<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>进程、线程复习篇 | 整理一些笔记</title><meta name="author" content="今晚不熬夜"><meta name="copyright" content="今晚不熬夜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#e4c6d0"><meta name="description" content="1.进程与线程 进程是执行程序的一次执行过程，是一个动态的概念，是系统分配资源的基本单位 一个进程可以包含若干个线程，线程是CPU调度和执行的单位  程序是指令、数据及其组织形式的描述，进程是程序的实体。 每个线程有自己独立的虚拟机栈、程序计数器 多个线程共享同一个进程中的结构：方法区、堆  单核CPU和多核CPU的理解：  单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线">
<meta property="og:type" content="article">
<meta property="og:title" content="进程、线程复习篇">
<meta property="og:url" content="http://quanquan170.github.io/2023/02/04/jin-cheng-xian-cheng-fu-xi-pian/index.html">
<meta property="og:site_name" content="整理一些笔记">
<meta property="og:description" content="1.进程与线程 进程是执行程序的一次执行过程，是一个动态的概念，是系统分配资源的基本单位 一个进程可以包含若干个线程，线程是CPU调度和执行的单位  程序是指令、数据及其组织形式的描述，进程是程序的实体。 每个线程有自己独立的虚拟机栈、程序计数器 多个线程共享同一个进程中的结构：方法区、堆  单核CPU和多核CPU的理解：  单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://quanquan170.github.io/img/background/bg_bggenerator_com%20(2).png">
<meta property="article:published_time" content="2023-02-04T11:18:20.000Z">
<meta property="article:modified_time" content="2023-03-20T07:50:40.787Z">
<meta property="article:author" content="今晚不熬夜">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://quanquan170.github.io/img/background/bg_bggenerator_com%20(2).png"><link rel="shortcut icon" href="/img/avatar.svg"><link rel="canonical" href="http://quanquan170.github.io/2023/02/04/jin-cheng-xian-cheng-fu-xi-pian/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"B8BRZ1L2TD","apiKey":"8bb4e18949e6c588f375c44adfbad5e0","indexName":"quan","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '进程、线程复习篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-20 15:50:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#41555d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#e4c6d0')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.svg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-fw icon-resume-line"></i><span> 关于作者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background/bg_bggenerator_com%20(2).png')"><nav id="nav"><span id="blog-info"><a href="/" title="整理一些笔记"><img class="site-icon" src="/img/avatar.svg"/><span class="site-name">今晚不熬夜</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-fw icon-resume-line"></i><span> 关于作者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">进程、线程复习篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-04T11:18:20.000Z" title="发表于 2023-02-04 19:18:20">2023-02-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-20T07:50:40.787Z" title="更新于 2023-03-20 15:50:40">2023-03-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%8D%E4%B9%A0/">复习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="进程、线程复习篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h3><ul>
<li>进程是执行程序的一次<strong>执行过程</strong>，是一个动态的概念，是系统<strong>分配资源</strong>的基本单位</li>
<li>一个进程可以包含若干个线程，线程是<strong>CPU调度和执行的单位</strong></li>
</ul>
<p><strong>程序</strong>是指令、数据及其组织形式的描述，进程是<strong>程序</strong>的实体。</p>
<p>每个线程有自己<strong>独立</strong>的<strong>虚拟机栈、程序计数器</strong></p>
<p>多个线程<strong>共享</strong>同一个进程中的结构：<strong>方法区、堆</strong></p>
<p><img src="/2023/02/04/jin-cheng-xian-cheng-fu-xi-pian/v2-2cdedcdf752a00bafc1ee9d9901580c0_r.jpg" alt="JVM结构体系"></p>
<p>单核CPU和多核CPU的理解：</p>
<ul>
<li>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程 的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费 才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以 把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时 间单元特别短，因此感觉不出来。</li>
<li>多核才能更好的发挥多线程的效率。（现在的服务器都是多核的）</li>
</ul>
<p>Java应用程序至少3个线程：</p>
<ul>
<li>main()主线程</li>
<li>gc()垃圾回收线程（典型的守护线程，如果JVM中只有守护线程，那么将退出）</li>
<li>异常处理线程</li>
</ul>
<p>并行与并发：</p>
<p>并行：多个CPU同时执行多个任务。多个人做多件事。</p>
<p>并发：一个CPU(采用时间片)同时执行多个任务。一个人做多件事。</p>
<h3 id="2-创建线程的方式："><a href="#2-创建线程的方式：" class="headerlink" title="2.创建线程的方式："></a>2.创建线程的方式：</h3><h4 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h4><ol>
<li>定义子类继承Thread类</li>
<li>子类中<strong>重写Thread类中的run方法</strong></li>
<li>创建Thread子类对象，即创建了线程对象</li>
<li>调用线程对象start方法：启动线程，调用run方法。</li>
</ol>
<p>注意：</p>
<ul>
<li>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式</li>
<li>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU 调度决定</li>
<li>想要启动多线程，必须调用start方法</li>
<li>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常“IllegalThreadStateException”，如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start()方法</li>
</ul>
<h4 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口:"></a>方式二：实现Runnable接口:</h4><ol>
<li>创建一个实现了Runnable接口的类</li>
<li>实现类去<strong>实现Runnable中的抽象方法</strong>: run()</li>
<li>创建实现类的对象</li>
<li>将<strong>此对象作为参数传递</strong>到Thread类的构造器中，创建Thread类的对象</li>
<li>通过Thread类的对象调用start()</li>
</ol>
<p>比较创建线程的两种方式：</p>
<p>开发中：优先选择实现Runnable接口的方式。原因如下:</p>
<ol>
<li>实现的方式没有类的<strong>单继承性的局限</strong>性</li>
<li>实现的方式更适合来处理<strong>多个线程</strong>有<strong>共享数据</strong>的情况。</li>
</ol>
<p>联系：<code>public class Thread extends Object implements Runnable</code></p>
<p>相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中，这两种方式要想启动线程，都要调用Thead类中的start()方法</p>
<h4 id="方法三：实现Callable接口：–-gt-JDK5-0以后新增的"><a href="#方法三：实现Callable接口：–-gt-JDK5-0以后新增的" class="headerlink" title="方法三：实现Callable接口：–>JDK5.0以后新增的"></a>方法三：实现Callable接口：–&gt;JDK5.0以后新增的</h4><ol>
<li><p>借助FutureTask执行</p>
<p>FutureTask类同时实现了两个接口，Future和Runnable接口，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//定义实现Callable接口的的实现类重写call方法。</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallableTask</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
           <span class="token comment">//TODO 线程执行方法</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token comment">//创建Callable对象</span>
<span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> mycallabletask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//开始线程</span>
<span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> futuretask<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>mycallabletask<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futuretask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
通过futuretask可以得到<span class="token class-name">MyCallableTask</span>的<span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的运行结果：
futuretask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</li>
<li><p>借助线程池来运行</p>
<ul>
<li>线程池中执行Callable任务原型：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
    <span class="token comment">//提交一个Callable任务，返回值为一个Future类型</span>
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
        <span class="token comment">//other methods...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>借助线程池来运行Callable任务的一般流程为</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> exec <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> exec<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCallableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>​		通过future可以得到MyCallableTask的call()的运行结果： future.get();</p>
</li>
</ol>
<h5 id="Runnable和Callable的区别："><a href="#Runnable和Callable的区别：" class="headerlink" title="Runnable和Callable的区别："></a>Runnable和Callable的区别：</h5><ul>
<li>1、Callable规定的方法是call(),Runnable规定的方法是run().</li>
<li>2、Callable的任务执行后可返回值（支持泛型的返回值），而Runnable的任务是不能返回值的</li>
<li>3、call方法可以抛出异常，run方法不可以</li>
<li>4、运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
</ul>
<h5 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h5><ul>
<li>Future是一个接口，代表了一个异步计算的结果。接口中的方法用来检查计算是否完成、等待完成和得到计算的结果。</li>
<li>当计算完成后，只能通过get()方法得到结果，get方法会阻塞直到结果准备好了。</li>
<li>如果想取消，那么调用cancel()方法。其他方法用于确定任务是正常完成还是取消了。</li>
<li>一旦计算完成了，那么这个计算就不能被取消。</li>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是 否完成、获取结果等。</li>
</ul>
<h5 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h5><ul>
<li>FutureTask类实现了RunnableFuture接口，而RunnnableFuture接口继承了Runnable和Future接口，所以说FutureTask是一个提供异步计算的结果的任务。</li>
<li>FutureTask可以用来包装Callable或者Runnbale对象。因为FutureTask实现了Runnable接口，所以FutureTask也可以被提交给Executor（如上面例子那样）。</li>
<li>FutrueTask是Futrue接口的唯一的实现类</li>
</ul>
<h4 id="方法四：使用线程池"><a href="#方法四：使用线程池" class="headerlink" title="方法四：使用线程池"></a>方法四：使用线程池</h4><ul>
<li><p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程， 对性能影响很大。</p>
</li>
<li><p>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完 放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交 通工具。</p>
</li>
<li><p>好处：</p>
<ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建） </li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ul>
</li>
<li><p>线程池相关的API：ExecutorService 和 Executors</p>
</li>
<li><p>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor</p>
<ul>
<li>void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行 Runnable</li>
<li>Future submit(Callable task)：执行任务，有返回值，一般又来执行 Callable</li>
<li>void shutdown() ：关闭连接池</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池<ul>
<li>Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池</li>
<li>Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池</li>
<li>Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池</li>
<li>Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运 行命令或者定期地执行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Java的调度方法</p>
<ul>
<li>同优先级线程组成先进先出队列（先到先服务），使用<strong>时间片</strong>策略</li>
<li>对高优先级，使用优先调度的抢占式策略</li>
</ul>
<p>注：</p>
<ul>
<li><p>线程创建时继承父线程的优先级</p>
</li>
<li><p>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用</p>
</li>
</ul>
<h3 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3.线程的生命周期"></a>3.线程的生命周期</h3><p>jdk5.0之前：</p>
<p><img src="/2023/02/04/jin-cheng-xian-cheng-fu-xi-pian/image-20230204201241175.png" alt="线程的生命周期"></p>
<p>suspend()方法可能死锁，所以不使用，resume()与其搭配，所以也过时啦</p>
<p>stop():一旦执行，线程就结束了，导致run()有未执行结束的代码。stop()会导致释放同步监视器，导致线程安全问题。（不推荐使用）</p>
<p>suspend(): 与resume()搭配使用，导致死锁。（不推荐使用）</p>
<p>jdk5.0之后：</p>
<p><img src="/2023/02/04/jin-cheng-xian-cheng-fu-xi-pian/image-20230227151448989.png"></p>
<h3 id="4-线程的同步"><a href="#4-线程的同步" class="headerlink" title="4.线程的同步"></a>4.线程的同步</h3><p>Java对于多线程的安全问题提供了专业的解决方式：同步机制</p>
<p>如何解决线程同步问题</p>
<h4 id="方法一：同步代码块"><a href="#方法一：同步代码块" class="headerlink" title="方法一：同步代码块"></a>方法一：同步代码块</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>对象<span class="token operator">/</span>同步监视器<span class="token punctuation">)</span><span class="token punctuation">{</span> 
	<span class="token comment">// 需要被同步的代码</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>说明:</p>
<ol>
<li>操作共享数据的代码，即为需要被同步的代码。–&gt;不能包含代码多了，也不能包含代码少了。</li>
<li><strong>共享数据</strong>:多个线程共同操作的变量。比如: ticket就是共享数据。</li>
<li><strong>同步监视器</strong>,俗称:锁。任何一个类的对象，都可以充当锁。<br>要求:多个线程必须要共用同一把锁。</li>
</ol>
<p>补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。<br>在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。</p>
<h4 id="方法二：synchronized还可以放在方法声明中，表示整个方法为同步方法。-例如："><a href="#方法二：synchronized还可以放在方法声明中，表示整个方法为同步方法。-例如：" class="headerlink" title="方法二：synchronized还可以放在方法声明中，表示整个方法为同步方法。 例如："></a>方法二：synchronized还可以放在方法声明中，表示整个方法为同步方法。 例如：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> show <span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//非静态方法锁的是this（当前对象）</span>
    <span class="token comment">//静态方法锁的是class</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</p>
<p>关于同步方法的总结:</p>
<ul>
<li>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</li>
<li>非静态的同步方法,同步监视器是: this<br>静态的同步方法，同步监视器是:当前类本身</li>
</ul>
<h4 id="方法三：Lock锁——JDK5-0新增"><a href="#方法三：Lock锁——JDK5-0新增" class="headerlink" title="方法三：Lock锁——JDK5.0新增"></a>方法三：Lock锁——JDK5.0新增</h4><p>ReentrantLock，意思是“可重入锁”。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReenTrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
        	<span class="token comment">//保证线程安全的代码;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">finally</span><span class="token punctuation">{</span>
        	lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a>synchronized 与 Lock 的对比</h5><ol>
<li>Lock是显式锁（<strong>手动开启和关闭锁</strong>，别忘记关闭锁），synchronized是 <strong>隐式锁</strong>，出了作用域<strong>自动释放</strong></li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有 更好的扩展性（提供更多的子类）</li>
</ol>
<p>优先使用顺序： Lock＞ 同步代码块（已经进入了方法体，分配了相应资源） ＞ 同步方法 （在方法体之外）</p>
<h5 id="释放锁的操作"><a href="#释放锁的操作" class="headerlink" title="释放锁的操作"></a>释放锁的操作</h5><ul>
<li>当前线程的同步方法、同步代码块执行结束。</li>
<li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、 该方法的继续执行。</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线 程暂停，并释放锁。</li>
</ul>
<h5 id="不会释放锁的操作"><a href="#不会释放锁的操作" class="headerlink" title="不会释放锁的操作"></a>不会释放锁的操作</h5><ul>
<li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、 Thread.yield()方法暂停当前线程的执行</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。<ul>
<li>应尽量避免使用suspend()和resume()来控制线程</li>
</ul>
</li>
</ul>
<h3 id="5-线程的通信"><a href="#5-线程的通信" class="headerlink" title="5.线程的通信"></a>5.线程的通信</h3><h4 id="wait-与-notify-和-notifyAll"><a href="#wait-与-notify-和-notifyAll" class="headerlink" title="wait() 与 notify() 和 notifyAll()"></a>wait() 与 notify() 和 notifyAll()</h4><ul>
<li>wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当 前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有 权后才能继续执行。</li>
<li>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待</li>
<li>notifyAll ()：唤醒正在排队等待资源的所有线程结束等待</li>
</ul>
<p>这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报 java.lang.IllegalMonitorStateException异常。</p>
<p>因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁， 因此这三个方法只能在<strong>Object类</strong>中声明。</p>
<p>三个方法的调用者必须是同步代码块或同步方法中的同步监视器。</p>
<p>wait():线程一旦执行此方法，就进入等待状态。同时，会释放对同步监视器的调用</p>
<p>notify():一旦执行此方法，就会唤醒被wait()的线程中优先级最高的那一个线程。(如果被wait()的多个线程的优先级相同，则<br>随机唤醒一个）。被唤醒的线程从当初被wait的位置继续执行。</p>
<p>notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。</p>
<h4 id="sleep-和wait-方法的异同："><a href="#sleep-和wait-方法的异同：" class="headerlink" title="sleep()和wait()方法的异同："></a>sleep()和wait()方法的异同：</h4><ol>
<li>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</li>
<li>不同点：<ol>
<li>两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</li>
<li>调用的范围不同：sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码块或同步方法中</li>
<li>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁</li>
</ol>
</li>
</ol>
<h3 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6.死锁"></a>6.死锁</h3><ol>
<li>如何看待死锁?</li>
</ol>
<p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。我们编写程序时，要避免出现死锁。</p>
<ol start="2">
<li>诱发死锁的原因?</li>
</ol>
<p>互斥条件<br>占用且等待<br>不可抢夺（或不可抢占) 循环等待<br>以上4个条件，同时出现就会触发死锁。</p>
<ol start="3">
<li>如何避免死锁?</li>
</ol>
<p>针对条件1:互斥条件基本上无法被破坏。因为线程需要通过互斥解决安全间题。</p>
<p>针对条件2:可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。</p>
<p>针对条件3:占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。</p>
<p>针对条件4:可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。</p>
<p>本文绝大部分来源为尚硅谷课件</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/05/java-guan-jian-zi-zong-jie-bu-chang-yong/" title="Java关键字学习（更新中）"><div class="cover" style="background: url(/img/background/bg_bggenerator_com.jpg)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java关键字学习（更新中）</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/" title="计算机网络大作业"><img class="cover" src="/img/background/bg_bggenerator_com%20(2).png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络大作业</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/05/file-yu-io/" title="File与IO"><img class="cover" src="/img/background/bg_bggenerator_com%20(2).png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">File与IO</div></div></a></div><div><a href="/2023/03/05/java-guan-jian-zi-zong-jie-bu-chang-yong/" title="Java关键字学习（更新中）"><div class="cover" style="background: url(/img/background/bg_bggenerator_com.jpg)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">Java关键字学习（更新中）</div></div></a></div><div><a href="/2023/03/20/dan-li-mo-shi-zui-hao-shi-xian-fang-shi/" title="一些单例模式的对比"><img class="cover" src="/img/background/bg_bggenerator_com%20(2).png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="title">一些单例模式的对比</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.svg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">今晚不熬夜</div><div class="author-info__description">别急~惊喜在路上！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/quanquan170"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/quanquan170" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1480105462@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/1480105462" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">来了都是缘分，祝你今天高兴</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.进程与线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">2.创建线程的方式：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-text">方式一：继承Thread类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-text">方式二：实现Runnable接口:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%EF%BC%9A%E2%80%93-gt-JDK5-0%E4%BB%A5%E5%90%8E%E6%96%B0%E5%A2%9E%E7%9A%84"><span class="toc-text">方法三：实现Callable接口：–&gt;JDK5.0以后新增的</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Runnable%E5%92%8CCallable%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">Runnable和Callable的区别：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Future%E6%8E%A5%E5%8F%A3"><span class="toc-text">Future接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FutureTask%E7%B1%BB"><span class="toc-text">FutureTask类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">方法四：使用线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3.线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-text">4.线程的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">方法一：同步代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9Asynchronized%E8%BF%98%E5%8F%AF%E4%BB%A5%E6%94%BE%E5%9C%A8%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E%E4%B8%AD%EF%BC%8C%E8%A1%A8%E7%A4%BA%E6%95%B4%E4%B8%AA%E6%96%B9%E6%B3%95%E4%B8%BA%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E3%80%82-%E4%BE%8B%E5%A6%82%EF%BC%9A"><span class="toc-text">方法二：synchronized还可以放在方法声明中，表示整个方法为同步方法。 例如：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9ALock%E9%94%81%E2%80%94%E2%80%94JDK5-0%E6%96%B0%E5%A2%9E"><span class="toc-text">方法三：Lock锁——JDK5.0新增</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#synchronized-%E4%B8%8E-Lock-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">synchronized 与 Lock 的对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">释放锁的操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">不会释放锁的操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">5.线程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-%E4%B8%8E-notify-%E5%92%8C-notifyAll"><span class="toc-text">wait() 与 notify() 和 notifyAll()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep-%E5%92%8Cwait-%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9A"><span class="toc-text">sleep()和wait()方法的异同：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%AD%BB%E9%94%81"><span class="toc-text">6.死锁</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/06/mian-jing-wu-23.05.6/" title="面经五23.05.06">面经五23.05.06</a><time datetime="2023-05-06T07:20:20.000Z" title="发表于 2023-05-06 15:20:20">2023-05-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/28/mian-jing-wen-ti-zheng-li-ban/" title="面经问题汇总（更新中）">面经问题汇总（更新中）</a><time datetime="2023-04-28T07:20:20.000Z" title="发表于 2023-04-28 15:20:20">2023-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/27/mian-jing-si-23.04.27/" title="面经四23.04.27">面经四23.04.27</a><time datetime="2023-04-27T07:20:20.000Z" title="发表于 2023-04-27 15:20:20">2023-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/22/mysql-fen-ku-fen-biao/" title="MySQL——分库分表">MySQL——分库分表</a><time datetime="2023-04-22T09:03:20.000Z" title="发表于 2023-04-22 17:03:20">2023-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/20/mian-jing-san-23.04.20/" title="面经三23.04.20">面经三23.04.20</a><time datetime="2023-04-20T07:20:20.000Z" title="发表于 2023-04-20 15:20:20">2023-04-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/background/bg_bggenerator_com%20(2).png')"><div id="footer-wrap"><div class="footer_custom_text">谢谢看到这er~没有更多了奥</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></body></html>