<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Redis——SDS结构模型 | 整理一些笔记</title><meta name="author" content="今晚不熬夜"><meta name="copyright" content="今晚不熬夜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#e4c6d0"><meta name="description" content="1 数据结构 SDS（Simple Dynamic String，简单动态字符串）,源码底层就是typedef char *sds; Redis3.x  SDS的数据结构定义 struct sdshdr {     &#x2F;&#x2F;记录buf数组中已使用字节的数量     &#x2F;&#x2F;等于SDS所保存字符串的长度     unsigned int len;      &#x2F;&#x2F;记录buf数组中未使用字节的数量     un">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis——SDS结构模型">
<meta property="og:url" content="http://quanquan170.github.io/2023/03/19/redis-sds/index.html">
<meta property="og:site_name" content="整理一些笔记">
<meta property="og:description" content="1 数据结构 SDS（Simple Dynamic String，简单动态字符串）,源码底层就是typedef char *sds; Redis3.x  SDS的数据结构定义 struct sdshdr {     &#x2F;&#x2F;记录buf数组中已使用字节的数量     &#x2F;&#x2F;等于SDS所保存字符串的长度     unsigned int len;      &#x2F;&#x2F;记录buf数组中未使用字节的数量     un">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://quanquan170.github.io/img/background/bg_bggenerator_com%20(2).png">
<meta property="article:published_time" content="2023-03-19T05:01:20.000Z">
<meta property="article:modified_time" content="2023-03-21T06:12:36.729Z">
<meta property="article:author" content="今晚不熬夜">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://quanquan170.github.io/img/background/bg_bggenerator_com%20(2).png"><link rel="shortcut icon" href="/img/avatar.svg"><link rel="canonical" href="http://quanquan170.github.io/2023/03/19/redis-sds/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"B8BRZ1L2TD","apiKey":"8bb4e18949e6c588f375c44adfbad5e0","indexName":"quan","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis——SDS结构模型',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-21 14:12:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#41555d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#e4c6d0')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.svg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-fw icon-resume-line"></i><span> 关于作者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: url(/img/imgs/redis.png)"><nav id="nav"><span id="blog-info"><a href="/" title="整理一些笔记"><img class="site-icon" src="/img/avatar.svg"/><span class="site-name">今晚不熬夜</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-fw icon-resume-line"></i><span> 关于作者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis——SDS结构模型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-19T05:01:20.000Z" title="发表于 2023-03-19 13:01:20">2023-03-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-21T06:12:36.729Z" title="更新于 2023-03-21 14:12:36">2023-03-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis——SDS结构模型"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h2><p> SDS（Simple Dynamic String，简单动态字符串）,源码底层就是<code>typedef char *sds;</code></p>
<p>Redis3.x  SDS的数据结构定义</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sdshdr</span> <span class="token punctuation">{</span>
    <span class="token comment">//记录buf数组中已使用字节的数量</span>
    <span class="token comment">//等于SDS所保存字符串的长度</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">;</span>

    <span class="token comment">//记录buf数组中未使用字节的数量</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> free<span class="token punctuation">;</span>

    <span class="token comment">//char数组，用于保存字符串</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>buf 尾部自动追加一个’\0’字符并不会计算在 SDS 的len中，这是为了遵循 C 字符串以空字符串结尾的惯例，使得 SDS 可以直接使用一部分string.h库中的函数，如strlen</p>
</blockquote>
<h2 id="2-数据优化"><a href="#2-数据优化" class="headerlink" title="2 数据优化"></a>2 数据优化</h2><h3 id="2-1-数据结构优化"><a href="#2-1-数据结构优化" class="headerlink" title="2.1 数据结构优化"></a>2.1 数据结构优化</h3><p>在 Redis3.x 版本中<strong>不同长度的字符串占用的头部是相同的</strong>，如果某一字符串很短但是头部却占用了更多的空间造成空间浪费。所以SDS 分为三种级别的字符串：<strong>共有五种类型的SDS（长度小于1字节、1字节、2字节、4字节、8字节）</strong></p>
<ul>
<li>短字符串(长度小于32)，len和free的长度用1字节即可；</li>
<li>长字符串，用2字节或者4字节；</li>
<li>超长字符串，用8字节。</li>
</ul>
<blockquote>
<p>低三位存储类型，高5位存储长度，最多能标识的长度为32，所以短字符串的长度必定小于32。</p>
<p><strong>无需free字段了，32-len即为free</strong></p>
</blockquote>
<h4 id="Redis6-x实现"><a href="#Redis6-x实现" class="headerlink" title="Redis6.x实现"></a><strong>Redis6.x</strong>实现</h4><p>注意其中flags标识字段为char类型</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 注意：sdshdr5从未被使用，Redis中只是访问flags。</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr5</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 低3位存储类型, 高5位存储长度 */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* 已使用 */</span>
    <span class="token class-name">uint8_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* 总长度，用1字节存储 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 低3位存储类型, 高5位预留 */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr16</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint16_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* 已使用 */</span>
    <span class="token class-name">uint16_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* 总长度，用2字节存储 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 低3位存储类型, 高5位预留 */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr32</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* 已使用 */</span>
    <span class="token class-name">uint32_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* 总长度，用4字节存储 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 低3位存储类型, 高5位预留 */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr64</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint64_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* 已使用 */</span>
    <span class="token class-name">uint64_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* 总长度，用8字节存储 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 低3位存储类型, 高5位预留 */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-2-uintX-t"><a href="#2-2-uintX-t" class="headerlink" title="2.2 uintX_t"></a>2.2 uintX_t</h3><p>Redis6.x 中 int 类型也多出了几种：<code>uint8_t / uint16_t / uint32_t /uint64_t</code>。</p>
<p>定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token class-name">uint8_t</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token class-name">uint16_t</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token class-name">uint32_t</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token class-name">uint64_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-3-对齐填充"><a href="#2-3-对齐填充" class="headerlink" title="2.3 对齐填充"></a>2.3 对齐填充</h3><p>现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。</p>
<p>但实际中在访问特定类型变量时经常在特定的内存地址访问，这就<strong>需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。</strong></p>
<p>对齐的原因：由于各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。最常见的是如果不按照适合其平台的要求对数据存放进行对齐，会在存取效率上带来损失。</p>
<blockquote>
<p>注：我们写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略。</p>
</blockquote>
<h5 id="Redis为什么不对齐呢？"><a href="#Redis为什么不对齐呢？" class="headerlink" title="Redis为什么不对齐呢？"></a>Redis为什么不对齐呢？</h5><p>综上所述我们知道了对齐填充可以提高 CPU 的数据读取效率，作为 IO 频繁的 <strong>Redis 为什么选择不对齐呢？</strong></p>
<p>Redis6.x 中的 SDS 结构：</p>
<p><img src="/2023/03/19/redis-sds/640-16792039812082.png"></p>
<blockquote>
<p>细节：SDS 的指针并不是指向 SDS 的起始位置（len位置），而是直接指向buf[]，使得 SDS 可以直接使用 C 语言string.h库中的某些函数，做到了兼容</p>
</blockquote>
<p>如果不进行对齐填充，那么在获取当前 SDS 的类型时则只需要后退一步即可<code>flagsPointer = ((unsigned char*)s)-1</code>；相反，若进行对齐填充，由于 Padding 的存在，我们在不同的系统中不知道退多少才能获得flags，并且我们也不能将 sds 的指针指向flags，这样就无法兼容 C 语言的函数了，也不知道前进多少才能得到 buf[]。</p>
<h2 id="3-SDS-优势"><a href="#3-SDS-优势" class="headerlink" title="3 SDS 优势"></a>3 SDS 优势</h2><h3 id="3-1-O-1-时间复杂度获取字符串长度"><a href="#3-1-O-1-时间复杂度获取字符串长度" class="headerlink" title="3.1 O(1)时间复杂度获取字符串长度"></a>3.1 O(1)时间复杂度获取字符串长度</h3><p>由于C字符串不记录自身的长度，所以为了获取一个字符串的长度程序必须遍历这个字符串，直至遇到’＼0’为止，整个操作的时间复杂度为O(N)。而我们使用SDS封装字符串则直接获取<code>len</code>属性值即可，时间复杂度为O(1)。</p>
<h3 id="3-2-二进制安全"><a href="#3-2-二进制安全" class="headerlink" title="3.2 二进制安全"></a>3.2 二进制安全</h3><p>通俗地讲，C语言中，用’\0’表示字符串的结束，如果字符串本身就有’\0’字符，字符串就会被截断，即非二进制安全；若通过某种机制，保证读写字符串时不损害其内容，则是二进制安全。</p>
<p>C字符串中的字符除了末尾字符为’\0’外其他字符不能为空字符，否则会被认为是字符串结尾(即使实际上不是)。</p>
<p>这限制了C字符串只能保存文本数据，而不能保存二进制数据。而SDS使用<code>len</code>属性的值判断字符串是否结束，所以不会受’\0’的影响。</p>
<h3 id="3-3-杜绝缓冲区溢出"><a href="#3-3-杜绝缓冲区溢出" class="headerlink" title="3.3 杜绝缓冲区溢出"></a>3.3 杜绝缓冲区溢出</h3><p>字符串的拼接操作是使用十分频繁的，在C语言开发中使用<code>char *strcat(char *dest,const char *src)</code>方法将<code>src</code>字符串中的内容拼接到<code>dest</code>字符串的末尾。由于C字符串不记录自身的长度，所有<code>strcat</code>方法已经认为用户在执行此函数时已经为<code>dest</code>分配了足够多的内存，足以容纳<code>src</code>字符串中的所有内容，而一旦这个条件不成立就会产生缓冲区溢出，会把其他数据覆盖掉。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// strcat 源码</span>
<span class="token keyword">char</span> <span class="token operator">*</span> __cdecl <span class="token function">strcat</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> src<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span> cp <span class="token operator">=</span> dst<span class="token punctuation">;</span>
 
    <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token operator">*</span>cp <span class="token punctuation">)</span>
        cp<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">/* 找到 dst 的结尾 */</span>
 
    <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token operator">*</span>cp<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">/* 无脑将 src 复制到 dst 中 */</span>
 
    <span class="token keyword">return</span><span class="token punctuation">(</span> dst <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 返回 dst */</span>
<span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>与C字符串不同，SDS 的<strong>自动扩容机制</strong>完全杜绝了发生缓冲区溢出的可能性：</p>
<p><strong>当SDS API需要对SDS进行修改时，API会先检查 SDS 的空间是否满足修改所需的要求，如果不满足，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改SDS的空间大小，也不会出现缓冲区溢出问题。</strong> </p>
<p>SDS 的<code>sds sdscat(sds s, const char *t)</code>方法在字符串拼接时会进行扩容相关操作。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">sds <span class="token function">sdscatsds</span><span class="token punctuation">(</span>sds s<span class="token punctuation">,</span> <span class="token keyword">const</span> sds t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* s: 源字符串
 * t: 待拼接字符串
 * len: 待拼接字符串长度
 */</span>
sds <span class="token function">sdscatlen</span><span class="token punctuation">(</span>sds s<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>t<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取源字符串长度</span>
    <span class="token class-name">size_t</span> curlen <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token comment">// SDS 分配空间（自动扩容机制）</span>
    s <span class="token operator">=</span> <span class="token function">sdsMakeRoomFor</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment">// 将目标字符串拷贝至源字符串末尾</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>s<span class="token operator">+</span>curlen<span class="token punctuation">,</span> t<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 更新 SDS 长度</span>
    <span class="token function">sdssetlen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> curlen<span class="token operator">+</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 追加结束符</span>
    s<span class="token punctuation">[</span>curlen<span class="token operator">+</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="自动扩容机制——sdsMakeRoomFor方法"><a href="#自动扩容机制——sdsMakeRoomFor方法" class="headerlink" title="自动扩容机制——sdsMakeRoomFor方法"></a>自动扩容机制——sdsMakeRoomFor方法</h5><p><code>strcatlen</code>中调用<code>sdsMakeRoomFor</code>完成字符串的容量检查及扩容操作，重点分析此方法：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* s: 源字符串
 * addlen: 新增长度
 */</span>
sds <span class="token function">sdsMakeRoomFor</span><span class="token punctuation">(</span>sds s<span class="token punctuation">,</span> <span class="token class-name">size_t</span> addlen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>sh<span class="token punctuation">,</span> <span class="token operator">*</span>newsh<span class="token punctuation">;</span>
    <span class="token comment">// sdsavail: s-&gt;alloc - s-&gt;len, 获取 SDS 的剩余长度</span>
    <span class="token class-name">size_t</span> avail <span class="token operator">=</span> <span class="token function">sdsavail</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> newlen<span class="token punctuation">,</span> reqlen<span class="token punctuation">;</span>
    <span class="token comment">// 根据 flags 获取 SDS 的类型 oldtype</span>
    <span class="token keyword">char</span> type<span class="token punctuation">,</span> oldtype <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> SDS_TYPE_MASK<span class="token punctuation">;</span>
    <span class="token keyword">int</span> hdrlen<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> usable<span class="token punctuation">;</span>

    <span class="token comment">/* Return ASAP if there is enough space left. */</span>
    <span class="token comment">// 剩余空间大于等于新增空间，无需扩容，直接返回源字符串</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>avail <span class="token operator">&gt;=</span> addlen<span class="token punctuation">)</span> <span class="token keyword">return</span> s<span class="token punctuation">;</span>
    <span class="token comment">// 获取当前长度</span>
    len <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// </span>
    sh <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token operator">-</span><span class="token function">sdsHdrSize</span><span class="token punctuation">(</span>oldtype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 新长度</span>
    reqlen <span class="token operator">=</span> newlen <span class="token operator">=</span> <span class="token punctuation">(</span>len<span class="token operator">+</span>addlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 断言新长度比原长度长，否则终止执行</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>newlen <span class="token operator">&gt;</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* 防止数据溢出 */</span>
    <span class="token comment">// SDS_MAX_PREALLOC = 1024*1024, 即1MB</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newlen <span class="token operator">&lt;</span> SDS_MAX_PREALLOC<span class="token punctuation">)</span>
        <span class="token comment">// 新增后长度小于 1MB ，则按新长度的两倍扩容</span>
        newlen <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token comment">// 新增后长度大于 1MB ，则按新长度加上 1MB 扩容</span>
        newlen <span class="token operator">+=</span> SDS_MAX_PREALLOC<span class="token punctuation">;</span>
    <span class="token comment">// 重新计算 SDS 的类型</span>
    type <span class="token operator">=</span> <span class="token function">sdsReqType</span><span class="token punctuation">(</span>newlen<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Don't use type 5: the user is appending to the string and type 5 is
     * not able to remember empty space, so sdsMakeRoomFor() must be called
     * at every appending operation. */</span>
    <span class="token comment">// 不使用 sdshdr5 </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> SDS_TYPE_5<span class="token punctuation">)</span> type <span class="token operator">=</span> SDS_TYPE_8<span class="token punctuation">;</span>
    <span class="token comment">// 获取新的 header 大小</span>
    hdrlen <span class="token operator">=</span> <span class="token function">sdsHdrSize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>hdrlen <span class="token operator">+</span> newlen <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;</span> reqlen<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Catch size_t overflow */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldtype<span class="token operator">==</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 类型没变</span>
        <span class="token comment">// 调用 s_realloc_usable 重新分配可用内存，返回新 SDS 的头部指针</span>
        <span class="token comment">// usable 会被设置为当前分配的大小</span>
        newsh <span class="token operator">=</span> <span class="token function">s_realloc_usable</span><span class="token punctuation">(</span>sh<span class="token punctuation">,</span> hdrlen<span class="token operator">+</span>newlen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>usable<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newsh <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 分配失败直接返回NULL</span>
        <span class="token comment">// 获取指向 buf 的指针</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>newsh<span class="token operator">+</span>hdrlen<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 类型变化导致 header 的大小也变化，需要向前移动字符串，不能使用 realloc</span>
        newsh <span class="token operator">=</span> <span class="token function">s_malloc_usable</span><span class="token punctuation">(</span>hdrlen<span class="token operator">+</span>newlen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>usable<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newsh <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token comment">// 将原字符串copy至新空间中</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>newsh<span class="token operator">+</span>hdrlen<span class="token punctuation">,</span> s<span class="token punctuation">,</span> len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 释放原字符串内存</span>
        <span class="token function">s_free</span><span class="token punctuation">(</span>sh<span class="token punctuation">)</span><span class="token punctuation">;</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>newsh<span class="token operator">+</span>hdrlen<span class="token punctuation">;</span>
        <span class="token comment">// 更新 SDS 类型</span>
        s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> type<span class="token punctuation">;</span>
        <span class="token comment">// 设置长度</span>
        <span class="token function">sdssetlen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 获取 buf 总长度(待定)</span>
    usable <span class="token operator">=</span> usable<span class="token operator">-</span>hdrlen<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>usable <span class="token operator">&gt;</span> <span class="token function">sdsTypeMaxSize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 若可用空间大于当前类型支持的最大长度则截断</span>
        usable <span class="token operator">=</span> <span class="token function">sdsTypeMaxSize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置 buf 总长度</span>
    <span class="token function">sdssetalloc</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> usable<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="自动扩容机制总结："><a href="#自动扩容机制总结：" class="headerlink" title="自动扩容机制总结："></a>自动扩容机制总结：</h5><p><strong>扩容阶段：</strong></p>
<ul>
<li>若 SDS 中剩余空闲空间 avail 大于新增内容的长度 addlen，则无需扩容；</li>
<li>若 SDS 中剩余空闲空间 avail 小于或等于新增内容的长度 addlen：<ul>
<li>若新增后总长度 len+addlen &lt; 1MB，则按新长度的两倍扩容；</li>
<li>若新增后总长度 len+addlen &gt; 1MB，则按新长度加上 1MB 扩容。</li>
</ul>
</li>
</ul>
<p><strong>内存分配阶段：</strong></p>
<ul>
<li>根据扩容后的长度选择对应的 SDS 类型：<ul>
<li>若类型不变，则只需通过 <code>s_realloc_usable</code>扩大 buf 数组即可；</li>
<li>若类型变化，则需要为整个 SDS 重新分配内存，并将原来的 SDS 内容拷贝至新位置。</li>
</ul>
</li>
</ul>
<p><strong>自动扩容流程图：</strong></p>
<p><img src="/2023/03/19/redis-sds/640.png"></p>
<blockquote>
<p>扩容后的 SDS 不会恰好容纳下新增的字符，而是多分配了一些空间(预分配策略)，这减少了修改字符串时带来的内存重分配次数</p>
</blockquote>
<h5 id="根据不同的type确定对应的数据结构——sdsHdrSize方法"><a href="#根据不同的type确定对应的数据结构——sdsHdrSize方法" class="headerlink" title="根据不同的type确定对应的数据结构——sdsHdrSize方法"></a>根据不同的type确定对应的数据结构——sdsHdrSize方法</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">sdsHdrSize</span><span class="token punctuation">(</span><span class="token keyword">char</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// #define SDS_TYPE_MASK 7，二进制为0000 0111</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>type<span class="token operator">&amp;</span>SDS_TYPE_MASK<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// #define SDS_TYPE_5  0</span>
        <span class="token keyword">case</span> SDS_TYPE_5<span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sdshdr5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// #define SDS_TYPE_8  1</span>
        <span class="token keyword">case</span> SDS_TYPE_8<span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sdshdr8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// #define SDS_TYPE_16 2</span>
        <span class="token keyword">case</span> SDS_TYPE_16<span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sdshdr16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// #define SDS_TYPE_32 3</span>
        <span class="token keyword">case</span> SDS_TYPE_32<span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sdshdr32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// #define SDS_TYPE_64 4</span>
        <span class="token keyword">case</span> SDS_TYPE_64<span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sdshdr64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="根据字符串长度选择对应数据结构——sdsReqType方法"><a href="#根据字符串长度选择对应数据结构——sdsReqType方法" class="headerlink" title="根据字符串长度选择对应数据结构——sdsReqType方法"></a>根据字符串长度选择对应数据结构——sdsReqType方法</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">char</span> <span class="token function">sdsReqType</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> string_size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>string_size <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span>
       <span class="token comment">// #define SDS_TYPE_5  0</span>
        <span class="token keyword">return</span> SDS_TYPE_5<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>string_size <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span>
        <span class="token comment">// #define SDS_TYPE_8  1</span>
        <span class="token keyword">return</span> SDS_TYPE_8<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>string_size <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span>
        <span class="token comment">// #define SDS_TYPE_16 2</span>
        <span class="token keyword">return</span> SDS_TYPE_16<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>LONG_MAX <span class="token operator">==</span> LLONG_MAX<span class="token punctuation">)</span></span></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>string_size <span class="token operator">&lt;</span> <span class="token number">1ll</span><span class="token operator">&lt;&lt;</span><span class="token number">32</span><span class="token punctuation">)</span>
        <span class="token comment">// #define SDS_TYPE_32 3</span>
        <span class="token keyword">return</span> SDS_TYPE_32<span class="token punctuation">;</span>
    <span class="token comment">// #define SDS_TYPE_64 4</span>
    <span class="token keyword">return</span> SDS_TYPE_64<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token keyword">return</span> SDS_TYPE_32<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过位运算<code>type&amp;SDS_TYPE_MASK</code>选择对应的数据结构，和子网划分有点相似，都是和一个MASK做位运算。</p>
<h3 id="3-4-内存重分配次数优化"><a href="#3-4-内存重分配次数优化" class="headerlink" title="3.4 内存重分配次数优化"></a>3.4 内存重分配次数优化</h3><h5 id="1-空间预分配策略"><a href="#1-空间预分配策略" class="headerlink" title="(1) 空间预分配策略"></a>(1) 空间预分配策略</h5><p>因为 SDS 的空间预分配策略， SDS 字符串在增长过程中不会频繁的进行空间分配。</p>
<p>通过这种分配策略，SDS 将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次。</p>
<h5 id="2-惰性空间释放机制"><a href="#2-惰性空间释放机制" class="headerlink" title="(2) 惰性空间释放机制"></a>(2) 惰性空间释放机制</h5><p>空间预分配策略用于优化 SDS 增长时频繁进行空间分配，而惰性空间释放机制则用于优化 SDS 字符串缩短时并不立即使用内存重分配来回收缩短后多出来的空间，而仅仅更新 SDS 的len属性，多出来的空间供将来使用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* sdstrim 方法删除字符串cset中出现的所有字符
 */</span>
sds <span class="token function">sdstrim</span><span class="token punctuation">(</span>sds s<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cset<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>start<span class="token punctuation">,</span> <span class="token operator">*</span>end<span class="token punctuation">,</span> <span class="token operator">*</span>sp<span class="token punctuation">,</span> <span class="token operator">*</span>ep<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> len<span class="token punctuation">;</span>

    sp <span class="token operator">=</span> start <span class="token operator">=</span> s<span class="token punctuation">;</span>
    ep <span class="token operator">=</span> end <span class="token operator">=</span> s<span class="token operator">+</span><span class="token function">sdslen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// strchr()函数用于查找给定字符串中某一个特定字符</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>sp <span class="token operator">&lt;=</span> end <span class="token operator">&amp;&amp;</span> <span class="token function">strchr</span><span class="token punctuation">(</span>cset<span class="token punctuation">,</span> <span class="token operator">*</span>sp<span class="token punctuation">)</span><span class="token punctuation">)</span> sp<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>ep <span class="token operator">&gt;</span> sp <span class="token operator">&amp;&amp;</span> <span class="token function">strchr</span><span class="token punctuation">(</span>cset<span class="token punctuation">,</span> <span class="token operator">*</span>ep<span class="token punctuation">)</span><span class="token punctuation">)</span> ep<span class="token operator">--</span><span class="token punctuation">;</span>
    len <span class="token operator">=</span> <span class="token punctuation">(</span>sp <span class="token operator">&gt;</span> ep<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ep<span class="token operator">-</span>sp<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> sp<span class="token punctuation">)</span> <span class="token function">memmove</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> sp<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
    <span class="token comment">// 仅仅更新了len</span>
    <span class="token function">sdssetlen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>在《Redis的设计与实现》一书中针对 sdstrim方法的讲解为：<strong>删除字符串中 cset 出现的所有字符</strong>，而不是首尾。</p>
<p>比如：调用sdstrim(“XYXaYYbcXyY”,”XY”)，后移除了所有的’X’和’Y’。这是错误❌的~</p>
</blockquote>
<p>SDS 并没有释放多出来的5字节空间，仅仅将 len 设置成了7，剩余空间为5。如果后续字符串增长时则可以派上用场（可能不需要再分配内存）。</p>
<p>也许各位又会有疑问了，<strong>这没真正释放空间，是否会导致内存泄漏呢</strong>？</p>
<p>放心，SDS为我们提供了真正释放SDS未使用空间的方法<code>sdsRemoveFreeSpace</code>。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">sds <span class="token function">sdsRemoveFreeSpace</span><span class="token punctuation">(</span>sds s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>sh<span class="token punctuation">,</span> <span class="token operator">*</span>newsh<span class="token punctuation">;</span>
    <span class="token comment">// 获取类型</span>
    <span class="token keyword">char</span> type<span class="token punctuation">,</span> oldtype <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> SDS_TYPE_MASK<span class="token punctuation">;</span>
    <span class="token comment">// 获取 header 大小</span>
    <span class="token keyword">int</span> hdrlen<span class="token punctuation">,</span> oldhdrlen <span class="token operator">=</span> <span class="token function">sdsHdrSize</span><span class="token punctuation">(</span>oldtype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取原字符串长度</span>
    <span class="token class-name">size_t</span> len <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取可用长度</span>
    <span class="token class-name">size_t</span> avail <span class="token operator">=</span> <span class="token function">sdsavail</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取指向头部的指针</span>
    sh <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token operator">-</span>oldhdrlen<span class="token punctuation">;</span>

    <span class="token comment">/* Return ASAP if there is no space left. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>avail <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> s<span class="token punctuation">;</span>

    <span class="token comment">// 查找适合这个字符串长度的最优 SDS 类型</span>
    type <span class="token operator">=</span> <span class="token function">sdsReqType</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    hdrlen <span class="token operator">=</span> <span class="token function">sdsHdrSize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* 如果类型相同，或者至少仍然需要一个足够大的类型，我们只需 realloc buf即可；
     * 否则，说明变化很大，则手动重新分配字符串以使用不同的头文件类型。
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldtype<span class="token operator">==</span>type <span class="token operator">||</span> type <span class="token operator">&gt;</span> SDS_TYPE_8<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        newsh <span class="token operator">=</span> <span class="token function">s_realloc</span><span class="token punctuation">(</span>sh<span class="token punctuation">,</span> oldhdrlen<span class="token operator">+</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newsh <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>newsh<span class="token operator">+</span>oldhdrlen<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        newsh <span class="token operator">=</span> <span class="token function">s_malloc</span><span class="token punctuation">(</span>hdrlen<span class="token operator">+</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newsh <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>newsh<span class="token operator">+</span>hdrlen<span class="token punctuation">,</span> s<span class="token punctuation">,</span> len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 释放内存</span>
        <span class="token function">s_free</span><span class="token punctuation">(</span>sh<span class="token punctuation">)</span><span class="token punctuation">;</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>newsh<span class="token operator">+</span>hdrlen<span class="token punctuation">;</span>
        s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> type<span class="token punctuation">;</span>
        <span class="token function">sdssetlen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 重新设置总长度为len</span>
    <span class="token function">sdssetalloc</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="4-SDS-最长多少？"><a href="#4-SDS-最长多少？" class="headerlink" title="4 SDS 最长多少？"></a>4 SDS 最长多少？</h2><p><strong>在 Reids3.x 版本中<code>len</code>是使用int修饰的，这就会导致 buf 最长就是<code>2147483647</code>，无形中限制了字符串的最大长度为512MB。</strong></p>
<p>在<code>_sdsnewlen</code>方法创建 SDS 中都会调用<code>sdsTypeMaxSize</code>方法获取每种类型所能创建的最大buf长度，不难发现此方法最大的返回值为<code>2147483647</code>，即512MB。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//Redis3.0.0中不存在</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token class-name">size_t</span> <span class="token function">sdsTypeMaxSize</span><span class="token punctuation">(</span><span class="token keyword">char</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> SDS_TYPE_5<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> SDS_TYPE_8<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> SDS_TYPE_16<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>LONG_MAX <span class="token operator">==</span> LLONG_MAX<span class="token punctuation">)</span></span></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> SDS_TYPE_32<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1ll</span><span class="token operator">&lt;&lt;</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 不管方法啥意思，最大返回2147483647。OVER~</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* this is equivalent to the max SDS_TYPE_64 or SDS_TYPE_32 */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="5-部分-API-源码解读"><a href="#5-部分-API-源码解读" class="headerlink" title="5 部分 API 源码解读"></a>5 部分 API 源码解读</h2><h4 id="创建SDS"><a href="#创建SDS" class="headerlink" title="创建SDS"></a>创建SDS</h4><p>Redis 通过<code>sdsnewlen</code>方法创建 SDS。在方法中会根据字符串初始化长度选择合适的类型。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">sds <span class="token function">_sdsnewlen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>init<span class="token punctuation">,</span> <span class="token class-name">size_t</span> initlen<span class="token punctuation">,</span> <span class="token keyword">int</span> trymalloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>sh<span class="token punctuation">;</span>
    sds s<span class="token punctuation">;</span>
    <span class="token comment">// 根据初始化长度判断 SDS 的类型</span>
    <span class="token keyword">char</span> type <span class="token operator">=</span> <span class="token function">sdsReqType</span><span class="token punctuation">(</span>initlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// SDS_TYPE_5 强制转换为 SDS_TYPE_8</span>
    <span class="token comment">// 这样侧面验证了 sdshdr5 从未被使用</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> SDS_TYPE_5 <span class="token operator">&amp;&amp;</span> initlen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> type <span class="token operator">=</span> SDS_TYPE_8<span class="token punctuation">;</span>
    <span class="token comment">// 获取头部大小</span>
    <span class="token keyword">int</span> hdrlen <span class="token operator">=</span> <span class="token function">sdsHdrSize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 指向 flags 的指针</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>fp<span class="token punctuation">;</span> <span class="token comment">/* flags pointer. */</span>
    <span class="token comment">// 分配的空间</span>
    <span class="token class-name">size_t</span> usable<span class="token punctuation">;</span>
    <span class="token comment">// 防止溢出</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>initlen <span class="token operator">+</span> hdrlen <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;</span> initlen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Catch size_t overflow */</span>
    <span class="token comment">// 分配空间</span>
    <span class="token comment">// s_trymalloc_usable: 尝试分配内存，失败则返回NULL</span>
    <span class="token comment">// s_malloc_usable: 分配内存或者抛异常[不友好]</span>
    sh <span class="token operator">=</span> trymalloc<span class="token operator">?</span>
        <span class="token function">s_trymalloc_usable</span><span class="token punctuation">(</span>hdrlen<span class="token operator">+</span>initlen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>usable<span class="token punctuation">)</span> <span class="token operator">:</span>
        <span class="token function">s_malloc_usable</span><span class="token punctuation">(</span>hdrlen<span class="token operator">+</span>initlen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>usable<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sh <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>init<span class="token operator">==</span>SDS_NOINIT<span class="token punctuation">)</span>
        init <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>init<span class="token punctuation">)</span>
        <span class="token function">memset</span><span class="token punctuation">(</span>sh<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> hdrlen<span class="token operator">+</span>initlen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// s 此时指向buf</span>
    s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>sh<span class="token operator">+</span>hdrlen<span class="token punctuation">;</span>
    <span class="token comment">// 指向flags</span>
    fp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    usable <span class="token operator">=</span> usable<span class="token operator">-</span>hdrlen<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 对不同类型的 SDS 可分配空间进行截断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>usable <span class="token operator">&gt;</span> <span class="token function">sdsTypeMaxSize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span>
        usable <span class="token operator">=</span> <span class="token function">sdsTypeMaxSize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> SDS_TYPE_5<span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token operator">*</span>fp <span class="token operator">=</span> type <span class="token operator">|</span> <span class="token punctuation">(</span>initlen <span class="token operator">&lt;&lt;</span> SDS_TYPE_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">case</span> SDS_TYPE_8<span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token function">SDS_HDR_VAR</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
            sh<span class="token operator">-&gt;</span>len <span class="token operator">=</span> initlen<span class="token punctuation">;</span>
            sh<span class="token operator">-&gt;</span>alloc <span class="token operator">=</span> usable<span class="token punctuation">;</span>
            <span class="token operator">*</span>fp <span class="token operator">=</span> type<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// ... 省略</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>initlen <span class="token operator">&amp;&amp;</span> init<span class="token punctuation">)</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> init<span class="token punctuation">,</span> initlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 末尾添加\0</span>
    s<span class="token punctuation">[</span>initlen<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过<code>sdsnewlen</code>方法我们可以获得以下信息：</p>
<ul>
<li><code>SDS_TYPE_5</code> 会被强制转换为 <code>SDS_TYPE_8</code> 类型；</li>
<li>创建时默认会在末尾加<code>'\0'</code>；</li>
<li>返回值是指向 SDS 结构中 buf 的指针；</li>
<li>返回值是<code>char *sds</code>类型，可以兼容部分C函数。</li>
</ul>
<h4 id="释放SDS"><a href="#释放SDS" class="headerlink" title="释放SDS"></a>释放SDS</h4><p>为了优化性能，SDS 提供了不直接释放内存，而是通过重置len达到清空 SDS 目的的方法——<code>sdsclear</code>。</p>
<p>改方法仅仅将 SDS 的len归零，而buf的空间并为真正被清空，新的数据可以复写，而不用重新申请内存。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sdsclear</span><span class="token punctuation">(</span>sds s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">sdssetlen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置len为0</span>
    s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span><span class="token comment">//“清空”buf</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>若真正想清空 SDS 则可以调用<code>sdsfree</code>方法，底层通过调用<code>s_free</code>释放内存。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sdsfree</span><span class="token punctuation">(</span>sds s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">s_free</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token operator">-</span><span class="token function">sdsHdrSize</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>







<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/uYUQ1P8Dq1Cdknxif7lF-g">完整含详细解释来源</a></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/20/redis-bitmap/" title="Redis——BitMap"><img class="cover" src="/img/background/bg_bggenerator_com%20(2).png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis——BitMap</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/05/file-yu-io/" title="File与IO"><img class="cover" src="/img/background/bg_bggenerator_com%20(2).png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">File与IO</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/22/redis-aof-chi-jiu-hua/" title="Redis——AOF持久化"><img class="cover" src="/img/background/bg_bggenerator_com%20(2).png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-22</div><div class="title">Redis——AOF持久化</div></div></a></div><div><a href="/2023/03/20/redis-bitmap/" title="Redis——BitMap"><img class="cover" src="/img/background/bg_bggenerator_com%20(2).png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="title">Redis——BitMap</div></div></a></div><div><a href="/2023/03/23/redis-rdb-kuai-zhao/" title="Redis——RDB快照"><img class="cover" src="/img/background/bg_bggenerator_com%20(2).png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-23</div><div class="title">Redis——RDB快照</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.svg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">今晚不熬夜</div><div class="author-info__description">别急~惊喜在路上！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/quanquan170"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/quanquan170" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1480105462@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/1480105462" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">来了都是缘分，祝你今天高兴</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">1 数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96"><span class="toc-text">2 数据优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96"><span class="toc-text">2.1 数据结构优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis6-x%E5%AE%9E%E7%8E%B0"><span class="toc-text">Redis6.x实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-uintX-t"><span class="toc-text">2.2 uintX_t</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85"><span class="toc-text">2.3 对齐填充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E9%BD%90%E5%91%A2%EF%BC%9F"><span class="toc-text">Redis为什么不对齐呢？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SDS-%E4%BC%98%E5%8A%BF"><span class="toc-text">3 SDS 优势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-O-1-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-text">3.1 O(1)时间复杂度获取字符串长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8"><span class="toc-text">3.2 二进制安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%9D%9C%E7%BB%9D%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-text">3.3 杜绝缓冲区溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94sdsMakeRoomFor%E6%96%B9%E6%B3%95"><span class="toc-text">自动扩容机制——sdsMakeRoomFor方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">自动扩容机制总结：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%B8%8D%E5%90%8C%E7%9A%84type%E7%A1%AE%E5%AE%9A%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94sdsHdrSize%E6%96%B9%E6%B3%95"><span class="toc-text">根据不同的type确定对应的数据结构——sdsHdrSize方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%E9%80%89%E6%8B%A9%E5%AF%B9%E5%BA%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94sdsReqType%E6%96%B9%E6%B3%95"><span class="toc-text">根据字符串长度选择对应数据结构——sdsReqType方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%86%85%E5%AD%98%E9%87%8D%E5%88%86%E9%85%8D%E6%AC%A1%E6%95%B0%E4%BC%98%E5%8C%96"><span class="toc-text">3.4 内存重分配次数优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%A9%BA%E9%97%B4%E9%A2%84%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">(1) 空间预分配策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%83%B0%E6%80%A7%E7%A9%BA%E9%97%B4%E9%87%8A%E6%94%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">(2) 惰性空间释放机制</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-SDS-%E6%9C%80%E9%95%BF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">4 SDS 最长多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%83%A8%E5%88%86-API-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-text">5 部分 API 源码解读</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BASDS"><span class="toc-text">创建SDS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8A%E6%94%BESDS"><span class="toc-text">释放SDS</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/12/mian-jing-yi-23.04.12/" title="面经一">面经一</a><time datetime="2023-04-12T11:47:20.000Z" title="发表于 2023-04-12 19:47:20">2023-04-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/26/mybatis-shi-yong-pei-zhi-wen-dang/" title="MyBatis——使用配置文档1">MyBatis——使用配置文档1</a><time datetime="2023-03-26T13:30:20.000Z" title="发表于 2023-03-26 21:30:20">2023-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/25/mysql-explain-yu-ju-select-type/" title="MySQL——Explain语句(select_type)">MySQL——Explain语句(select_type)</a><time datetime="2023-03-25T13:30:20.000Z" title="发表于 2023-03-25 21:30:20">2023-03-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/25/mysql-lian-jie-de-yuan-li/" title="MySQL——连接原理">MySQL——连接原理</a><time datetime="2023-03-25T09:16:20.000Z" title="发表于 2023-03-25 17:16:20">2023-03-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/24/mysql-zi-cha-xun-you-hua/" title="MySQL——子查询优化">MySQL——子查询优化</a><time datetime="2023-03-24T13:30:20.000Z" title="发表于 2023-03-24 21:30:20">2023-03-24</time></div></div></div></div></div></div></main><footer id="footer" style="background: url(/img/imgs/redis.png)"><div id="footer-wrap"><div class="footer_custom_text">谢谢看到这er~没有更多了奥</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></body></html>