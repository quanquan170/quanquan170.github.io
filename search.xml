<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java关键字学习（更新中）</title>
    <url>/2023/03/05/java-guan-jian-zi-zong-jie-bu-chang-yong/</url>
    <content><![CDATA[<h2 id="1-assert-jdk1-4"><a href="#1-assert-jdk1-4" class="headerlink" title="1.assert   jdk1.4"></a>1.assert   jdk1.4</h2><p>assert意为断言的意思，这个关键字可以判断布尔值的结果是否和预期的一样，如果一样就正常执行，否则会抛出AssertionError。</p>
<p>assert有两种用法：</p>
<p>（1）asset expression1;</p>
<p>（2）asset expression1 : expression2; // expression2允许我们自定义一个异常错误信息抛出。</p>
<blockquote>
<p>注意，在运行的时候，正常情况下assert是不会生效的，因为运行时assert是关闭的，想要使用，必须在VM启动参数中开启：</p>
<blockquote>
<p>-enableassertions 或者 -ea</p>
</blockquote>
</blockquote>
<p>即使assert能够精简的判断一些case，并不推荐在生产环境中使用，因为在运行时默认是关闭assert的，因为开启assert校验，也会损耗一定的性能，并且如果在关键部分的校验使用了assert验证，但是忘记开启assert功能，那么肯定会造成重大的失误，所以一般都是在测试类里面使用的比较多。</p>
<p>那么，既然没法在生产环境中使用assert功能，那么有没有替代的assert的组件？</p>
<h3 id="替代assert的组件"><a href="#替代assert的组件" class="headerlink" title="替代assert的组件"></a>替代assert的组件</h3><p>（1）在spring环境中，可以直接使用工具类Assert：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"object was null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>（2）如果不在spring中，在普通的Java项目中可以使用jdk7中自带的Objects工具类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>（3）如果觉得Objects工具类功能较弱，可以引入junit工具类里面的Assert类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertNotNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="2-transient"><a href="#2-transient" class="headerlink" title="2.transient"></a>2.transient</h2><p>让某些被修饰的成员属性变量不被序列化</p>
<p>注：</p>
<ul>
<li>只能修饰变量，而不能修饰方法和类</li>
<li>一个静态变量不管是否被transient修饰，均不能被序列化</li>
</ul>
<p>使用情况：</p>
<p>1、类中的字段值可以根据其它字段推导出来，那么在序列化的时候，面积这个属性就没必要被序列化了</p>
<p>2、具体业务需求不需要其被序列化</p>
<blockquote>
<p>注意：</p>
<p>HashMap中的桶数组 table 被申明为 transient。table 如果不序列化的话，怎么传输并还原呢？（HashSet同理）</p>
<p>HashMap 并没有使用默认的序列化机制，而是通过实现<code>readObject/writeObject</code>两个方法自定义了序列化的内容。直接序列化 talbe 存在着两个问题：</p>
<ol>
<li>table 多数情况下是无法被存满的，序列化未使用的部分，浪费空间</li>
<li>同一个键值对在不同 JVM 下，所处的桶位置可能是不同的，在不同的 JVM 下反序列化 table 可能会发生错误。</li>
</ol>
<p>以上两个问题中，第一个问题比较好理解，第二个问题解释一下。HashMap 的<code>get/put/remove</code>等方法第一步就是根据 hash 找到键所在的桶位置，但如果键没有覆写 hashCode 方法，计算 hash 时最终调用 Object 中的 hashCode 方法。但 Object 中的 hashCode 方法是 native 型的，不同的 JVM 下，可能会有不同的实现，产生的 hash 可能也是不一样的。也就是说同一个键在不同平台下可能会产生不同的 hash，此时再对在同一个 table 继续操作，就会出现问题。</p>
</blockquote>
<p>在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是<code>Serializable</code>接口，则所有的序列化将会自动进行，若实现的是<code>Externalizable</code>接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。</p>
<h2 id="3-native"><a href="#3-native" class="headerlink" title="3.native"></a>3.native</h2><p>用来修饰方法，代表该方法是在用其他语言（如C和C++）实现的文件中，并不提供实现体</p>
<ul>
<li><p>标识符native可以与所有其它的java标识符连用，但是abstract除外。这是因为native暗示这些方法是有实现体的，只不过这些实现体是非java的，但是abstract却显然的指明这些方法无实现体。</p>
</li>
<li><p>native method方法可以返回任何java类型，包括非基本类型，而且同样可以进行异常控制。这些方法的实现体可以自制一个异常并且将其抛出，这一点与java的方法非常相似。</p>
</li>
<li><p>native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。 如果一个含有本地方法的类被继承，子类会继承这个本地方法并且可以用java语言重写这个方法（这个似乎看起来有些奇怪），同样的如果一个本地方法被fianl标识，它被继承后不能被重写。</p>
</li>
</ul>
<p>本地方法非常有用，因为它有效地扩充了JVM。事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务。</p>
<p><a href="https://www.cnblogs.com/KingIceMou/p/7239668.html">具体自定义使用方法（本文略）</a></p>
<p>大致使用步骤：</p>
<ol>
<li><p>在Java中声明native()方法，然后编译；</p>
</li>
<li><p>用javah产生一个.h文件；</p>
</li>
<li><p>写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）；</p>
</li>
<li><p>将第三步的.cpp文件编译成动态链接库文件；</p>
</li>
<li><p>在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。</p>
</li>
</ol>
<h2 id="4-volatile"><a href="#4-volatile" class="headerlink" title="4.volatile"></a>4.volatile</h2><p>用来修饰变量，表示该变量为共享变量，不会将该变量上的操作与其他内存操作一起重排序</p>
<p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在<strong>读取volatile类型的变量时总会返回最新写入的值</strong>。</p>
<p>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</p>
<p><img src="/2023/03/05/java-guan-jian-zi-zong-jie-bu-chang-yong/731716-20160708224602686-2141387366.png"></p>
<p>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</p>
<p>而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。</p>
<h4 id="当一个变量定义为-volatile-之后，将具备两种特性："><a href="#当一个变量定义为-volatile-之后，将具备两种特性：" class="headerlink" title="当一个变量定义为 volatile 之后，将具备两种特性："></a>当一个变量定义为 volatile 之后，将具备两种特性：</h4><ol>
<li>保证此变量对所有的线程的可见性，也就是当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：<a href="http://www.cnblogs.com/zhengbin/p/6407137.html">Java内存模型</a>）来完成。</li>
<li>禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个<strong>内存屏障</strong>（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。</li>
</ol>
<h4 id="volatile-性能："><a href="#volatile-性能：" class="headerlink" title="volatile 性能："></a>volatile 性能：</h4><p>　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行</p>
<p><a href="https://www.cnblogs.com/zhengbin/p/5654805.html">原文</a></p>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>File与IO</title>
    <url>/2023/03/05/file-yu-io/</url>
    <content><![CDATA[<h2 id="1-java-io-File"><a href="#1-java-io-File" class="headerlink" title="1.java.io.File"></a>1.java.io.File</h2><ul>
<li>关于相对路径：在Test方法中和main()中不同，Test中为当前Module，main()中为当前Project</li>
<li>关于renameTo():</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">renameTo</span><span class="token punctuation">(</span><span class="token class-name">File</span> dest<span class="token punctuation">)</span><span class="token comment">//把文件重命名为指定的文件路径</span>
file1<span class="token punctuation">.</span><span class="token function">renameTo</span><span class="token punctuation">(</span>file2<span class="token punctuation">)</span>
<span class="token comment">/*
	重命名（移动文件）成功要求：
	1.file1必须存在
	2.file2必须不存在
	3.file2的父目录必须存在
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>关于删除<code>delete()</code>：① Java中的删除不走回收站。② 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录。</li>
<li>筛选文件<code>FilenameFilter</code>：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">File</span> srcFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"d:\\code"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">File</span><span class="token punctuation">[</span><span class="token punctuation">]</span> subFiles <span class="token operator">=</span> srcFile<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FilenameFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token class-name">File</span> dir<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">".jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">File</span> file <span class="token operator">:</span> subFiles<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-IO流分类和常见API"><a href="#2-IO流分类和常见API" class="headerlink" title="2.IO流分类和常见API"></a>2.IO流分类和常见API</h2><p>按数据的流向不同分为：输入流和输出流。（相对于程序（内存）来说）</p>
<ul>
<li>输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</li>
<li>输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。</li>
</ul>
<p>按操作数据单位的不同分为：字节流（8bit）和字符流（16bit）</p>
<ul>
<li>字节流 ：以字节为单位，读写数据的流。<br>以InputStream、OutputStream结尾</li>
<li>字符流 ：以字符为单位，读写数据的流。<br>以Reader、Writer结尾<br>根据</li>
</ul>
<p>IO流的角色不同分为：节点流和处理流</p>
<ul>
<li><p>节点流：直接从数据源或目的地读写数据</p>
</li>
<li><p>处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。</p>
</li>
</ul>
<p>Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。</p>
<table>
<thead>
<tr>
<th>（抽象基类）</th>
<th>输入流</th>
<th>输出流</th>
</tr>
</thead>
<tbody><tr>
<td>字节流</td>
<td>InputStream</td>
<td>OutputStream</td>
</tr>
<tr>
<td>字符流</td>
<td>Reader</td>
<td>Writer</td>
</tr>
</tbody></table>
<p>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</p>
<p><img src="/2023/03/05/file-yu-io/image-20220412230501953.png"></p>
<p>常用的节点流：</p>
<ul>
<li>文件流： FileInputStream、FileOutputStrean、FileReader、FileWriter</li>
<li>字节/字符数组流： ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter<br>对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。</li>
</ul>
<p>常用处理流：</p>
<ul>
<li><p>缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</p>
<ul>
<li>作用：增加缓冲功能，避免频繁读写硬盘，进而提升读写效率。</li>
</ul>
</li>
<li><p>转换流：InputStreamReader、OutputStreamReader</p>
<ul>
<li>作用：实现字节流和字符流之间的转换。</li>
</ul>
</li>
<li><p>对象流：ObjectInputStream、ObjectOutputStream</p>
<ul>
<li>作用：提供直接读写Java对象功能</li>
</ul>
</li>
</ul>
<h3 id="节点流："><a href="#节点流：" class="headerlink" title="节点流："></a>节点流：</h3><h4 id="FileReader-x2F-FileWriter字符流使用："><a href="#FileReader-x2F-FileWriter字符流使用：" class="headerlink" title="FileReader/FileWriter字符流使用："></a>FileReader/FileWriter字符流使用：</h4><p>（处理文本文件）</p>
<ol>
<li>创建读取或写出的File类的对象<ul>
<li>注意：输入流的File对象对应的物理磁盘上的文件必须存在，否则会报FileNotFoundException<ul>
<li>输出流当不存在时会自动创建，存在时可以选择覆盖文件（默认）/追加</li>
</ul>
</li>
</ul>
</li>
<li>创建输入流或输出流</li>
<li>具体的读入或写出的过程<ul>
<li>读入：<code>read(char[] cbuffer)</code></li>
<li>写出：<code>write(String str)</code>/<code>write(char[] cbuffer, 0, len)</code>  // 注意len</li>
</ul>
</li>
<li>关闭流资源，避免内存泄漏 <ul>
<li>注意使用finally关闭</li>
</ul>
</li>
</ol>
<h4 id="FileInputStream-x2F-FileOutputStream字节流使用："><a href="#FileInputStream-x2F-FileOutputStream字节流使用：" class="headerlink" title="FileInputStream/FileOutputStream字节流使用："></a>FileInputStream/FileOutputStream字节流使用：</h4><p>（通常处理非文本文件，处理中文文本文件时可能乱码，可以只复制，如果是英文都可以处理，因为英文都是用一个字节存储的）</p>
<ol>
<li>创建读取或写出的File类的对象<ul>
<li>注意：输入流的File对象对应的物理磁盘上的文件必须存在，否则会报FileNotFoundException<ul>
<li>输出流当不存在时会自动创建，存在时可以选择覆盖文件（默认）/追加</li>
</ul>
</li>
</ul>
</li>
<li>创建输入流或输出流</li>
<li>具体的读入或写出的过程<ul>
<li>读入：<code>read(byte[] buffer)</code></li>
<li>写出：<code>write(byte[] buffer, 0, len)</code>  // 注意len</li>
</ul>
</li>
<li>关闭流资源，避免内存泄漏 <ul>
<li>注意使用finally关闭</li>
</ul>
</li>
</ol>
<h3 id="处理流："><a href="#处理流：" class="headerlink" title="处理流："></a>处理流：</h3><h4 id="1-缓冲流"><a href="#1-缓冲流" class="headerlink" title="1.缓冲流"></a>1.缓冲流</h4><p>提升文件读写的效率</p>
<p>缓冲流对应的就是文件流，要“套接”在相应的文件流之上</p>
<table>
<thead>
<tr>
<th>抽象基类</th>
<th>4个节点流（文件流）</th>
<th>4个缓冲流（处理流的一种）</th>
</tr>
</thead>
<tbody><tr>
<td>InputStream</td>
<td>FileInputStream</td>
<td>BufferedInputStream</td>
</tr>
<tr>
<td>OutputStream</td>
<td>FileOutputStream</td>
<td>BufferedOutputStream</td>
</tr>
<tr>
<td>Reader</td>
<td>FileReader</td>
<td>BufferedReader</td>
</tr>
<tr>
<td>Writer</td>
<td>FileWriter</td>
<td>BufferedWriter</td>
</tr>
</tbody></table>
<p>使用方法：</p>
<p>处理非文本文件的字节流：</p>
<p>BufferedInputStream：<code>read(byte[] buffer)</code></p>
<p>BufferedOutputStream：<code>write(byte[] buffer, 0, len)</code></p>
<p>处理文本文件的字符流：</p>
<p>BufferedReader：<code>read(char[] cbuffer)</code>  / <code>readLine()</code></p>
<p>BufferedWriter：<code>write(char[] cbuffer, 0, len)</code>  / <code>write(String str)</code> /+ <code>newLine()</code>（换行符）</p>
<p>关闭资源顺序：从外到内关闭，由于外层流的关闭也会自动的对内层的流进行关闭，所以可以省略内层流的关闭</p>
<h4 id="2-转换流"><a href="#2-转换流" class="headerlink" title="2.转换流"></a>2.转换流</h4><p>作用：转换流是字节与字符间的桥梁！</p>
<p>使用情况：</p>
<p>使用FileReader 读取项目中的文本文件。由于IDEA设置中针对项目设置了UTF-8编码，当读取Windows系统中创建的文本文件时，如果Windows系统默认的是GBK编码，则读入内存中会出现乱码。</p>
<p>针对文本文件，现在使用一个字节流进行数据的读入，希望将数据显示在控制台上。此时针对包含中文的文本数据，可能会出现乱码。</p>
<p><img src="/2023/03/05/file-yu-io/image-20220412231533768.png"></p>
<p>InputStreamReader：将一个输入型的<strong>字节流</strong>转换为输入型的<strong>字符流</strong></p>
<p>OutputStreamWriter：将一个输出型的<strong>字符流</strong>转换为输出型的<strong>字节流</strong></p>
<p>从构造器制定编码规则</p>
<p><img src="/2023/03/05/file-yu-io/%E5%AD%97%E7%AC%A6%E9%9B%86.jpg" alt="字符集"></p>
<h4 id="3-数据流、对象流"><a href="#3-数据流、对象流" class="headerlink" title="3.数据流、对象流"></a>3.数据流、对象流</h4><p>作用：可以读写基本数据类型的变量、引用数据类型的变量</p>
<p>数据流：DataOutputStream、DataInputStream</p>
<ul>
<li>DataOutputStream：允许应用程序将基本数据类型、String类型的变量写入输出流中</li>
<li>DataInputStream：允许应用程序以与机器无关的方式从底层输入流中读取基本数据类型、String类型的变量。</li>
</ul>
<p>数据流DataInputStream中的方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span> <span class="token function">readByte</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">short</span> <span class="token function">readShort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">int</span> <span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token keyword">long</span> <span class="token function">readLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">float</span> <span class="token function">readFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token keyword">double</span> <span class="token function">readDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">char</span> <span class="token function">readChar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>				 <span class="token keyword">boolean</span> <span class="token function">readBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span>					
<span class="token class-name">String</span> <span class="token function">readUTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token keyword">void</span> <span class="token function">readFully</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>数据流DataOutputStream中的方法：将上述的方法的read改为相应的write即可。</p>
<p>数据流的弊端：只支持Java基本数据类型和字符串的读写，而不支持其它Java对象的类型。而ObjectOutputStream和ObjectInputStream既支持Java基本数据类型的数据读写，又支持Java对象的读写，所以主要使用对象流ObjectOutputStream和ObjectInputStream。</p>
<p>对象流：ObjectOutputStream、ObjectInputStream</p>
<ul>
<li>ObjectOutputStream：将 Java 基本数据类型和对象写入字节输出流中。通过在流中使用文件可以实现Java各种基本数据类型的数据以及对象的持久存储。</li>
<li>ObjectInputStream：ObjectInputStream 对以前使用 ObjectOutputStream 写出的基本数据类型的数据和对象进行读入操作，保存在内存中。</li>
</ul>
<h5 id="1-对象的序列化机制"><a href="#1-对象的序列化机制" class="headerlink" title="1.对象的序列化机制"></a>1.对象的序列化机制</h5><p>对象的序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其他程序获取了着这种二进制流，就可以恢复成原来的Java对象。</p>
<ul>
<li><p>序列化过程：用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<code>持久保存</code>了一个对象的信息。</p>
</li>
<li><p>反序列化过程：该字节序列还可以从文件中读取回来，重构对象，对它进行<code>反序列化</code>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。</p>
</li>
</ul>
<p><img src="/2023/03/05/file-yu-io/image-20220503123328452-16780014423175.png"></p>
<h5 id="2-序列化机制的重要性"><a href="#2-序列化机制的重要性" class="headerlink" title="2.序列化机制的重要性"></a>2.序列化机制的重要性</h5><p>序列化是 RMI（Remote Method Invoke、远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是 JavaEE 平台的基础。</p>
<p>序列化的好处，在于可将任何实现了Serializable接口的对象转化为<strong>字节数据</strong>，使其在保存和传输时可被还原。</p>
<h5 id="3-序列化实现原理"><a href="#3-序列化实现原理" class="headerlink" title="3.序列化实现原理"></a>3.序列化实现原理</h5><ul>
<li>序列化：用ObjectOutputStream类保存基本类型数据或对象的机制。方法为：<ul>
<li><code>public final void writeObject (Object obj) </code>: 将指定的对象写出。</li>
</ul>
</li>
<li>反序列化：用ObjectInputStream类读取基本类型数据或对象的机制。方法为：<ul>
<li><code>public final Object readObject () </code>: 读取一个对象。</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/05/file-yu-io/3_xuliehua.jpg"></p>
<h5 id="4-实现序列化机制"><a href="#4-实现序列化机制" class="headerlink" title="4.实现序列化机制"></a>4.实现序列化机制</h5><p>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现<code>java.io.Serializable </code>接口。<code>Serializable</code> 是一个<code>标记接口</code>(内部为空)，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</p>
<ul>
<li>如果对象的某个属性也是引用数据类型，那么如果该属性也要序列化的话，也要实现Serializable 接口，该类的所有属性必须是可序列化的。<ul>
<li>对于基本数据类型的属性：默认就是可以序列化的</li>
<li>对于引用数据类型的属性：要求实现Serializable</li>
</ul>
</li>
<li>如果有一个属性不需要可序列化的，则该属性必须注明是<strong>瞬态的</strong>，使用<code>transient </code>关键字修饰。</li>
<li><strong>静态（static）变量的值</strong>不会序列化。因为静态变量的值不属于某个对象。</li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>serialVersionUID用来表明类的不同版本间的兼容性。简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException)。</li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID <code>可能发生变化</code>。因此，建议显式声明。</li>
<li>如果声明了serialVersionUID，即使在序列化完成之后修改了类导致类重新编译，则原来的数据也能正常反序列化，只是新增的字段值是默认值而已。</li>
</ul>
</blockquote>
<blockquote>
<p>谈谈你对java.io.Serializable接口的理解，我们知道它用于序列化，是空方法接口，还有其它认识吗？</p>
<p>答：实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。这一过程亦可通过网络进行。这意味着序列化机制能<code>自动补偿操作系统间的差异</code>。换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。</p>
<p>由于大部分作为参数的类如String、Integer等都实现了java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更灵活。</p>
</blockquote>
<h5 id="5-其他流的使用"><a href="#5-其他流的使用" class="headerlink" title="5.其他流的使用"></a>5.其他流的使用</h5><h6 id="标准输入、输出流"><a href="#标准输入、输出流" class="headerlink" title="标准输入、输出流"></a>标准输入、输出流</h6><ul>
<li>System.in和System.out分别代表了系统标准的输入和输出设备</li>
<li>默认输入设备是：键盘，输出设备是：显示器</li>
<li>System.in的类型是InputStream</li>
<li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类</li>
<li>重定向：通过System类的setIn，setOut方法对默认设备进行改变。<ul>
<li><code>public static void setIn(InputStream in)</code>：内部由<code>native</code>修饰的方法实现。调用底层C/C++实现重定向</li>
<li><code>public static void setOut(PrintStream out)</code>：内部由<code>native</code>修饰的方法实现</li>
</ul>
</li>
</ul>
<p>System类中有三个常量对象：System.out、System.in、System.err，在源码中的声明如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">InputStream</span> in <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">PrintStream</span> out <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">PrintStream</span> err <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>final声明的常量，表示在Java的语法体系中它们的值是不能修改的，而这三个常量对象的值是由C/C++等系统函数进行初始化和修改值的，所以它们故意没有用大写，也有set方法。</p>
<h6 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h6><ul>
<li>PrintStream和PrintWriter的输出不会抛出IOException异常</li>
<li>PrintStream和PrintWriter有自动flush功能</li>
<li>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类</li>
<li>System.out返回的是PrintStream的实例</li>
</ul>
<h6 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h6><h3 id="关于flush（刷新）"><a href="#关于flush（刷新）" class="headerlink" title="关于flush（刷新）"></a>关于flush（刷新）</h3><p>因为内置缓冲区的原因，如果FileWriter不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush() 方法了。</p>
<p>flush() ：刷新缓冲区，流对象可以继续使用。</p>
<p>close()：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。<br>注意：即便是flush()方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p>
<p>本文绝大部分来源为尚硅谷</p>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL——访问方法合集</title>
    <url>/2023/03/21/mysql-fang-wen-fang-fa-zong-jie/</url>
    <content><![CDATA[<p>执行查询语句的方式称之为<code>访问方法</code>或者<code>访问类型</code>。可以通过explain语句在执行计划的<code>type</code>列查看。</p>
<p>完整的访问方法如下：<code>system</code>，<code>const</code>，<code>eq_ref</code>，<code>ref</code>，<code>fulltext</code>，<code>ref_or_null</code>，<code>index_merge</code>，<code>unique_subquery</code>，<code>index_subquery</code>，<code>range</code>，<code>index</code>，<code>ALL</code>。</p>
<p>除了<code>All</code>这个访问方法外，其余的访问方法都能用到索引，除了<code>index_merge</code>访问方法外，其余的访问方法都最多只能用到一个索引</p>
<p>建表语句：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> single_table <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
    key1 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    key2 <span class="token keyword">INT</span><span class="token punctuation">,</span>
    key3 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    key_part1 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    key_part2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    key_part3 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    common_field <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">KEY</span> idx_key1 <span class="token punctuation">(</span>key1<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> idx_key2 <span class="token punctuation">(</span>key2<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">KEY</span> idx_key3 <span class="token punctuation">(</span>key3<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">KEY</span> idx_key_part<span class="token punctuation">(</span>key_part1<span class="token punctuation">,</span> key_part2<span class="token punctuation">,</span> key_part3<span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">Engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>为<code>id</code>列建立的聚簇索引。</li>
<li>为<code>key1</code>列建立的<code>idx_key1</code>二级索引。</li>
<li>为<code>key2</code>列建立的<code>idx_key2</code>二级索引，而且该索引是唯一二级索引。</li>
<li>为<code>key3</code>列建立的<code>idx_key3</code>二级索引。</li>
<li>为<code>key_part1</code>、<code>key_part2</code>、<code>key_part3</code>列建立的<code>idx_key_part</code>二级索引，这也是一个联合索引。</li>
</ul>
<h2 id="单表访问方法（InnoDB）"><a href="#单表访问方法（InnoDB）" class="headerlink" title="单表访问方法（InnoDB）"></a>单表访问方法（InnoDB）</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>通过<strong>主键</strong>或者<strong>唯一二级索引列与常数的等值比较</strong>来定位<strong>一条记录</strong></p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>搜索条件为<strong>二级索引列与常数等值比较</strong>，采用二级索引来执行查询的访问方法</p>
<p>注：</p>
<ul>
<li><p>二级索引列值为<code>NULL</code>的情况</p>
<p>  不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含<code>NULL</code>值的数量并不限制，所以我们采用<code>key IS NULL</code>这种形式的搜索条件最多只能使用<code>ref</code>的访问方法，而不是<code>const</code>的访问方法。</p>
</li>
<li><p>对于某个包含多个索引列的二级索引来说，只要是最<strong>左边的连续索引列是与常数的等值比较</strong>就<strong>可能</strong>采用<code>ref</code>的访问方法（还可能是全表扫描）</p>
</li>
</ul>
<h3 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h3><p>不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为<code>NULL</code>的记录也找出来，当使用<strong>二级索引</strong>而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为<code>ref_or_null</code></p>
<h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> single_table 
<span class="token keyword">WHERE</span> key2 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1438</span><span class="token punctuation">,</span> <span class="token number">6328</span><span class="token punctuation">)</span> <span class="token operator">OR</span> <span class="token punctuation">(</span>key2 <span class="token operator">&gt;=</span> <span class="token number">38</span> <span class="token operator">AND</span> key2 <span class="token operator">&lt;=</span> <span class="token number">79</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>从数学的角度看，每一个所谓的范围都是数轴上的一个<code>区间</code>，3个范围也就对应着3个区间：</p>
<ul>
<li>范围1：<code>key2 = 1438</code></li>
<li>范围2：<code>key2 = 6328</code></li>
<li>范围3：<code>key2 ∈ [38, 79]</code>，注意这里是闭区间。</li>
</ul>
<p>  我们可以把那种索引列等值匹配的情况称之为<code>单点区间</code>，上面所说的<code>范围1</code>和<code>范围2</code>都可以被称为单点区间，像<code>范围3</code>这种的我们可以称为连续范围区间。</p>
<p>​		如果采用<code>二级索引 + 回表</code>的方式来执行的话，那么此时的搜索条件就不只是要求索引列与常数的等值匹配了，而是索引列需要匹配某个或某些范围的值</p>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> key_part1<span class="token punctuation">,</span> key_part2<span class="token punctuation">,</span> key_part3 
<span class="token keyword">FROM</span> single_table 
<span class="token keyword">WHERE</span> key_part2 <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p> 由于<code>key_part2</code>并不是联合索引<code>idx_key_part</code>最左索引列，所以我们无法使用<code>ref</code>或者<code>range</code>访问方法来执行这个语句。但是这个查询符合下面这两个条件：</p>
<ul>
<li>它的查询列表只有3个列：<code>key_part1</code>, <code>key_part2</code>, <code>key_part3</code>，而索引<code>idx_key_part</code>又包含这三个列。</li>
<li>搜索条件中只有<code>key_part2</code>列。这个列也包含在索引<code>idx_key_part</code>中。</li>
</ul>
<p>​		可以直接通过遍历<code>idx_key_part</code>索引的叶子节点的记录来比较<code>key_part2 = 'abc'</code>这个条件是否成立，把匹配成功的二级索引记录的<code>key_part1</code>, <code>key_part2</code>, <code>key_part3</code>列的值直接加到结果集中就行了。由于<strong>二级索引记录比聚簇索记录小的多</strong>（聚簇索引记录要存储所有用户定义的列以及所谓的隐藏列，而二级索引记录只需要存放索引列和主键），而且这个过程也<strong>不用进行回表操作</strong>，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多，设计<code>MySQL</code>的大佬就把这种采用遍历二级索引记录的执行方式称之为：<code>index</code>。</p>
<h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p>最直接的查询执行方式就是全表扫描，对于<code>InnoDB</code>表来说也就是直接扫描聚簇索引。</p>
<p>注：</p>
<p>一个使用到索引的搜索条件和没有使用该索引的搜索条件使用<code>OR</code>连接起来后是无法使用该索引的。</p>
<h3 id="index-merge"><a href="#index-merge" class="headerlink" title="index merge"></a>index merge</h3><p>在一般情况下执行一个查询时最多只会用到单个二级索引。但在特殊情况下也可能在一个查询中使用到多个二级索引</p>
<h4 id="Intersection合并"><a href="#Intersection合并" class="headerlink" title="Intersection合并"></a>Intersection合并</h4><p>翻译为交集，对应不同索引搜索条件用<code>AND</code>连接的情况，某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，比方说下面这个查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> single_table 
<span class="token keyword">WHERE</span> key1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">AND</span> key3 <span class="token operator">=</span> <span class="token string">'b'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。</p>
<ul>
<li>需要保证最终取出的主键值是排序的（此时时间复杂度为O(n)），否则取主键交集的时候还需要排序，时间复杂度会增加。</li>
</ul>
<p>情况二：主键列可以是范围匹配</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> single_table 
<span class="token keyword">WHERE</span> id <span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">AND</span> key1 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>小贴士：按照有序的主键值去回表取记录有个专有名词儿，叫：Rowid Ordered Retrieval，简称ROR，以后大家在某些地方见到这个名词儿就眼熟了。</p>
</blockquote>
<p>​		上面说的<code>情况一</code>和<code>情况二</code>只是发生<code>Intersection</code>索引合并的必要条件，不是充分条件。也就是说即使情况一、情况二成立，也不一定发生<code>Intersection</code>索引合并，这得看优化器的心情。<strong>优化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过<code>Intersection</code>索引合并后需要回表的记录数大大减少时才会使用<code>Intersection</code>索引合并</strong>。</p>
<blockquote>
<p>注：部分Intersection索引合并（比如情况一上面的语句）可以使用联合索引替代，还能只维护一个索引，简直又快又好</p>
</blockquote>
<h4 id="Union合并"><a href="#Union合并" class="headerlink" title="Union合并"></a>Union合并</h4><p>翻译为并集，对应不同索引搜索条件用<code>OR</code>连接的情况</p>
<ul>
<li><p>情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况。</p>
</li>
<li><p>情况二：主键列可以是范围匹配</p>
</li>
<li><p>情况三：使用<code>Intersection</code>索引合并的搜索条件</p>
<p>  这种情况其实也挺好理解，就是搜索条件的某些部分使用<code>Intersection</code>索引合并的方式得到的主键集合和其他方式得到的主键集合取交集，比方说这个查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> 
<span class="token keyword">FROM</span> single_table 
<span class="token keyword">WHERE</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">AND</span> key_part2 <span class="token operator">=</span> <span class="token string">'b'</span> <span class="token operator">AND</span> key_part3 <span class="token operator">=</span> <span class="token string">'c'</span> <span class="token operator">OR</span> <span class="token punctuation">(</span>key1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">AND</span> key3 <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>  优化器可能采用这样的方式来执行这个查询：</p>
<ul>
<li>先按照搜索条件<code>key1 = 'a' AND key3 = 'b'</code>从索引<code>idx_key1</code>和<code>idx_key3</code>中使用<code>Intersection</code>索引合并的方式得到一个主键集合。</li>
<li>再按照搜索条件<code>key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c'</code>从联合索引<code>idx_key_part</code>中得到另一个主键集合。</li>
<li>采用<code>Union</code>索引合并的方式把上述两个主键集合取并集，然后进行回表操作，将结果返回给用户。</li>
</ul>
</li>
</ul>
<p>​		当然，查询条件符合了这些情况也不一定就会采用<code>Union</code>索引合并，也得看优化器的心情。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过<code>Union</code>索引合并后进行访问的代价比全表扫描更小时才会使用<code>Union</code>索引合并。</p>
<h4 id="Sort-Union合并"><a href="#Sort-Union合并" class="headerlink" title="Sort-Union合并"></a>Sort-Union合并</h4><p>​		先按照二级索引记录的主键值进行排序，之后按照<code>Union</code>索引合并方式执行的方式称之为<code>Sort-Union</code>索引合并，很显然，这种<code>Sort-Union</code>索引合并比单纯的<code>Union</code>索引合并多了一步对二级索引记录的主键值排序的过程。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> single_table <span class="token keyword">WHERE</span> key1 <span class="token operator">&lt;</span> <span class="token string">'a'</span> <span class="token operator">OR</span> key3 <span class="token operator">&gt;</span> <span class="token string">'z'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>根据<code>key1 &lt; 'a'</code>从<code>idx_key1</code>索引中获取的二级索引记录的主键值不是排好序的，根据<code>key3 &gt; 'z'</code>从<code>idx_key3</code>索引中获取的二级索引记录的主键值也不是排好序的，但是<code>key1 &lt; 'a'</code>和<code>key3 &gt; 'z'</code>这两个条件又特别让我们动心，所以我们可以这样：</p>
<ul>
<li>先根据<code>key1 &lt; 'a'</code>条件从<code>idx_key1</code>二级索引总获取记录，并按照记录的主键值进行排序</li>
<li>再根据<code>key3 &gt; 'z'</code>条件从<code>idx_key3</code>二级索引总获取记录，并按照记录的主键值进行排序</li>
<li>因为上述的两个二级索引主键值都是排好序的，剩下的操作和<code>Union</code>索引合并方式就一样了。</li>
</ul>
<blockquote>
<p>小贴士：为什么有Sort-Union索引合并，就没有Sort-Intersection索引合并么？是的，的确没有Sort-Intersection索引合并这么一说，Sort-Union的适用场景是单独根据搜索条件从某个二级索引中获取的记录数比较少，这样即使对这些二级索引记录按照主键值进行排序的成本也不会太高，而Intersection索引合并的适用场景是单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，合并后可以明显降低回表开销，但是如果加入Sort-Intersection后，就需要为大量的二级索引记录按照主键值进行排序，这个成本可能比回表查询都高了，所以也就没有引入Sort-Intersection这个玩意儿。  </p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>  当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是<code>system</code>。比方说我们新建一个<code>MyISAM</code>表，并为其插入一条记录：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t<span class="token punctuation">(</span>i <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token keyword">Engine</span><span class="token operator">=</span>MyISAM<span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.05</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  然后我们看一下查询这个表的执行计划：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span>   <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t     <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> system <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  可以看到<code>type</code>列的值就是<code>system</code>了。</p>
<p>​		如果是InnoDB存储引擎，那么<code>type</code>为ALL~</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 <span class="token keyword">where</span> m1 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">as</span> t3
    <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra       <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token number">3</span> <span class="token operator">|</span>    <span class="token number">33.33</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h3><p>  在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是<code>eq_ref</code>，比方说：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> s2 <span class="token keyword">ON</span> s1<span class="token punctuation">.</span>id <span class="token operator">=</span> s2<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span>   <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>     <span class="token operator">|</span> key_len <span class="token operator">|</span> ref             <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> s1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>    <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>       <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span>            <span class="token operator">|</span> <span class="token number">9688</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>  <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> s2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> eq_ref <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>       <span class="token operator">|</span> <span class="token keyword">PRIMARY</span> <span class="token operator">|</span> <span class="token number">4</span>       <span class="token operator">|</span> xiaohaizi<span class="token punctuation">.</span>s1<span class="token punctuation">.</span>id <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span>
<span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  从执行计划的结果中可以看出，<code>MySQL</code>打算将<code>s1</code>作为驱动表，<code>s2</code>作为被驱动表，重点关注<code>s2</code>的访问方法是<code>eq_ref</code>，表明在访问<code>s2</code>表的时候可以通过主键的等值匹配来进行访问。</p>
<h3 id="fulltext"><a href="#fulltext" class="headerlink" title="fulltext"></a>fulltext</h3><p>  全文索引，我们没有细讲过，跳过～</p>
<h3 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a>unique_subquery</h3><p>  类似于两表连接中被驱动表的<code>eq_ref</code>访问方法，<code>unique_subquery</code>是针对在一些包含<code>IN</code>子查询的查询语句中，如果查询优化器决定将<code>IN</code>子查询转换为<code>EXISTS</code>子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的<code>type</code>列的值就是<code>unique_subquery</code>，比如下面的这个查询语句：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> key2 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> s2 <span class="token keyword">where</span> s1<span class="token punctuation">.</span>key1 <span class="token operator">=</span> s2<span class="token punctuation">.</span>key1<span class="token punctuation">)</span> <span class="token operator">OR</span> key3 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type        <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span>            <span class="token operator">|</span> possible_keys    <span class="token operator">|</span> <span class="token keyword">key</span>     <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra       <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>            <span class="token operator">|</span> s1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>             <span class="token operator">|</span> idx_key3         <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">9688</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> DEPENDENT SUBQUERY <span class="token operator">|</span> s2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> unique_subquery <span class="token operator">|</span> <span class="token keyword">PRIMARY</span><span class="token punctuation">,</span>idx_key1 <span class="token operator">|</span> <span class="token keyword">PRIMARY</span> <span class="token operator">|</span> <span class="token number">4</span>       <span class="token operator">|</span> func <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>    <span class="token number">10.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span>
<span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">warnings</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  可以看到执行计划的第二条记录的<code>type</code>值就是<code>unique_subquery</code>，说明在执行子查询时会使用到<code>id</code>列的索引。</p>
<h3 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a>index_subquery</h3><p>  <code>index_subquery</code>与<code>unique_subquery</code>类似，只不过访问子查询中的表时使用的是普通的索引，比如这样：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> common_field <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> key3 <span class="token keyword">FROM</span> s2 <span class="token keyword">where</span> s1<span class="token punctuation">.</span>key1 <span class="token operator">=</span> s2<span class="token punctuation">.</span>key1<span class="token punctuation">)</span> <span class="token operator">OR</span> key3 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type        <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span>           <span class="token operator">|</span> possible_keys     <span class="token operator">|</span> <span class="token keyword">key</span>      <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra       <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>            <span class="token operator">|</span> s1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>            <span class="token operator">|</span> idx_key3          <span class="token operator">|</span> <span class="token boolean">NULL</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">9688</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> DEPENDENT SUBQUERY <span class="token operator">|</span> s2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> index_subquery <span class="token operator">|</span> idx_key1<span class="token punctuation">,</span>idx_key3 <span class="token operator">|</span> idx_key3 <span class="token operator">|</span> <span class="token number">303</span>     <span class="token operator">|</span> func <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>    <span class="token number">10.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+</span>
<span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">warnings</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>











<p>完整文章为：《MySQL 是怎样运行的：从根儿上理解 MySQL》——第10章 条条大路通罗马-单表访问方法</p>
<p>《MySQL 是怎样运行的：从根儿上理解 MySQL》——第15章 查询优化的百科全书-Explain详解（上）</p>
<p>以上只是一些自己想要记录且方便查找的笔记</p>
]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL——子查询优化</title>
    <url>/2023/03/24/mysql-zi-cha-xun-you-hua/</url>
    <content><![CDATA[<h3 id="子查询语法注意事项"><a href="#子查询语法注意事项" class="headerlink" title="子查询语法注意事项"></a>子查询语法注意事项</h3><ul>
<li><p>子查询必须用小括号扩起来。</p>
<p>  不扩起来的子查询是非法的，比如这样：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token keyword">SELECT</span> m1 <span class="token keyword">FROM</span> t1<span class="token punctuation">;</span>

ERROR <span class="token number">1064</span> <span class="token punctuation">(</span><span class="token number">42000</span><span class="token punctuation">)</span>: You have an error <span class="token operator">in</span> your <span class="token keyword">SQL</span> syntax<span class="token punctuation">;</span> <span class="token keyword">check</span> the manual that corresponds <span class="token keyword">to</span> your MySQL server version <span class="token keyword">for</span> the <span class="token keyword">right</span> syntax <span class="token keyword">to</span> <span class="token keyword">use</span> near <span class="token string">'SELECT m1 FROM t1'</span> at line <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>在<code>SELECT</code>子句中的子查询必须是标量子查询。</p>
<p>  如果子查询结果集中有多个列或者多个行，都不允许放在<code>SELECT</code>子句中，也就是查询列表中，比如这样就是非法的：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> m1<span class="token punctuation">,</span> n1 <span class="token keyword">FROM</span> t1<span class="token punctuation">)</span><span class="token punctuation">;</span>

ERROR <span class="token number">1241</span> <span class="token punctuation">(</span><span class="token number">21000</span><span class="token punctuation">)</span>: Operand should contain <span class="token number">1</span> <span class="token keyword">column</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用<code>LIMIT 1</code>语句来限制记录数量。</p>
</li>
<li><p>对于<code>[NOT] IN/ANY/SOME/ALL</code>子查询来说，子查询中不允许有<code>LIMIT</code>语句。</p>
<p>  比如这样是非法的：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> m1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t2 <span class="token keyword">LIMIT</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

ERROR <span class="token number">1235</span> <span class="token punctuation">(</span><span class="token number">42000</span><span class="token punctuation">)</span>: This version <span class="token keyword">of</span> MySQL doesn<span class="token string">'t yet support '</span><span class="token keyword">LIMIT</span> <span class="token operator">&amp;</span> <span class="token operator">IN</span><span class="token operator">/</span><span class="token keyword">ALL</span><span class="token operator">/</span><span class="token keyword">ANY</span><span class="token operator">/</span><span class="token keyword">SOME</span> subquery'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>  为什么不合法？人家就这么规定的，不解释～ 可能以后的版本会支持吧。正因为<code>[NOT] IN/ANY/SOME/ALL</code>子查询不支持<code>LIMIT</code>语句，所以子查询中的这些语句也就是多余的了：</p>
<ul>
<li><p><code>ORDER BY</code>子句</p>
<p>  子查询的结果其实就相当于一个集合，集合里的值排不排序一点儿都不重要，比如下面这个语句中的<code>ORDER BY</code>子句简直就是画蛇添足：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> m1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> m2 <span class="token keyword">FROM</span> t2 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> m2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><code>DISTINCT</code>语句</p>
<p>  集合里的值去不去重也没什么意义，比如这样：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> m1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> m2 <span class="token keyword">FROM</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>没有聚集函数以及<code>HAVING</code>子句的<code>GROUP BY</code>子句。</p>
<p>  在没有聚集函数以及<code>HAVING</code>子句时，<code>GROUP BY</code>子句就是个摆设，比如这样：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> m1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> m2 <span class="token keyword">FROM</span> t2 <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> m2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>  对于这些冗余的语句，查询优化器在一开始就把它们给干掉了。</p>
</li>
</ul>
</li>
<li><p>不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。</p>
<p>  比方说这样：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> m1 <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>m1<span class="token punctuation">)</span> <span class="token keyword">FROM</span> t1<span class="token punctuation">)</span><span class="token punctuation">;</span>

ERROR <span class="token number">1093</span> <span class="token punctuation">(</span>HY000<span class="token punctuation">)</span>: You can<span class="token string">'t specify target table '</span>t1' <span class="token keyword">for</span> <span class="token keyword">update</span> <span class="token operator">in</span> <span class="token keyword">FROM</span> clause<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="标量子查询、行子查询的执行方式"><a href="#标量子查询、行子查询的执行方式" class="headerlink" title="标量子查询、行子查询的执行方式"></a>标量子查询、行子查询的执行方式</h2><p>  我们经常在下面两个场景中使用到标量子查询或者行子查询：</p>
<ul>
<li><code>SELECT</code>子句中，我们前面说过的在查询列表中的子查询必须是标量子查询。</li>
<li>子查询使用<code>=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>&lt;&gt;</code>、<code>!=</code>、<code>&lt;=&gt;</code>等操作符和某个操作数组成一个布尔表达式，这样的子查询必须是标量子查询或者行子查询。</li>
</ul>
<p>  对于上述两种场景中的不相关标量子查询或者行子查询来说，它们的执行方式是简单的，比方说下面这个查询语句：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 
    <span class="token keyword">WHERE</span> key1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> common_field <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> key3 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token keyword">LIMIT</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>先单独执行<code>(SELECT common_field FROM s2 WHERE key3 = 'a' LIMIT 1)</code>这个子查询。</li>
<li>然后在将上一步子查询得到的结果当作外层查询的参数再执行外层查询<code>SELECT * FROM s1 WHERE key1 = ...</code>。</li>
</ul>
<p>  也就是说，对于包含不相关的标量子查询或者行子查询的查询语句来说，MySQL会分别独立的执行外层查询和子查询，就当作两个单表查询就好了。</p>
<p>  对于相关的标量子查询或者行子查询来说，比如下面这个查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> 
    key1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> common_field <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> s1<span class="token punctuation">.</span>key3 <span class="token operator">=</span> s2<span class="token punctuation">.</span>key3 <span class="token keyword">LIMIT</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>先从外层查询中获取一条记录，本例中也就是先从<code>s1</code>表中获取一条记录。</li>
<li>然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，本例中就是从<code>s1</code>表中获取的那条记录中找出<code>s1.key3</code>列的值，然后执行子查询。</li>
<li>最后根据子查询的查询结果来检测外层查询<code>WHERE</code>子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。</li>
<li>再次执行第一步，获取第二条外层查询中的记录，依次类推～</li>
</ul>
<p>  也就是说对于一开始介绍的两种使用标量子查询以及行子查询的场景中，<code>MySQL</code>优化器的执行方式并没有什么新鲜的。</p>
<h2 id="IN子查询优化"><a href="#IN子查询优化" class="headerlink" title="IN子查询优化"></a>IN子查询优化</h2><p>如果<code>IN</code>子查询符合转换为<code>semi-join</code>的条件，查询优化器会优先把该子查询为<code>semi-join</code>，然后再考虑下面5种执行半连接的策略中哪个成本最低，选择成本最低的那种执行策略来执行子查询。</p>
<ul>
<li>Table pullout</li>
</ul>
<ul>
<li>DuplicateWeedout</li>
<li>LooseScan</li>
<li>Materialization</li>
<li>FirstMatch</li>
</ul>
<p>如果<code>IN</code>子查询不符合转换为<code>semi-join</code>的条件，那么查询优化器会从下面两种策略中找出一种成本更低的方式执行子查询：</p>
<ul>
<li>先将子查询物化之后再执行查询</li>
<li>执行<code>IN to EXISTS</code>转换。</li>
</ul>
<h3 id="物化表转连接"><a href="#物化表转连接" class="headerlink" title="物化表转连接"></a>物化表转连接</h3><p>将子查询结果集中的记录保存到临时表的过程称之为<code>物化</code>（英文名：<code>Materialize</code>）。为了方便起见，我们就把那个存储子查询结果集的临时表称之为<code>物化表</code>。正因为物化表中的记录都建立了索引（基于内存的物化表有哈希索引，基于磁盘的有B+树索引），通过索引执行<code>IN</code>语句判断某个操作数在不在子查询结果集中变得非常快，从而提升了子查询语句的性能。</p>
<p>查询语句转化成表和物化表内连接之后，查询优化器可以评估不同连接顺序需要的成本是多少，选取成本最低的那种查询方式执行查询。</p>
<h3 id="将子查询转换为semi-join"><a href="#将子查询转换为semi-join" class="headerlink" title="将子查询转换为semi-join"></a>将子查询转换为semi-join</h3><h4 id="Table-pullout-（子查询中的表上拉）"><a href="#Table-pullout-（子查询中的表上拉）" class="headerlink" title="Table pullout （子查询中的表上拉）"></a>Table pullout （子查询中的表上拉）</h4><p>当子查询的查询列表处只有主键或者唯一索引列时，可以直接把子查询中的表<code>上拉</code>到外层查询的<code>FROM</code>子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中</p>
<h4 id="DuplicateWeedout-execution-strategy-（重复值消除）"><a href="#DuplicateWeedout-execution-strategy-（重复值消除）" class="headerlink" title="DuplicateWeedout execution strategy （重复值消除）"></a>DuplicateWeedout execution strategy （重复值消除）</h4><p>使用临时表消除<code>semi-join</code>结果集中的重复值的方式称之为<code>DuplicateWeedout</code></p>
<h4 id="LooseScan-execution-strategy-（松散索引扫描）"><a href="#LooseScan-execution-strategy-（松散索引扫描）" class="headerlink" title="LooseScan execution strategy （松散索引扫描）"></a>LooseScan execution strategy （松散索引扫描）</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 
    <span class="token keyword">WHERE</span> key3 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> key1 <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> key1 <span class="token operator">&gt;</span> <span class="token string">'a'</span> <span class="token operator">AND</span> key1 <span class="token operator">&lt;</span> <span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在子查询中，对于<code>s2</code>表的访问可以使用到<code>key1</code>列的索引，而恰好子查询的查询列表处就是<code>key1</code>列，这样在将该查询转换为半连接查询后，如果将<code>s2</code>作为驱动表执行查询的话，那么执行过程就是这样：</p>
<p><img src="/2023/03/24/mysql-zi-cha-xun-you-hua/14-03.png"></p>
<p>如图所示，在<code>s2</code>表的<code>idx_key1</code>索引中，值为<code>'aa'</code>的二级索引记录一共有3条，那么只需要取第一条的值到<code>s1</code>表中查找<code>s1.key3 = 'aa'</code>的记录，如果能在<code>s1</code>表中找到对应的记录，那么就把对应的记录加入到结果集。依此类推，其他值相同的二级索引记录，也只需要取第一条记录的值到<code>s1</code>表中找匹配的记录，这种虽然是扫描索引，但只取值相同的记录的第一条去做匹配操作的方式称之为<code>松散索引扫描</code>。</p>
<h4 id="Semi-join-Materialization-execution-strategy"><a href="#Semi-join-Materialization-execution-strategy" class="headerlink" title="Semi-join Materialization execution strategy"></a>Semi-join Materialization execution strategy</h4><p>  我们之前介绍的先把外层查询的<code>IN</code>子句中的不相关子查询进行物化，然后再进行外层查询的表和物化表的连接本质上也算是一种<code>semi-join</code>，只不过由于物化表中没有重复的记录，所以可以直接将子查询转为连接查询。</p>
<h4 id="FirstMatch-execution-strategy-（首次匹配）"><a href="#FirstMatch-execution-strategy-（首次匹配）" class="headerlink" title="FirstMatch execution strategy （首次匹配）"></a>FirstMatch execution strategy （首次匹配）</h4><p>  <code>FirstMatch</code>是一种最原始的半连接执行方式，跟我们年少时认为的相关子查询的执行方式是一样一样的，就是说先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录，如果能找到一条，则将该外层查询的记录放入最终的结果集并且停止查找更多匹配的记录，如果找不到则把该外层查询的记录丢弃掉；然后再开始取下一条外层查询中的记录，重复上面这个过程。</p>
<p>  对于某些使用<code>IN</code>语句的相关子查询，比方这个查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 
  <span class="token keyword">WHERE</span> key1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> common_field <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> s1<span class="token punctuation">.</span>key3 <span class="token operator">=</span> s2<span class="token punctuation">.</span>key3<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>  它也可以很方便的转为半连接，转换后的语句类似这样：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> s1<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> s1 SEMI <span class="token keyword">JOIN</span> s2 
    <span class="token keyword">ON</span> s1<span class="token punctuation">.</span>key1 <span class="token operator">=</span> s2<span class="token punctuation">.</span>common_field <span class="token operator">AND</span> s1<span class="token punctuation">.</span>key3 <span class="token operator">=</span> s2<span class="token punctuation">.</span>key3<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>  然后就可以使用我们上面介绍过的<code>DuplicateWeedout</code>、<code>LooseScan</code>、<code>FirstMatch</code>等半连接执行策略来执行查询，当然，如果子查询的查询列表处只有主键或者唯一二级索引列，还可以直接使用<code>table pullout</code>的策略来执行查询，但是需要大家注意的是，<strong>由于相关子查询并不是一个独立的查询，所以不能转换为物化表来执行查询</strong>。</p>
<h3 id="汇总："><a href="#汇总：" class="headerlink" title="汇总："></a>汇总：</h3><h4 id="semi-join的适用条件"><a href="#semi-join的适用条件" class="headerlink" title="semi-join的适用条件"></a>semi-join的适用条件</h4><p>  当然，并不是所有包含<code>IN</code>子查询的查询语句都可以转换为<code>semi-join</code>，只有形如这样的查询才可以被转换为<code>semi-join</code>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FROM</span> outer_tables 
    <span class="token keyword">WHERE</span> expr <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FROM</span> inner_tables <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">AND</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>  或者这样的形式也可以：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FROM</span> outer_tables 
    <span class="token keyword">WHERE</span> <span class="token punctuation">(</span>oe1<span class="token punctuation">,</span> oe2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> ie1<span class="token punctuation">,</span> ie2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FROM</span> inner_tables <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">AND</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>  用文字总结一下，只有符合下面这些条件的子查询才可以被转换为<code>semi-join</code>：</p>
<ul>
<li>该子查询必须是和<code>IN</code>语句组成的布尔表达式，并且在外层查询的<code>WHERE</code>或者<code>ON</code>子句中出现。</li>
<li>外层查询也可以有其他的搜索条件，只不过和<code>IN</code>子查询的搜索条件必须使用<code>AND</code>连接起来。</li>
<li>该子查询必须是一个单一的查询，不能是由若干查询由<code>UNION</code>连接起来的形式。</li>
<li>该子查询不能包含<code>GROUP BY</code>或者<code>HAVING</code>语句或者聚集函数。</li>
<li>… 还有一些条件比较少见，就不介绍啦～</li>
</ul>
<h4 id="不适用于semi-join的情况"><a href="#不适用于semi-join的情况" class="headerlink" title="不适用于semi-join的情况"></a>不适用于semi-join的情况</h4><p>  对于一些不能将子查询转位<code>semi-join</code>的情况，典型的比如下面这几种：</p>
<ul>
<li><p>外层查询的WHERE条件中有其他搜索条件与IN子查询组成的布尔表达式使用<code>OR</code>连接起来</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 
    <span class="token keyword">WHERE</span> key1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> common_field <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> key3 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">)</span>
        <span class="token operator">OR</span> key2 <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>使用<code>NOT IN</code>而不是<code>IN</code>的情况</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 
    <span class="token keyword">WHERE</span> key1 <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> common_field <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> key3 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>在<code>SELECT</code>子句中的IN子查询的情况</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> key1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> common_field <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> key3 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> s1 <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>子查询中包含<code>GROUP BY</code>、<code>HAVING</code>或者聚集函数的情况</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 
    <span class="token keyword">WHERE</span> key2 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> s2 <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> key1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>子查询中包含<code>UNION</code>的情况</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> key1 <span class="token operator">IN</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span> common_field <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> key3 <span class="token operator">=</span> <span class="token string">'a'</span> 
    <span class="token keyword">UNION</span>
    <span class="token keyword">SELECT</span> common_field <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> key3 <span class="token operator">=</span> <span class="token string">'b'</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>  <code>MySQL</code>仍然留了两手绝活来优化不能转为<code>semi-join</code>查询的子查询，那就是：</p>
<ul>
<li><p>对于不相关子查询来说，可以尝试把它们物化之后再参与查询</p>
<p>  比如我们上面提到的这个查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 
    <span class="token keyword">WHERE</span> key1 <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> common_field <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> key3 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>  先将子查询物化，然后再判断<code>key1</code>是否在物化表的结果集中可以加快查询执行的速度。</p>
<blockquote>
<p>小贴士：请注意这里将子查询物化之后不能转为和外层查询的表的连接，只能是先扫描s1表，然后对s1表的某条记录来说，判断该记录的key1值在不在物化表中。</p>
</blockquote>
</li>
<li><p>不管子查询是相关的还是不相关的，都可以把<code>IN</code>子查询尝试专为<code>EXISTS</code>子查询</p>
<p>  其实对于任意一个IN子查询来说，都可以被转为<code>EXISTS</code>子查询，通用的例子如下：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">outer_expr <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> inner_expr <span class="token keyword">FROM</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">WHERE</span> subquery_where<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>  可以被转换为：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> inner_expr <span class="token keyword">FROM</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">WHERE</span> subquery_where <span class="token operator">AND</span> outer_expr<span class="token operator">=</span>inner_expr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>  当然这个过程中有一些特殊情况，比如在<code>outer_expr</code>或者<code>inner_expr</code>值为<code>NULL</code>的情况下就比较特殊。因为有<code>NULL</code>值作为操作数的表达式结果往往是<code>NULL</code>，比方说：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">-------------------+</span>
<span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-------------------+</span>
<span class="token operator">|</span>              <span class="token boolean">NULL</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-------------------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----------------+</span>
<span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----------------+</span>
<span class="token operator">|</span>              <span class="token number">1</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----------------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token boolean">NULL</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----------------+</span>
<span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">)</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----------------+</span>
<span class="token operator">|</span>           <span class="token boolean">NULL</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----------------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  而<code>EXISTS</code>子查询的结果肯定是<code>TRUE</code>或者<code>FASLE</code>：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> <span class="token boolean">NULL</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">------------------------------------------+</span>
<span class="token operator">|</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> <span class="token boolean">NULL</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------------------------------------------+</span>
<span class="token operator">|</span>                                        <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------------------------------------------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">------------------------------------------+</span>
<span class="token operator">|</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------------------------------------------+</span>
<span class="token operator">|</span>                                        <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------------------------------------------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> <span class="token boolean">NULL</span> <span class="token operator">=</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">---------------------------------------------+</span>
<span class="token operator">|</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> <span class="token boolean">NULL</span> <span class="token operator">=</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------------------------------------+</span>
<span class="token operator">|</span>                                           <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------------------------------------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  但是幸运的是，我们大部分使用<code>IN</code>子查询的场景是把它放在<code>WHERE</code>或者<code>ON</code>子句中，而<code>WHERE</code>或者<code>ON</code>子句是不区分<code>NULL</code>和<code>FALSE</code>的，比方说：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>
Empty <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> <span class="token boolean">FALSE</span><span class="token punctuation">;</span>
Empty <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  所以只要我们的<code>IN</code>子查询是放在<code>WHERE</code>或者<code>ON</code>子句中的，那么<code>IN -&gt; EXISTS</code>的转换就是没问题的。说了这么多，为什么要转换呢？这是因为不转换的话可能用不到索引，比方说下面这个查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1
    <span class="token keyword">WHERE</span> key1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> key3 <span class="token keyword">FROM</span> s2 <span class="token keyword">where</span> s1<span class="token punctuation">.</span>common_field <span class="token operator">=</span> s2<span class="token punctuation">.</span>common_field<span class="token punctuation">)</span> 
        <span class="token operator">OR</span> key2 <span class="token operator">&gt;</span> <span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>  这个查询中的子查询是一个相关子查询，而且子查询执行的时候不能使用到索引，但是将它转为<code>EXISTS</code>子查询后却可以使用到索引：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1
    <span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> s2 <span class="token keyword">where</span> s1<span class="token punctuation">.</span>common_field <span class="token operator">=</span> s2<span class="token punctuation">.</span>common_field <span class="token operator">AND</span> s2<span class="token punctuation">.</span>key3 <span class="token operator">=</span> s1<span class="token punctuation">.</span>key1<span class="token punctuation">)</span> 
        <span class="token operator">OR</span> key2 <span class="token operator">&gt;</span> <span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>  转为<code>EXISTS</code>子查询时便可以使用到<code>s2</code>表的<code>idx_key3</code>索引了。</p>
<p>  需要注意的是，如果<code>IN</code>子查询不满足转换为<code>semi-join</code>的条件，又不能转换为物化表或者转换为物化表的成本太大，那么它就会被转换为<code>EXISTS</code>查询。</p>
</li>
</ul>
<blockquote>
<p>小贴士：在MySQL5.5以及之前的版本没有引进semi-join和物化的方式优化子查询时，优化器都会把IN子查询转换为EXISTS子查询，好多同学就惊呼我明明写的是一个不相关子查询，为什么要按照执行相关子查询的方式来执行呢？所以当时好多声音都是建议大家把子查询转为连接，不过随着MySQL的发展，最近的版本中引入了非常多的子查询优化策略，大家可以稍微放心的使用子查询了，内部的转换工作优化器会为大家自动实现。</p>
</blockquote>
<h2 id="ANY-x2F-ALL子查询优化"><a href="#ANY-x2F-ALL子查询优化" class="headerlink" title="ANY/ALL子查询优化"></a>ANY/ALL子查询优化</h2><p>  如果ANY/ALL子查询是不相关子查询的话，它们在很多场合都能转换成我们熟悉的方式去执行，比方说：</p>
<table>
<thead>
<tr>
<th>原始表达式</th>
<th>转换为</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; ANY (SELECT inner_expr …)</td>
<td>&lt; (SELECT MAX(inner_expr) …)</td>
</tr>
<tr>
<td>&gt; ANY (SELECT inner_expr …)</td>
<td>&gt; (SELECT MIN(inner_expr) …)</td>
</tr>
<tr>
<td>&lt; ALL (SELECT inner_expr …)</td>
<td>&lt; (SELECT MIN(inner_expr) …)</td>
</tr>
<tr>
<td>&gt; ALL (SELECT inner_expr …)</td>
<td>&gt; (SELECT MAX(inner_expr) …)</td>
</tr>
</tbody></table>
<h3 id="NOT-EXISTS子查询的执行"><a href="#NOT-EXISTS子查询的执行" class="headerlink" title="[NOT] EXISTS子查询的执行"></a>[NOT] EXISTS子查询的执行</h3><p>  如果<code>[NOT] EXISTS</code>子查询是不相关子查询，可以先执行子查询，得出该<code>[NOT] EXISTS</code>子查询的结果是<code>TRUE</code>还是<code>FALSE</code>，并重写原先的查询语句，比如对这个查询来说：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 
    <span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> key1 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">)</span> 
        <span class="token operator">OR</span> key2 <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>  因为这个语句里的子查询是不相关子查询，所以优化器会首先执行该子查询，假设该EXISTS子查询的结果为<code>TRUE</code>，那么接着优化器会重写查询为：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 
    <span class="token keyword">WHERE</span> <span class="token boolean">TRUE</span> <span class="token operator">OR</span> key2 <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>  进一步简化后就变成了：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 
    <span class="token keyword">WHERE</span> <span class="token boolean">TRUE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>  对于相关的<code>[NOT] EXISTS</code>子查询来说，比如这个查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 
    <span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> s1<span class="token punctuation">.</span>common_field <span class="token operator">=</span> s2<span class="token punctuation">.</span>common_field<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>  很不幸，这个查询只能按照我们年少时的那种执行相关子查询的方式来执行。不过如果<code>[NOT] EXISTS</code>子查询中如果可以使用索引的话，那查询速度也会加快不少，比如：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 
    <span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> s1<span class="token punctuation">.</span>common_field <span class="token operator">=</span> s2<span class="token punctuation">.</span>key1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>  上面这个<code>EXISTS</code>子查询中可以使用<code>idx_key1</code>来加快查询速度。</p>
<h3 id="对于派生表的优化"><a href="#对于派生表的优化" class="headerlink" title="对于派生表的优化"></a>对于派生表的优化</h3><p>  我们前面说过把子查询放在外层查询的<code>FROM</code>子句后，那么这个子查询的结果相当于一个<code>派生表</code>，比如下面这个查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span>  <span class="token punctuation">(</span>
        <span class="token keyword">SELECT</span> id <span class="token keyword">AS</span> d_id<span class="token punctuation">,</span>  key3 <span class="token keyword">AS</span> d_key3 <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> key1 <span class="token operator">=</span> <span class="token string">'a'</span>
    <span class="token punctuation">)</span> <span class="token keyword">AS</span> derived_s1 <span class="token keyword">WHERE</span> d_key3 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>  子查询<code>( SELECT id AS d_id,  key3 AS d_key3 FROM s2 WHERE key1 = 'a')</code>的结果就相当于一个派生表，这个表的名称是<code>derived_s1</code>，该表有两个列，分别是<code>d_id</code>和<code>d_key3</code>。</p>
<p>  对于含有<code>派生表</code>的查询，<code>MySQL</code>提供了两种执行策略：</p>
<ul>
<li><p>最容易想到的就是把派生表物化。</p>
<p>  我们可以将派生表的结果集写到一个内部的临时表中，然后就把这个物化表当作普通表一样参与查询。当然，在对派生表进行物化时，设计<code>MySQL</code>的大佬使用了一种称为<code>延迟物化</code>的策略，也就是在查询中真正使用到派生表时才回去尝试物化派生表，而不是还没开始执行查询呢就把派生表物化掉。比方说对于下面这个含有派生表的查询来说：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">(</span>
        <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> key1 <span class="token operator">=</span> <span class="token string">'a'</span>
    <span class="token punctuation">)</span> <span class="token keyword">AS</span> derived_s1 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> s2
    <span class="token keyword">ON</span> derived_s1<span class="token punctuation">.</span>key1 <span class="token operator">=</span> s2<span class="token punctuation">.</span>key1
    <span class="token keyword">WHERE</span> s2<span class="token punctuation">.</span>key2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  如果采用物化派生表的方式来执行这个查询的话，那么执行时首先会到<code>s1</code>表中找出满足<code>s1.key2 = 1</code>的记录，如果压根儿找不到，说明参与连接的<code>s1</code>表记录就是空的，所以整个查询的结果集就是空的，所以也就没有必要去物化查询中的派生表了。</p>
</li>
<li><p>将派生表和外层的表合并，也就是将查询重写为没有派生表的形式</p>
<p>  我们来看这个贼简单的包含派生表的查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> key1 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> derived_s1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>  这个查询本质上就是想查看<code>s1</code>表中满足<code>key1 = 'a'</code>条件的的全部记录，所以和下面这个语句是等价的：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> key1 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>  对于一些稍微复杂的包含派生表的语句，比如我们上面提到的那个：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">(</span>
        <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> key1 <span class="token operator">=</span> <span class="token string">'a'</span>
    <span class="token punctuation">)</span> <span class="token keyword">AS</span> derived_s1 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> s2
    <span class="token keyword">ON</span> derived_s1<span class="token punctuation">.</span>key1 <span class="token operator">=</span> s2<span class="token punctuation">.</span>key1
    <span class="token keyword">WHERE</span> s2<span class="token punctuation">.</span>key2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  我们可以将派生表与外层查询的表合并，然后将派生表中的搜索条件放到外层查询的搜索条件中，就像这样：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> s2 
    <span class="token keyword">ON</span> s1<span class="token punctuation">.</span>key1 <span class="token operator">=</span> s2<span class="token punctuation">.</span>key1
    <span class="token keyword">WHERE</span> s1<span class="token punctuation">.</span>key1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">AND</span> s2<span class="token punctuation">.</span>key2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>  这样通过将外层查询和派生表合并的方式成功的消除了派生表，也就意味着我们没必要再付出创建和访问临时表的成本了。可是并不是所有带有派生表的查询都能被成功的和外层查询合并，当派生表中有这些语句就不可以和外层查询合并：</p>
<ul>
<li>聚集函数，比如MAX()、MIN()、SUM()什么的</li>
<li>DISTINCT</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>LIMIT</li>
<li>UNION 或者 UNION ALL</li>
<li>派生表对应的子查询的<code>SELECT</code>子句中含有另一个子查询</li>
<li>… 还有些不常用的情况就不多说了～</li>
</ul>
</li>
</ul>
<p>  所以<code>MySQL</code>在执行带有派生表的时候，优先尝试把派生表和外层查询合并掉，如果不行的话，再把派生表物化掉执行查询。</p>
<p>完整文章为：《MySQL 是怎样运行的：从根儿上理解 MySQL》——第14章 不好看就要多整容-MySQL基于规则的优化（内含关于子查询优化二三事儿）</p>
]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL——Explain语句(select_type)</title>
    <url>/2023/03/25/mysql-explain-yu-ju-select-type/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>SIMPLE</code></td>
<td>Simple SELECT (not using UNION or subqueries)</td>
</tr>
<tr>
<td><code>PRIMARY</code></td>
<td>Outermost SELECT</td>
</tr>
<tr>
<td><code>UNION</code></td>
<td>Second or later SELECT statement in a UNION</td>
</tr>
<tr>
<td><code>UNION RESULT</code></td>
<td>Result of a UNION</td>
</tr>
<tr>
<td><code>SUBQUERY</code></td>
<td>First SELECT in subquery</td>
</tr>
<tr>
<td><code>DEPENDENT SUBQUERY</code></td>
<td>First SELECT in subquery, dependent on outer query</td>
</tr>
<tr>
<td><code>DEPENDENT UNION</code></td>
<td>Second or later SELECT statement in a UNION, dependent on outer query</td>
</tr>
<tr>
<td><code>DERIVED</code></td>
<td>Derived table</td>
</tr>
<tr>
<td><code>MATERIALIZED</code></td>
<td>Materialized subquery</td>
</tr>
<tr>
<td><code>UNCACHEABLE SUBQUERY</code></td>
<td>A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td>
</tr>
<tr>
<td><code>UNCACHEABLE UNION</code></td>
<td>The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td>
</tr>
</tbody></table>
<h3 id="SIMPLE"><a href="#SIMPLE" class="headerlink" title="SIMPLE"></a>SIMPLE</h3><p>  查询语句中不包含<code>UNION</code>或者子查询的查询都算作是<code>SIMPLE</code>类型，连接查询也算</p>
<h3 id="PRIMARY"><a href="#PRIMARY" class="headerlink" title="PRIMARY"></a>PRIMARY</h3><p>  对于包含<code>UNION</code>、<code>UNION ALL</code>或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的<code>select_type</code>值就是<code>PRIMARY</code>，比方说：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">UNION</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s2<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type  <span class="token operator">|</span> <span class="token keyword">table</span>      <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra           <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>      <span class="token operator">|</span> s1         <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">9688</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>            <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> <span class="token keyword">UNION</span>        <span class="token operator">|</span> s2         <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">9954</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>            <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token keyword">UNION</span> RESULT <span class="token operator">|</span> <span class="token operator">&lt;</span>union1<span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>     <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">temporary</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span>
<span class="token number">3</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  从结果中可以看到，最左边的小查询<code>SELECT * FROM s1</code>对应的是执行计划中的第一条记录，它的<code>select_type</code>值就是<code>PRIMARY</code>。</p>
<h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>  对于包含<code>UNION</code>或者<code>UNION ALL</code>的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的<code>select_type</code>值就是<code>UNION</code>，可以对比上一个例子的效果，这就不多举例子了。</p>
<h3 id="UNION-RESULT"><a href="#UNION-RESULT" class="headerlink" title="UNION RESULT"></a>UNION RESULT</h3><p>  <code>MySQL</code>选择使用临时表来完成<code>UNION</code>查询的去重工作，针对该临时表的查询的<code>select_type</code>就是<code>UNION RESULT</code>，例子上面有，就不赘述了。</p>
<h3 id="SUBQUERY"><a href="#SUBQUERY" class="headerlink" title="SUBQUERY"></a>SUBQUERY</h3><p>  如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是不相关子查询，并且查询优化器<strong>决定采用将该子查询物化的方案来执行该子查询</strong>时，该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>SUBQUERY</code>，比如下面这个查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> key1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> key1 <span class="token keyword">FROM</span> s2<span class="token punctuation">)</span> <span class="token operator">OR</span> key3 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>      <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra       <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>     <span class="token operator">|</span> s1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>   <span class="token operator">|</span> idx_key3      <span class="token operator">|</span> <span class="token boolean">NULL</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">9688</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> SUBQUERY    <span class="token operator">|</span> s2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">index</span> <span class="token operator">|</span> idx_key1      <span class="token operator">|</span> idx_key1 <span class="token operator">|</span> <span class="token number">303</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">9954</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span>
<span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  可以看到，外层查询的<code>select_type</code>就是<code>PRIMARY</code>，子查询的<code>select_type</code>就是<code>SUBQUERY</code>。需要大家注意的是，由于select_type为SUBQUERY的子查询由于会被物化，所以<strong>只需要执行一遍</strong>。</p>
<h3 id="DEPENDENT-SUBQUERY"><a href="#DEPENDENT-SUBQUERY" class="headerlink" title="DEPENDENT SUBQUERY"></a>DEPENDENT SUBQUERY</h3><p>  如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是相关子查询，则该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>DEPENDENT SUBQUERY</code>，比如下面这个查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> key1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> key1 <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> s1<span class="token punctuation">.</span>key2 <span class="token operator">=</span> s2<span class="token punctuation">.</span>key2<span class="token punctuation">)</span> <span class="token operator">OR</span> key3 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type        <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys     <span class="token operator">|</span> <span class="token keyword">key</span>      <span class="token operator">|</span> key_len <span class="token operator">|</span> ref               <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra       <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>            <span class="token operator">|</span> s1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> idx_key3          <span class="token operator">|</span> <span class="token boolean">NULL</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span>              <span class="token operator">|</span> <span class="token number">9688</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> DEPENDENT SUBQUERY <span class="token operator">|</span> s2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> ref  <span class="token operator">|</span> idx_key2<span class="token punctuation">,</span>idx_key1 <span class="token operator">|</span> idx_key2 <span class="token operator">|</span> <span class="token number">5</span>       <span class="token operator">|</span> xiaohaizi<span class="token punctuation">.</span>s1<span class="token punctuation">.</span>key2 <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>    <span class="token number">10.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+</span>
<span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">warnings</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  需要注意的是，select_type为<strong>DEPENDENT SUBQUERY的查询可能会被执行多次</strong>。</p>
<h3 id="DEPENDENT-UNION"><a href="#DEPENDENT-UNION" class="headerlink" title="DEPENDENT UNION"></a>DEPENDENT UNION</h3><p>  在包含<code>UNION</code>或者<code>UNION ALL</code>的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的<code>select_type</code>的值就是<code>DEPENDENT UNION</code>。比方说下面这个查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> key1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> key1 <span class="token keyword">FROM</span> s2 <span class="token keyword">WHERE</span> key1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token keyword">UNION</span> <span class="token keyword">SELECT</span> key1 <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> key1 <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type        <span class="token operator">|</span> <span class="token keyword">table</span>      <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>      <span class="token operator">|</span> key_len <span class="token operator">|</span> ref   <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                    <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>            <span class="token operator">|</span> s1         <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span>  <span class="token operator">|</span> <span class="token number">9688</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span>              <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> DEPENDENT SUBQUERY <span class="token operator">|</span> s2         <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> ref  <span class="token operator">|</span> idx_key1      <span class="token operator">|</span> idx_key1 <span class="token operator">|</span> <span class="token number">303</span>     <span class="token operator">|</span> const <span class="token operator">|</span>   <span class="token number">12</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">3</span> <span class="token operator">|</span> DEPENDENT <span class="token keyword">UNION</span>    <span class="token operator">|</span> s1         <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> ref  <span class="token operator">|</span> idx_key1      <span class="token operator">|</span> idx_key1 <span class="token operator">|</span> <span class="token number">303</span>     <span class="token operator">|</span> const <span class="token operator">|</span>    <span class="token number">8</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token keyword">UNION</span> RESULT       <span class="token operator">|</span> <span class="token operator">&lt;</span>union2<span class="token punctuation">,</span><span class="token number">3</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>     <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">temporary</span>          <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span>
<span class="token number">4</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.03</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  这个查询比较复杂啊，大查询里包含了一个子查询，子查询里又是由<code>UNION</code>连起来的两个小查询。从执行计划中可以看出来，<code>SELECT key1 FROM s2 WHERE key1 = 'a'</code>这个小查询由于是子查询中第一个查询，所以它的<code>select_type</code>是<code>DEPENDENT SUBQUERY</code>，而<code>SELECT key1 FROM s1 WHERE key1 = 'b'</code>这个查询的<code>select_type</code>就是<code>DEPENDENT UNION</code>。</p>
<h3 id="DERIVED"><a href="#DERIVED" class="headerlink" title="DERIVED"></a>DERIVED</h3><p>  对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的<code>select_type</code>就是<code>DERIVED</code>，比方说下面这个查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> key1<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> c <span class="token keyword">FROM</span> s1 <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> key1<span class="token punctuation">)</span> <span class="token keyword">AS</span> derived_s1 <span class="token keyword">where</span> c <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span>      <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>      <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra       <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">PRIMARY</span>     <span class="token operator">|</span> <span class="token operator">&lt;</span>derived2<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>   <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">9688</span> <span class="token operator">|</span>    <span class="token number">33.33</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> DERIVED     <span class="token operator">|</span> s1         <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">index</span> <span class="token operator">|</span> idx_key1      <span class="token operator">|</span> idx_key1 <span class="token operator">|</span> <span class="token number">303</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">9688</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span>
<span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  从执行计划中可以看出，<code>id</code>为<code>2</code>的记录就代表子查询的执行方式，它的<code>select_type</code>是<code>DERIVED</code>，说明该子查询是以物化的方式执行的。<code>id</code>为<code>1</code>的记录代表外层查询，大家注意看它的<code>table</code>列显示的是<code>&lt;derived2&gt;</code>，表示该查询是针对将派生表物化之后的表进行查询的。</p>
<p>​		派生表可以通过和外层查询合并的方式执行时，就会合并，</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> m1 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> t3<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra       <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t1    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token number">3</span> <span class="token operator">|</span>    <span class="token number">33.33</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="MATERIALIZED"><a href="#MATERIALIZED" class="headerlink" title="MATERIALIZED"></a>MATERIALIZED</h3><p>  当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的<code>select_type</code>属性就是<code>MATERIALIZED</code>，比如下面这个查询：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> s1 <span class="token keyword">WHERE</span> key1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> key1 <span class="token keyword">FROM</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type  <span class="token operator">|</span> <span class="token keyword">table</span>       <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span>   <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>        <span class="token operator">|</span> key_len <span class="token operator">|</span> ref               <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra       <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>       <span class="token operator">|</span> s1          <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>    <span class="token operator">|</span> idx_key1      <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span>              <span class="token operator">|</span> <span class="token number">9688</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>       <span class="token operator">|</span> <span class="token operator">&lt;</span>subquery2<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> eq_ref <span class="token operator">|</span> <span class="token operator">&lt;</span>auto_key<span class="token operator">&gt;</span>    <span class="token operator">|</span> <span class="token operator">&lt;</span>auto_key<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token number">303</span>     <span class="token operator">|</span> xiaohaizi<span class="token punctuation">.</span>s1<span class="token punctuation">.</span>key1 <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>        <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> MATERIALIZED <span class="token operator">|</span> s2          <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">index</span>  <span class="token operator">|</span> idx_key1      <span class="token operator">|</span> idx_key1   <span class="token operator">|</span> <span class="token number">303</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span>              <span class="token operator">|</span> <span class="token number">9954</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+</span>
<span class="token number">3</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  执行计划的第三条记录的<code>id</code>值为<code>2</code>，说明该条记录对应的是一个单表查询，从它的<code>select_type</code>值为<code>MATERIALIZED</code>可以看出，查询优化器是要把子查询先转换成物化表。然后看执行计划的前两条记录的<code>id</code>值都为<code>1</code>，说明这两条记录对应的表进行连接查询，需要注意的是第二条记录的<code>table</code>列的值是<code>&lt;subquery2&gt;</code>，说明该表其实就是<code>id</code>为<code>2</code>对应的子查询执行之后产生的物化表，然后将<code>s1</code>和该物化表进行连接查询。</p>
<h3 id="UNCACHEABLE-SUBQUERY"><a href="#UNCACHEABLE-SUBQUERY" class="headerlink" title="UNCACHEABLE SUBQUERY"></a>UNCACHEABLE SUBQUERY</h3><p>不常用，就不多介绍了。</p>
<h3 id="UNCACHEABLE-UNION"><a href="#UNCACHEABLE-UNION" class="headerlink" title="UNCACHEABLE UNION"></a>UNCACHEABLE UNION</h3><p>不常用，就不多介绍了。</p>
<p>完整文章为：《MySQL 是怎样运行的：从根儿上理解 MySQL》——第14章 查询优化的百科全书-Explain详解（上）</p>
]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL——子查询优化</title>
    <url>/2023/03/25/mysql-lian-jie-de-yuan-li/</url>
    <content><![CDATA[<p>用到的表结构</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">------+------+</span>
<span class="token operator">|</span> m1   <span class="token operator">|</span> n1   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------+------+</span>
<span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span> a    <span class="token operator">|</span>
<span class="token operator">|</span>    <span class="token number">2</span> <span class="token operator">|</span> b    <span class="token operator">|</span>
<span class="token operator">|</span>    <span class="token number">3</span> <span class="token operator">|</span> c    <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------+------+</span>
<span class="token number">3</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t2<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">------+------+</span>
<span class="token operator">|</span> m2   <span class="token operator">|</span> n2   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------+------+</span>
<span class="token operator">|</span>    <span class="token number">2</span> <span class="token operator">|</span> b    <span class="token operator">|</span>
<span class="token operator">|</span>    <span class="token number">3</span> <span class="token operator">|</span> c    <span class="token operator">|</span>
<span class="token operator">|</span>    <span class="token number">4</span> <span class="token operator">|</span> d    <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------+------+</span>
<span class="token number">3</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="1-嵌套循环连接（Nested-Loop-Join）"><a href="#1-嵌套循环连接（Nested-Loop-Join）" class="headerlink" title="1.嵌套循环连接（Nested-Loop Join）"></a>1.嵌套循环连接（Nested-Loop Join）</h3><p>  对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍，具体访问几遍取决于对驱动表执行单表查询后的结果集中的记录条数。对于内连接来说，选取哪个表为驱动表都没关系，而外连接的驱动表是固定的，也就是说左（外）连接的驱动表就是左边的那个表，右（外）连接的驱动表就是右边的那个表。</p>
<p><code>t1</code>表和<code>t2</code>表执行内连接查询的大致过程：</p>
<ul>
<li>步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。</li>
<li>步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。</li>
</ul>
<p>  通用的两表连接过程如下图所示：</p>
<p><img src="/2023/03/25/mysql-lian-jie-de-yuan-li/11-04.png" alt="img"></p>
<p>  如果有3个表进行连接的话，那么<code>步骤2</code>中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表，重复上面过程，也就是<code>步骤2</code>中得到的结果集中的每一条记录都需要到<code>t3</code>表中找一找有没有匹配的记录，用伪代码表示一下这个过程就是这样：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">for each row</span> <span class="token operator">in</span> t1 {   <span class="token comment">#此处表示遍历满足对t1单表查询结果集中的每一条记录</span>
    <span class="token keyword">for each row</span> <span class="token operator">in</span> t2 {   <span class="token comment">#此处表示对于某条t1表的记录来说，遍历满足对t2单表查询结果集中的每一条记录</span>
    
        <span class="token keyword">for each row</span> <span class="token operator">in</span> t3 {   <span class="token comment">#此处表示对于某条t1和t2表的记录组合来说，对t3表进行单表查询</span>
            <span class="token keyword">if</span> <span class="token keyword">row</span> satisfies <span class="token keyword">join</span> conditions<span class="token punctuation">,</span> send <span class="token keyword">to</span> client
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>  这个过程就像是一个嵌套的循环，所以这种驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为<code>嵌套循环连接</code>（<code>Nested-Loop Join</code>），这是最简单，也是最笨拙的一种连接查询算法。</p>
<h3 id="2-使用索引加快连接速度（Index-Nested-Loop-Join-INLJ-）"><a href="#2-使用索引加快连接速度（Index-Nested-Loop-Join-INLJ-）" class="headerlink" title="2.使用索引加快连接速度（Index Nested-Loop Join (INLJ)）"></a>2.使用索引加快连接速度（Index Nested-Loop <strong>Join</strong> (INLJ)）</h3><p>  利用索引在<code>嵌套循环连接</code>的<code>步骤2</code>中加快查询速度。回顾一下t1<code>表和</code>t2`表进行内连接的例子：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1<span class="token punctuation">,</span> t2 <span class="token keyword">WHERE</span> t1<span class="token punctuation">.</span>m1 <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">AND</span> t1<span class="token punctuation">.</span>m1 <span class="token operator">=</span> t2<span class="token punctuation">.</span>m2 <span class="token operator">AND</span> t2<span class="token punctuation">.</span>n2 <span class="token operator">&lt;</span> <span class="token string">'d'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>  使用的其实是<code>嵌套循环连接</code>算法执行的连接查询，再把上面那个查询执行过程表拉下来给大家看一下：</p>
<p><img src="/2023/03/25/mysql-lian-jie-de-yuan-li/11-05.png" alt="img"></p>
<p>  查询驱动表<code>t1</code>后的结果集中有两条记录，<code>嵌套循环连接</code>算法需要对被驱动表查询2次：</p>
<ul>
<li><p>当<code>t1.m1 = 2</code>时，去查询一遍<code>t2</code>表，对<code>t2</code>表的查询语句相当于：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t2 <span class="token keyword">WHERE</span> t2<span class="token punctuation">.</span>m2 <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">AND</span> t2<span class="token punctuation">.</span>n2 <span class="token operator">&lt;</span> <span class="token string">'d'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>当<code>t1.m1 = 3</code>时，再去查询一遍<code>t2</code>表，此时对<code>t2</code>表的查询语句相当于：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t2 <span class="token keyword">WHERE</span> t2<span class="token punctuation">.</span>m2 <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">AND</span> t2<span class="token punctuation">.</span>n2 <span class="token operator">&lt;</span> <span class="token string">'d'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<p>  可以看到，原来的<code>t1.m1 = t2.m2</code>这个涉及两个表的过滤条件在针对<code>t2</code>表做查询时关于<code>t1</code>表的条件就已经确定了，所以我们只需要单单优化对<code>t2</code>表的查询了，上述两个对<code>t2</code>表的查询语句中利用到的列是<code>m2</code>和<code>n2</code>列，那么就可以：</p>
<ul>
<li><p>在<code>m2</code>列上建立索引，因为对<code>m2</code>列的条件是等值查找，比如<code>t2.m2 = 2</code>、<code>t2.m2 = 3</code>等，所以可能使用到<code>ref</code>的访问方法，假设使用<code>ref</code>的访问方法去执行对<code>t2</code>表的查询的话，需要回表之后再判断<code>t2.n2 &lt; d</code>这个条件是否成立。</p>
<p>  这里有一个比较特殊的情况，就是假设<code>m2</code>列是<code>t2</code>表的主键或者唯一二级索引列，那么使用<code>t2.m2 = 常数值</code>这样的条件从<code>t2</code>表中查找记录的过程的代价就是常数级别的。我们知道在单表中使用主键值或者唯一二级索引列的值进行等值查找的方式称之为<code>const</code>，而设计<code>MySQL</code>的大佬把在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为：<code>eq_ref</code>。</p>
</li>
<li><p>在<code>n2</code>列上建立索引，涉及到的条件是<code>t2.n2 &lt; 'd'</code>，可能用到<code>range</code>的访问方法，假设使用<code>range</code>的访问方法对<code>t2</code>表的查询的话，需要回表之后再判断在<code>m2</code>列上的条件是否成立。</p>
</li>
</ul>
<p>  假设<code>m2</code>和<code>n2</code>列上都存在索引的话，那么就需要从这两个里边儿挑一个代价更低的去执行对<code>t2</code>表的查询。当然，建立了索引不一定使用索引，只有在<code>二级索引 + 回表</code>的代价比全表扫描的代价更低时才会使用索引。</p>
<p>  另外，有时候连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，而这些列都是某个索引的一部分，这种情况下即使不能使用<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>或者<code>range</code>这些访问方法执行对被驱动表的查询的话，也可以使用索引扫描，也就是<code>index</code>的访问方法来查询被驱动表。所以建议在真实工作中最好不要使用<code>*</code>作为查询列表，最好把真实用到的列作为查询列表。</p>
<h3 id="3-基于块的嵌套循环连接（Block-Nested-Loop-Join）"><a href="#3-基于块的嵌套循环连接（Block-Nested-Loop-Join）" class="headerlink" title="3.基于块的嵌套循环连接（Block Nested-Loop Join）"></a>3.基于块的嵌套循环连接（Block Nested-Loop Join）</h3><p>  内存里可能并不能完全存放的下表中所有的记录，所以在扫描表前面记录的时候后边的记录可能还在磁盘上，等扫描到后边记录的时候可能内存不足，所以需要把前面的记录从内存中释放掉。我们前面又说过，采用<code>嵌套循环连接</code>算法的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个<code>I/O</code>代价就非常大了，所以我们得想办法：<strong>尽量减少访问被驱动表的次数</strong>。</p>
<p>  当被驱动表中的数据非常多时，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。所以我们可不可以在<strong>把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价了</strong>。所以设计<code>MySQL</code>的大佬提出了一个<code>join buffer</code>的概念，<code>join buffer</code>就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个<code>join buffer</code>中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和<code>join buffer</code>中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的<code>I/O</code>代价。使用<code>join buffer</code>的过程如下图所示：</p>
<p><img src="/2023/03/25/mysql-lian-jie-de-yuan-li/11-06.png" alt="img"></p>
<p>  最好的情况是<code>join buffer</code>足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。设计<code>MySQL</code>的大佬把这种加入了<code>join buffer</code>的嵌套循环连接算法称之为<code>基于块的嵌套连接</code>（Block Nested-Loop Join）算法。</p>
<p>  这个<code>join buffer</code>的大小是可以通过启动参数或者系统变量<code>join_buffer_size</code>进行配置，默认大小为<code>262144字节</code>（也就是<code>256KB</code>），最小可以设置为<code>128字节</code>。当然，对于优化被驱动表的查询来说，最好是为被驱动表加上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大<code>join_buffer_size</code>的值来对连接查询进行优化。</p>
<p>  另外需要注意的是，驱动表的记录并不是所有列都会被放到<code>join buffer</code>中，只有查询列表中的列和过滤条件中的列才会被放到<code>join buffer</code>中，所以再次提醒我们，最好不要把<code>*</code>作为查询列表，只需要把我们关心的列放到查询列表就好了，这样还可以在<code>join buffer</code>中放置更多的记录呢。</p>
<p>完整文章为：《MySQL 是怎样运行的：从根儿上理解 MySQL》——第11章 两个表的亲密接触-连接的原理</p>
]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis——使用配置文档1</title>
    <url>/2023/03/25/mybatis-shi-yong-pei-zhi-wen-dang/</url>
    <content><![CDATA[<h1 id="MyBatis-框架"><a href="#MyBatis-框架" class="headerlink" title="MyBatis 框架"></a>MyBatis 框架</h1><h1 id="第一章-框架的概述"><a href="#第一章-框架的概述" class="headerlink" title="第一章 框架的概述"></a>第一章 框架的概述</h1><h2 id="1-三层架构"><a href="#1-三层架构" class="headerlink" title="1.三层架构"></a>1.三层架构</h2><p>mvc：web开发中，使用mvc架构模式。  m：数据， v：视图， c：控制器。</p>
<p>​          c控制器： 接收请求，调用service对象，显示请求的处理结果。 当前使用servlet作为控制器</p>
<p>​          v视图： 现在使用jsp， html，css，js。 显示请求的处理结果，把m中数据显示出来。</p>
<p>​          m数据： 来自数据库mysql， 来自文件，来自网络</p>
<p>mvc作用：</p>
<p>​     1）实现解耦合。 </p>
<p>​     2）让mvc 各负其职。  </p>
<p>​     3）使的系统扩展更好。更容易维护。 </p>
<p>三层架构：</p>
<p>1.界面层（视图层）：接收用户的请求，调用service， 显示请求的处理结果的。 包含了jsp，html，servlet等对象。 对应的包controller，</p>
<p>2.业务逻辑层：处理业务逻辑， 使用算法处理数据的。 把数据返回给界面层。 对应的是service包，和包中的很多的XXXService类。 例如：  StudentService ， OrderService, ShopService </p>
<p>3.持久层（数据库访问层）：访问数据库，或者读取文件，访问网络。获取数据。 对应的包是dao。 dao包中很多的StudentDao,  OrderDao,  ShopDao等等。</p>
<h2 id="2-三层架构请求的处理流程"><a href="#2-三层架构请求的处理流程" class="headerlink" title="2. 三层架构请求的处理流程"></a>2. 三层架构请求的处理流程</h2><p>用户发起请求—-&gt;界面层—–&gt;业务逻辑层—-&gt;持久层—-&gt;数据库（mysql）</p>
<h2 id="3-为什么要使用三层？"><a href="#3-为什么要使用三层？" class="headerlink" title="3. 为什么要使用三层？"></a>3. 为什么要使用三层？</h2><p>1，结构清晰、耦合度低, 各层分工明确<br>2，可维护性高，可扩展性高<br>3，有利于标准化<br>4，开发人员可以只关注整个结构中的其中某一层的功能实现<br>5，有利于各层逻辑的复用</p>
<h2 id="4-三层架构模式和框架"><a href="#4-三层架构模式和框架" class="headerlink" title="4. 三层架构模式和框架"></a>4. 三层架构模式和框架</h2><p>每一层对应着一个框架</p>
<p>1）界面层—SpringMVC框架</p>
<p>2）业务层—Spring框架</p>
<p>3）持久层—MyBatis框架</p>
<h2 id="5-框架"><a href="#5-框架" class="headerlink" title="5 .框架"></a>5 .框架</h2><ol>
<li>什么是框架（framework）</li>
</ol>
<p>框架：就是一个软件， 完成了部分的功能。  软件中的类和类之间的方法调用都已经规定好了。 通过这些可以完成某些功能。  框架看做是模版。   </p>
<p>框架是可以升级的，改造的。 框架是安全的。</p>
<p>框架是对某一个方面有用的，不是全能的。 </p>
<h2 id="6-框架解决的问题"><a href="#6-框架解决的问题" class="headerlink" title="6. 框架解决的问题"></a>6. 框架解决的问题</h2><p>1）框架能实现技术的整合。 </p>
<p>2）提供开发的效率。 降低难度。</p>
<h2 id="7-jdbc访问数据库的优缺点"><a href="#7-jdbc访问数据库的优缺点" class="headerlink" title="7. jdbc访问数据库的优缺点"></a>7. jdbc访问数据库的优缺点</h2><p>优点：</p>
<ol>
<li>直观，好理解</li>
</ol>
<p>缺点：</p>
<ol>
<li>创建很多对象 Connection ,Statement, ResultSet</li>
<li>注册驱动</li>
<li>执行sql语句</li>
<li>把ResultSet转为 Student ， List集合。</li>
<li>关闭资源</li>
<li>sql语句和业务逻辑代码混在一起</li>
</ol>
<h2 id="8-MyBatis框架"><a href="#8-MyBatis框架" class="headerlink" title="8 MyBatis框架"></a>8 MyBatis框架</h2><p>什么 mybatis： 是一个持久层框架， 原名是ibatis， 2013改名为 MyBatis.   MyBatis可以操作数据库，对数据执行增删改查。  看做是高级的jdbc。  解决jdbc的缺点。</p>
<p>mybatis能做什么？</p>
<p> 1） 注册驱动 。</p>
<p>  2） 创建jdbc中使用的Connection， Statement，ResultSet</p>
<ol start="3">
<li><p>执行sql语句， 得到ResultSet</p>
</li>
<li><p>处理ResultSet， 把记录集中的数据转为java对象，  同时还能把java对象放入到List集合。</p>
</li>
</ol>
<p>  5）关闭资源</p>
<p>  6）实现sql语句和java代码的解耦合。</p>
<p>mybatis的文档： <a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p>
<h1 id="第二章-MyBatis入门"><a href="#第二章-MyBatis入门" class="headerlink" title="第二章  MyBatis入门"></a>第二章  MyBatis入门</h1><h2 id="2-1-第一个例子"><a href="#2-1-第一个例子" class="headerlink" title="2.1 第一个例子"></a>2.1 第一个例子</h2><p>实现步骤：</p>
<p>0.创建student表（id，name，email，age）</p>
<p>1.新建maven项目</p>
<p>2.修改pom.xml </p>
<p>   1）加入依赖 mybatis依赖， mysql驱动， junit</p>
<p>   2）在<build>加入资源插件</build></p>
<p>3.创建实体类Student。定义属性， 属性名和列名保持一致</p>
<p>4.创建Dao接口， 定义操作数据库的方法。</p>
<p>5.创建xml文件（mapper文件）， 写sql语句。 </p>
<p>   mybatis框架推荐是把sql语句和java代码分开</p>
<p>   mapper文件：定义和dao接口在同一目录， 一个表一个mapper文件。</p>
<p>6.创建mybatis的主配置文件（xml文件）：有一个， 放在resources目录下</p>
<p>   1）定义创建连接实例的数据源（DataSource）对象</p>
<ol start="2">
<li>指定其他mapper文件的位置</li>
</ol>
<p>7.创建测试的内容。</p>
<p>   使用main方法，测试mybatis访问数据库</p>
<p>   也可以使用junit 访问数据库</p>
<h2 id="2-2-概念"><a href="#2-2-概念" class="headerlink" title="2.2 概念"></a>2.2 概念</h2><p>1.自动提交：当你的 sql语句执行完毕后， 提交事务。 数据库更新操作之间保存到数据</p>
<p>2.手动（手工）提交事务：在你需要提交事务的位置， 执行方法，提交事务或者回顾事务。</p>
<h2 id="2-3-MyBatis的一些重要对象"><a href="#2-3-MyBatis的一些重要对象" class="headerlink" title="2.3 MyBatis的一些重要对象"></a>2.3 MyBatis的一些重要对象</h2><p>1） Resources ： mybatis框架中的对象， 一个作用读取 主配置信息。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">InputStream</span> inputStream <span class="token operator">=</span> <span class="token class-name">Resources</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"mybatis.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>2）SqlSessionFactoryBuilder：负责创建SqlSessionFactory对象</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">SqlSessionFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>3）SqlSessionFactory: 重要对象</p>
<p>SqlSessionFactory是重量级对象：创建此对象需要使用更多的资源和时间。  在项目中有一个就可以了。</p>
<p>SqlSessionFactory接口：作用是SqlSession的工厂， 就是创建SqlSession对象。</p>
<p>DefaultSqlSessionFactory实现类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultSqlSessionFactory</span> <span class="token keyword">implements</span> <span class="token class-name">SqlSessionFactory</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>SqlSessionFactory接口中的方法</p>
<p>openSession(): 获取一个默认的SqlSession对象， 默认是需要手工提交事务的。</p>
<p>openSession(boolean): boolean参数表示是否自动提交事务。 </p>
<p>​                   true： 创建一个自动提交事务的SqlSession</p>
<p>​                  false:   等同于没有参数的openSession</p>
<ol start="4">
<li>SqlSession对象</li>
</ol>
<p>SqlSession对象是通过SqlSessionFactory获取的。 SqlSession本身是接口</p>
<p>DefaultSqlSession: 实现类</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultSqlSession</span> <span class="token keyword">implements</span> <span class="token class-name">SqlSession</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>SqlSession作用是提供了大量的执行sql语句的方法：</p>
<pre class="line-numbers language-:" data-language=":"><code class="language-:">selectOne：执行sql语句，最多得到一行记录，多余1行是错误。
selectList：执行sql语句，返回多行数据
selectMap：执行sql语句的，得到一个Map结果
insert：执行insert语句
update：执行update语句
delete：执行delete语句
commit：提交事务
rollback：回顾事务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>注意SqlSession对象不是线程安全的， 使用的步骤：</p>
<p>①：在方法的内部，执行sql语句之前，先获取SqlSession对象</p>
<p>②：调用SqlSession的方法，执行sql语句</p>
<p>③：关闭SqlSession对象，执行SqlSession.close()</p>
<h2 id="2-4-使用工具类和模版"><a href="#2-4-使用工具类和模版" class="headerlink" title="2.4 使用工具类和模版"></a>2.4 使用工具类和模版</h2><p>1）创建模版，mapper文件模版和mybatis主配置文件模版</p>
<p>创建模版的步骤：</p>
<p><img src="/images/image-20201019094212830.png" alt="image-20201019094212830">	</p>
<p>创建模版文件：</p>
<p><img src="/images/image-20201019094359625.png" alt="image-20201019094359625">	</p>
<p>创建文件选择使用的模版：</p>
<p><img src="/images/image-20201019094616208.png" alt="image-20201019094616208">	</p>
<h1 id="第三章-MyBatis的Dao代理"><a href="#第三章-MyBatis的Dao代理" class="headerlink" title="第三章  MyBatis的Dao代理"></a>第三章  MyBatis的Dao代理</h1><h2 id="3-1-dao代理"><a href="#3-1-dao代理" class="headerlink" title="3.1  dao代理"></a>3.1  dao代理</h2><h3 id="3-1-1-mybatis提供代理："><a href="#3-1-1-mybatis提供代理：" class="headerlink" title="3.1.1 mybatis提供代理："></a>3.1.1 mybatis提供代理：</h3><p> mybatis创建Dao接口的实现类对象， 完成对sql语句的执行。  mybatis创建一个对象代替你的 dao实现类功能。</p>
<h3 id="3-1-2-使用mybatis代理要求"><a href="#3-1-2-使用mybatis代理要求" class="headerlink" title="3.1.2 使用mybatis代理要求"></a>3.1.2 使用mybatis代理要求</h3><p>1）mapper文件中的namespace 一定dao接口的全限定名称</p>
<p>2）mapper文件中 标签的id是dao接口方法名称</p>
<h3 id="3-1-3-mybatis代理实现方式"><a href="#3-1-3-mybatis代理实现方式" class="headerlink" title="3.1.3 mybatis代理实现方式"></a>3.1.3 mybatis代理实现方式</h3><p>使用SqlSession对象的方法 getMapper(dao.class)</p>
<p>例如： 现在有 StudentDao接口。 </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">SqlSession</span> session  <span class="token operator">=</span> <span class="token class-name">MyBatisUtils</span><span class="token punctuation">.</span><span class="token function">getSqlSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">StudentDao</span> dao  <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">StudentDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Student</span> student <span class="token operator">=</span> dao<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">//上面代码中</span>
<span class="token class-name">StudentDao</span> dao  <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">StudentDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
等同于
<span class="token class-name">StudentDao</span> dao  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StudentDaoImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="3-2-理解参数"><a href="#3-2-理解参数" class="headerlink" title="3.2 理解参数"></a>3.2 理解参数</h2><p>理解参数是： 通过java程序把数据传入到mapper文件中的sql语句。 参数主要是指dao接口方法的形参</p>
<h3 id="3-2-1-parameterType"><a href="#3-2-1-parameterType" class="headerlink" title="3.2.1 parameterType"></a>3.2.1 parameterType</h3><p>parameterType:表示参数的类型， 指定dao方法的形参数据类型。 这个形参的数据类型是给mybatis使用。 mybatis在给sql语句的参数赋值时使用。 PreparedStatement.setXXX( 位置， 值) </p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">第一个用法： java类型的全限定类型名称   parameterType="java.lang.Integer"
第二个用法： mybatis定义的java类型的别名  parameterType="int"

parameterType：mybatis通过反射机制可以获取 dao接口方法参数的类型， 可以不写

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectById<span class="token punctuation">"</span></span>  <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>integer<span class="token punctuation">"</span></span>
                 <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
   select id,name,email,age from student where id=#{studentId}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-2-2-dao接口方法是一个简单类型的参数"><a href="#3-2-2-dao接口方法是一个简单类型的参数" class="headerlink" title="3.2.2 dao接口方法是一个简单类型的参数"></a>3.2.2 dao接口方法是一个简单类型的参数</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//dao接口的方法形参是一个简单类型的</span>
<span class="token comment">//简单类型： java基本数据类型和String</span>
<span class="token class-name">Student</span> <span class="token function">selectByEmail</span><span class="token punctuation">(</span><span class="token class-name">String</span> email<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--
   dao接口是一个简单类型的参数
   mapper文件，获取这个参数值，使用#{任意字符}
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectByEmail<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select id,name,email,age from student where email=#{studentEmail}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-2-3-dao接口方法有多个简单类型的参数"><a href="#3-2-3-dao接口方法有多个简单类型的参数" class="headerlink" title="3.2.3 dao接口方法有多个简单类型的参数"></a>3.2.3 dao接口方法有多个简单类型的参数</h3><p>@Param: 命名参数， 在方法的形参前面使用的， 定义参数名。  这个名称可以用在mapper文件中。</p>
<p>dao接口，方法的定义</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*
  多个简单类型的参数
  使用@Param命名参数， 注解是mybatis提供的
  位置：在形参定义的前面
  属性：value 自定义的参数名称
 */</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectByNameOrAge</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"myname"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span>
                                <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"myage"</span><span class="token punctuation">)</span> <span class="token class-name">Integer</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>mapper文件</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--
   多个简单类型的参数.
   当使用了@Param命名后，例如@Param("myname").
   在mapper中，使用#{命名的参数}， 例如 #{myname}
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectByNameOrAge<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select id,name,email,age from student where name=#{myname} or age=#{myage}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-2-4-dao接口方法使用一个对象作为参数"><a href="#3-2-4-dao接口方法使用一个对象作为参数" class="headerlink" title="3.2.4 dao接口方法使用一个对象作为参数"></a>3.2.4 dao接口方法使用一个对象作为参数</h3><p>方法的形参是一个java对象。这个java对象表示多个参数。使用对象的属性值作为参数使用</p>
<p>java对象</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>
    <span class="token comment">//set|get方法</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QueryParam</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span> p1<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Object</span> p2<span class="token punctuation">;</span>
    <span class="token comment">//set|get方法</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<p>dao接口中的方法定义</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*
 * 一个java对象作为参数( 对象由属性， 每个属性有set，get方法)
 */</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectByObject</span><span class="token punctuation">(</span><span class="token class-name">Student</span> student<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectByQueryParam</span><span class="token punctuation">(</span><span class="token class-name">QueryParam</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>mapper文件</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--
   一个java对象作为方法的参数，使用对象的属性作为参数值使用
   简单的语法： #{属性名} ， mybatis调用此属性的getXXX()方法获取属性值
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectByObject<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select id,name,email,age from student where name=#{name} or age=#{age}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectByQueryParam<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
     select id,name,email,age from student where name=#{p1} or age=#{p2}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!--负责的语法格式： #{属性名,javaType=java类型的全限定名称,jdbcType=mybatis中定义列的数据类型}--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectByObject<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        select id,name,email,age from student where
        name=#{name,javaType=java.lang.String,jdbcType=VARCHAR}
        or
        age=#{age,javaType=java.lang.Integer,jdbcType=INTEGER}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-2-5-dao接口中多个简单类型的参数，使用位置"><a href="#3-2-5-dao接口中多个简单类型的参数，使用位置" class="headerlink" title="3.2.5 dao接口中多个简单类型的参数，使用位置"></a>3.2.5 dao接口中多个简单类型的参数，使用位置</h3><p>参数位置： dao接口中方法的形参列表，从左往右，参数位置是 0 ， 1， 2……</p>
<p>语法格式：#{arg0} ,#{arg1}</p>
<p>dao接口的方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*
   使用位置，获取参数
 */</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectByPosition</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token class-name">Integer</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--
   mybatis版本是 3.5.1
   使用位置获取参数值， dao接口方法是多个简单类型的参数
   语法： #{arg0}, #{arg1}....
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectByPosition<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select id,name,email,age from student where name=#{arg0} or age=#{arg1}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-2-6-dao接口参数是一个Map"><a href="#3-2-6-dao接口参数是一个Map" class="headerlink" title="3.2.6 dao接口参数是一个Map"></a>3.2.6 dao接口参数是一个Map</h3><p>map作为dao接口的参数， 使用 key 获取参数值，mapper文件中，语法格式 #{key}</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*
   使用Map作为参数
 */</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectStudentByMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<p>mapper文件</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--
   使用Map传递参数，
   在mapper文件中，获取map的值，是通过key获取的，语法：#{key}
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectStudentByMap<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
     select id,name,email,age from student where name=#{myname} or age=#{myage}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>测试，调用方法的位置</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSelectByMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">SqlSession</span> sqlSession <span class="token operator">=</span> <span class="token class-name">MyBatisUtil</span><span class="token punctuation">.</span><span class="token function">getSqlSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">StudentDao</span> dao  <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">StudentDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//使用map传递参数</span>
    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    data<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"myname"</span><span class="token punctuation">,</span> <span class="token string">"李思思"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    data<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"myage"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> students <span class="token operator">=</span> dao<span class="token punctuation">.</span><span class="token function">selectStudentByMap</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

    students<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> stu<span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"stu="</span><span class="token operator">+</span>stu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sqlSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="3-3-和-的区别"><a href="#3-3-和-的区别" class="headerlink" title="3.3 #和$的区别"></a>3.3 #和$的区别</h2><h3 id="3-3-1-占位符"><a href="#3-3-1-占位符" class="headerlink" title="3.3.1 # 占位符"></a>3.3.1 # 占位符</h3><p>语法： #{字符}</p>
<p>mybatis处理#{} 使用jdbc对象是 PrepareStatment对象</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectById<span class="token punctuation">"</span></span>  <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>integer<span class="token punctuation">"</span></span>
             <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select id,name,email,age from student where id=#{studentId}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>

mybatis出创建PrepareStatement对象，执行sql语句
String sql=" select id,name,email,age from student where id=?";
PrepareStatement pst = conn.prepareStatement(sql);
pst.setInt(1,1001);  //传递参数
ResultSet rs  = pst.executeQuery(); //执行sql语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>#{}特点：</p>
<p>1）使用的PrepareStatement对象，执行sql语句，效率高。</p>
<p>2）使用的PrepareStatement对象，能避免sql语句， sql语句执行更安全。</p>
<p>3） #{} 常常作为 列值使用的， 位于等号的右侧，  #{}位置的值和数据类型有关的。</p>
<h3 id="3-3-2-占位符"><a href="#3-3-2-占位符" class="headerlink" title="3.3.2 $ 占位符"></a>3.3.2 $ 占位符</h3><p>语法 :  ${字符}</p>
<p>mybatis执行${}占位符的sql语句</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectById<span class="token punctuation">"</span></span>  <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>integer<span class="token punctuation">"</span></span>
             <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select id,name,email,age from student where id=${studentId}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>	

${} 表示字符串连接， 把sql语句的其他内容和 ${}内容使用 字符串（+） 连接的方式连在一起
String sql="select id,name,email,age from student where id=" + "1001";

mybatis创建Statement对象， 执行sql语句。
Statement stmt  = conn.createStatement(sql);
ResultSet rs  = stmt.executeQuery();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>${} 的特点</p>
<p>1）使用Statement对象，执行sql语句，效率低</p>
<p>2）${}占位符的值，使用的字符串连接方式， 有sql注入的风险。 有代码安全的问题</p>
<ol start="3">
<li>${} 数据是原样使用的， 不会区分数据类型。</li>
</ol>
<p>4）${} 常用作 表名或者列名， 在能保证数据安全的情况下使用 ${}</p>
<h2 id="3-4-封装MyBatis输出结果"><a href="#3-4-封装MyBatis输出结果" class="headerlink" title="3.4 封装MyBatis输出结果"></a>3.4 封装MyBatis输出结果</h2><p>封装输出结果： MyBatis执行sql语句，得到ResultSet, 转为java对象。 </p>
<p>讲两个 resultType, resultMap</p>
<h3 id="3-4-1-resultType"><a href="#3-4-1-resultType" class="headerlink" title="3.4.1 resultType"></a>3.4.1 resultType</h3><p>resultType属性： 在执行select时使用， 作为&lt;select&gt;标签的属性出现的。</p>
<p>resultType:表示结果类型 ，  mysql执行sql语句，得到java对象的类型。  它的值有两种</p>
<p>​		     1） java类型的全限定名称  。 2）使用别名</p>
<p>1） resultType:表示java自定义对象</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">Student selectById(Integer id);

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectById<span class="token punctuation">"</span></span>  <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>integer<span class="token punctuation">"</span></span>
             <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select id,name,email,age from student where id=#{studentId}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>

resultType:现在使用java类型的全限定名称。 表示的意思 mybatis执行sql，把ResultSet中的数据转为Student类型的对象。  mybatis会做以下操作：
1. 调用com.bjpowernode.domain.Student的无参数构造方法，创建对象。
    Student student = new Student(); //使用反射创建对象
2. 同名的列赋值给同名的属性。
    student.setId( rs.getInt("id"));
    student.setName(rs.getString("name"));
3. 得到java对象， 如果dao接口返回值是List集合， mybatis把student对象放入到List集合。


所以执行 Student mystudent = dao.selectById(1001); 得到 数据库中 id=1001这行数据， 
这行数据的列值， 付给了mystudent对象的属性。 你能得到mystudent对象。 就相当于是 id=1001这行数据。


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>2）resultType表示简单类型</p>
<p>dao方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> <span class="token function">countStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>mapper文件</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--
  执行sql语句，得到是一个值（一行一列）
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>countStudent<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.Long<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select count(*) from student
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>3） resultType:表示一个map结构</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//查询结果返回是一个Map</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectMap</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"stuid"</span><span class="token punctuation">)</span> <span class="token class-name">Integer</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--
   执行sql得到一个Map结构数据， mybatis执行sql，把ResultSet转为map
   sql执行结果， 列名做map的key ， 列值作为value
   sql执行得到是一行记录，转为map结构是正确的。

   dao接口返回是一个map， sql语句最多能获取一行记录，多余一行是错误

--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectMap<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.util.HashMap<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select id,name,email from student where id != #{stuid}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>练习题：</p>
<p> 输入一个省份id ，得到 省份id ，省份name， 城市id，城市名称</p>
<p>例如输入 省份id=1</p>
<p>1 河北  1 石家庄</p>
<p>1 河北   2 秦皇岛</p>
<h3 id="3-4-2-resultMap"><a href="#3-4-2-resultMap" class="headerlink" title="3.4.2 resultMap"></a>3.4.2 resultMap</h3><p>resultMap: 结果映射。 自定义列名和java对象属性的对应关系。 常用在列名和属性名不同的情况。</p>
<p>用法：</p>
<p>1.先定义 resultMap标签， 指定列名和属性名称对应关系</p>
<p>2.在select标签使用resultMap属性，指定上面定义的resultMap的id值</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--使用resultMap定义列和属性的关系--&gt;</span>
<span class="token comment">&lt;!--定义resultMap
    id:给resultMap的映射关系起个名称，唯一值
    type:java类型的全限定名称
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>customMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.vo.CustomObject<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

    <span class="token comment">&lt;!--定义列名和属性名的对应--&gt;</span>
    <span class="token comment">&lt;!--主键类型使用id标签--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cid<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token comment">&lt;!--非主键类型使用result标签--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cname<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token comment">&lt;!--列名和属性名相同不用定义--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!--使用resultMap属性，指定映射关系的id
    resultMap和resultType 不能同时使用， 二选一。
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectById2<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>customMap<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  select id,name,email,age from student where id=#{stuid}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="3-5-自定义别名"><a href="#3-5-自定义别名" class="headerlink" title="3.5 自定义别名"></a>3.5 自定义别名</h2><p>mybatis提供的对java类型定义简短，好记名称。</p>
<p>自定义别名的步骤：</p>
<p>1）在mybatis主配置文件，使用 typeAliases标签声明别名</p>
<p>2）在mapper文件中， resultType=”别名”</p>
<p>声明别名（mybatis主配置文件）</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAliases</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--第一种语法格式
        type:java类型的全限定名称（自定义类型）
        alias:自定义别名
    --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stu<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAliases</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>mapper文件中使用</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">resultType="别名"
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectById<span class="token punctuation">"</span></span>  <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>integer<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stu<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select id,name,email,age from student where id=#{studentId}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="3-6-列名和java对象属性名称不一样解决方式"><a href="#3-6-列名和java对象属性名称不一样解决方式" class="headerlink" title="3.6 列名和java对象属性名称不一样解决方式"></a>3.6 列名和java对象属性名称不一样解决方式</h2><p>1） 使用resultMap： 自定义列名和属性名称对应关系</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">/* 接口 */
List<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyStudent</span><span class="token punctuation">&gt;</span></span> selectMyStudent();

/* mapper文件 */
<span class="token comment">&lt;!-- 定义resultMap --&gt;</span>
MyStudent为新定义的java类，它的属性名跟数据库中的字段名是不一样的
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myStudentMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.apps.bean.MyStudent<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 列名和java属性的关属 --&gt;</span>
    <span class="token comment">&lt;!-- 主键列，使用id标签 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myId<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token comment">&lt;!-- 非主键列，使用result标签 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myName<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myEmail<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myAge<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectMyStudent<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>myStudentMap<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select * from stu;
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2）使用resultType:  使用列别名，让别名和java对象属性名称一样</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectDiffColProperty<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.apps.bean.MyStudent<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select id as myId,name as myName,email as myEmail,age as myAge from stu;
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h2 id="3-7-like"><a href="#3-7-like" class="headerlink" title="3.7 like"></a>3.7 like</h2><p>第一种方式： 在java程序中，把like的内容组装好。 把这个内容传入到sql语句</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//like第一种方式</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectLikeOne</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p>mapper</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--like第一种方式--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectLikeOne<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select * from student where name like #{name}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<p>执行like</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLikeOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">SqlSession</span> sqlSession <span class="token operator">=</span> <span class="token class-name">MyBatisUtil</span><span class="token punctuation">.</span><span class="token function">getSqlSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">StudentDao</span> dao  <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">StudentDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">String</span> name<span class="token operator">=</span><span class="token string">"%李%"</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> students <span class="token operator">=</span> dao<span class="token punctuation">.</span><span class="token function">selectLikeOne</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

    sqlSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    students<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> stu<span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>第二种方式： 在sql语句，组织like的内容。 </p>
<p>sql语句like的格式：  where name like “%”空格#{name}空格”%”</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//like第二种方式</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectLikeTwo</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--like第二种方式--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectLikeTwo<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select * from student where name like "%" #{name} "%"
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLikeTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">SqlSession</span> sqlSession <span class="token operator">=</span> <span class="token class-name">MyBatisUtil</span><span class="token punctuation">.</span><span class="token function">getSqlSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">StudentDao</span> dao  <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">StudentDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">String</span> name<span class="token operator">=</span><span class="token string">"李"</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> students <span class="token operator">=</span> dao<span class="token punctuation">.</span><span class="token function">selectLikeTwo</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

    sqlSession<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    students<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> stu<span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="第四章-动态sql"><a href="#第四章-动态sql" class="headerlink" title="第四章 动态sql"></a>第四章 动态sql</h1><p>什么是动态sql： 同一个dao的方法， 根据不同的条件可以表示不同的sql语句， 主要是where部分有变化</p>
<p>使用mybatis提供的标签，实现动态sql的能力，  主要讲 if ，where ，foreach， sql。</p>
<p>使用动态sql的时候， dao方法的形参使用java对象。 </p>
<p>什么时候使用动态sql：</p>
<p><img src="/images/image-20201020114831474.png" alt="image-20201020114831474">	</p>
<h2 id="4-1-if-标签"><a href="#4-1-if-标签" class="headerlink" title="4.1  if 标签"></a>4.1  if 标签</h2><p>语法：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>boolean判断结果<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
   sql 代码
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>


在mapper文件中
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectStudent<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpwoernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
      select *from student
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>条件<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
          sql语句
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>条件<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
          sql语句
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>例子：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectIf</span><span class="token punctuation">(</span><span class="token class-name">Student</span> student<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--if
    test: 使用对象的属性值作为条件
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectIf<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select * from student
    where id=-1
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name !=null and name!=''<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
       or  name = #{name}
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age &gt;0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        or age <span class="token entity named-entity" title="<">&amp;lt;</span> #{age}
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="4-2-where-标签"><a href="#4-2-where-标签" class="headerlink" title="4.2 where 标签"></a>4.2 where 标签</h2><p>使用if标签时，容易引起sql语句语法错误。  使用where标签解决if产生的语法问题。</p>
<p>使用时 where ,里面是一个或多个if 标签， 当有一个if标签 判断条件为true，  where标签会转为 WHERE 关键字附加到sql语句的后面。  如果 if 没有一个条件为true ， 忽略where和里面的if。</p>
<p>where标签删除 和他最近的or 或者 and。（注，但是不能把<code>AND</code>写在语句后面,eg:<code>name = #{name} OR</code>）</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">语法：
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>条件1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>sql语句1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>条件2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>sql语句2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>例子：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//where</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectWhere</span><span class="token punctuation">(</span><span class="token class-name">Student</span> student<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--where--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectWhere<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select * from student
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name !=null and name!=''<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            or  name = #{name}
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>

        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age &gt;0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            or age <span class="token entity named-entity" title="<">&amp;lt;</span> #{age}
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="4-3-foreach-循环"><a href="#4-3-foreach-循环" class="headerlink" title="4.3 foreach 循环"></a>4.3 foreach 循环</h2><p>使用foreach可以循环数组，list集合， 一般使用在in语句中。</p>
<p>语法：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt; foreach collection="集合类型" open="开始的字符" close="结束的字符"
          item="集合中的成员" separator="集合成员之间的分隔符"&gt;
              #{item 的值}
&lt;/ foreach&gt;

标签属性：
collection： 表示，循环的对象是 数组， 还是list集合。  如果dao接口方法的形参是 数组， 
             collection="array" ,如果dao接口形参是List， collection="list"

open:循环开始时的字符。  sql.append("(");
close：循环结束时字符。  sql.append(")");
item：集合成员， 自定义的变量。   Integer item  = idlist.get(i);// item是集合成员
separator：集合成员之间的分隔符。  sql.append(","); //集合成员之间的分隔符
#{item 的值}：获取集合成员的值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>第一种方式：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//foreach-1</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectForeachOne</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> idlist<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>foreach第一种方式， 循环简单类型的<span class="token class-name">List</span><span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">"selectForeachOne"</span> resultType<span class="token operator">=</span><span class="token string">"com.bjpowernode.domain.Student"</span><span class="token operator">&gt;</span>
      select <span class="token operator">*</span> from student
        <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"list !=null and list.size&gt;0"</span><span class="token operator">&gt;</span>
            where id in
            <span class="token operator">&lt;</span>foreach collection<span class="token operator">=</span><span class="token string">"list"</span> <span class="token keyword">open</span><span class="token operator">=</span><span class="token string">"("</span> close<span class="token operator">=</span><span class="token string">")"</span> separator<span class="token operator">=</span><span class="token string">","</span> item<span class="token operator">=</span><span class="token string">"myid"</span><span class="token operator">&gt;</span>
                  #<span class="token punctuation">{</span>myid<span class="token punctuation">}</span>
            <span class="token operator">&lt;</span><span class="token operator">/</span>foreach<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">&gt;</span>

<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSelectForeachOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//1.获取SqlSession</span>
        <span class="token class-name">SqlSession</span> session <span class="token operator">=</span> <span class="token class-name">MyBatisUtil</span><span class="token punctuation">.</span><span class="token function">getSqlSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//2.获取dao的代理</span>
        <span class="token class-name">StudentDao</span> dao <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">StudentDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> idlist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        idlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        idlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1002</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        idlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1003</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> students  <span class="token operator">=</span> dao<span class="token punctuation">.</span><span class="token function">selectForeachOne</span><span class="token punctuation">(</span>idlist<span class="token punctuation">)</span><span class="token punctuation">;</span>

        students<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> stu<span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"stu=="</span><span class="token operator">+</span>stu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//3.关闭SqlSession对象</span>
        session<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>第二种方式：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//foreach-2</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectForeachTwo</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> studentList<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>foreach第二种方式， 循环的<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span><span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">"selectForeachTwo"</span> resultType<span class="token operator">=</span><span class="token string">"com.bjpowernode.domain.Student"</span><span class="token operator">&gt;</span>
        select <span class="token operator">*</span> from student
        <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"list != null and list.size&gt;0"</span><span class="token operator">&gt;</span>
            where id in
            <span class="token operator">&lt;</span>foreach collection<span class="token operator">=</span><span class="token string">"list"</span> <span class="token keyword">open</span><span class="token operator">=</span><span class="token string">"("</span> close<span class="token operator">=</span><span class="token string">")"</span> separator<span class="token operator">=</span><span class="token string">","</span> item<span class="token operator">=</span><span class="token string">"stu"</span><span class="token operator">&gt;</span>
                  #<span class="token punctuation">{</span>stu<span class="token punctuation">.</span>id<span class="token punctuation">}</span>
            <span class="token operator">&lt;</span><span class="token operator">/</span>foreach<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">&gt;</span>
            
 <span class="token annotation punctuation">@Test</span>
 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSelectForeachTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//1.获取SqlSession</span>
        <span class="token class-name">SqlSession</span> session <span class="token operator">=</span> <span class="token class-name">MyBatisUtil</span><span class="token punctuation">.</span><span class="token function">getSqlSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//2.获取dao的代理</span>
        <span class="token class-name">StudentDao</span> dao <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">StudentDao</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> list  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Student</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s1<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Student</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s2<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1002</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> students  <span class="token operator">=</span> dao<span class="token punctuation">.</span><span class="token function">selectForeachTwo</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>

        students<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> stu<span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"stu=="</span><span class="token operator">+</span>stu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//3.关闭SqlSession对象</span>
        session<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="4-4-sql标签"><a href="#4-4-sql标签" class="headerlink" title="4.4 sql标签"></a>4.4 sql标签</h2><p>sql标签标示 一段sql代码， 可以是表名，几个字段， where条件都可以， 可以在其他地方复用sql标签的内容。</p>
<p>使用方式：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">1) 在mapper文件中定义 sql代码片段 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>唯一字符串<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  部分sql语句  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">&gt;</span></span>
2）在其他的位置，使用include标签引用某个代码片段<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p>例如：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--定义代码片段--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectStudent<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    select * from student
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>studentFieldList<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    id,name,email
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectIf<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectStudent<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>

        where id=-1
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name !=null and name!=''<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
           or  name = #{name}
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>

        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age &gt;0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            or age <span class="token entity named-entity" title="<">&amp;lt;</span> #{age}
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>

    <span class="token comment">&lt;!--where--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectWhere<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        select <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>studentFieldList<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span> from student
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name !=null and name!=''<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                or  name = #{name}
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>

            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age &gt;0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                or age <span class="token entity named-entity" title="<">&amp;lt;</span> #{age}
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="第五章-MyBatis配置文件"><a href="#第五章-MyBatis配置文件" class="headerlink" title="第五章 MyBatis配置文件"></a>第五章 MyBatis配置文件</h1><p>mybatis配置文件两大类： 1 mybatis主配置文件； 2 mybatis的mapper文件</p>
<ol>
<li>mybatis主配置文件，提供mybatis全局设置的。包含的内容 日志， 数据源，mapper文件位置</li>
<li>mapper文件： 写sql语句的。 一个表一个mapper文件</li>
</ol>
<h2 id="5-1-settings部分"><a href="#5-1-settings部分" class="headerlink" title="5.1 settings部分"></a>5.1 settings部分</h2><p>settings是mybatis的全局设置，影响整个mybatis的运行。 这个设置一般使用默认值就可以了。</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cacheEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lazyLoadingEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>multipleResultSetsEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>useColumnLabel<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>useGeneratedKeys<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>autoMappingBehavior<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>PARTIAL<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>autoMappingUnknownColumnBehavior<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>WARNING<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>defaultExecutorType<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SIMPLE<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>defaultStatementTimeout<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>25<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>defaultFetchSize<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>safeRowBoundsEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapUnderscoreToCamelCase<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>localCacheScope<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SESSION<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbcTypeForNull<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>OTHER<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lazyLoadTriggerMethods<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>equals,clone,hashCode,toString<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="5-2-typeAliase-别名"><a href="#5-2-typeAliase-别名" class="headerlink" title="5.2 typeAliase 别名"></a>5.2 typeAliase 别名</h2><p>设置别名</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAliases</span><span class="token punctuation">&gt;</span></span>
       <span class="token comment">&lt;!--第一种语法格式
           type:java类型的全限定名称（自定义类型）
           alias:自定义别名

           优点： 别名可以自定义
           缺点： 每个类型必须单独定义
       --&gt;</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain.Student<span class="token punctuation">"</span></span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stu<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.vo.QueryParam<span class="token punctuation">"</span></span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>qp<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>

       <span class="token comment">&lt;!--第二种方式
           name:包名， mybatis会把这个包中所有类名作为别名（不用区分大小写）
           优点：使用方便，一次给多个类定义别名
           缺点: 别名不能自定义，必须是类名。
       --&gt;</span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.domain<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.vo<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>

   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAliases</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面两种可以同时作用在一个类上</p>
<p><strong>使用注解@Alias在类的声明部分取别名的时候，使用指定包下取别名就无效了，但是可以和第一种语法格式同时使用</strong></p>
<h2 id="5-3-配置环境"><a href="#5-3-配置环境" class="headerlink" title="5.3 配置环境"></a>5.3 配置环境</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">environments: 环境标签， 在他里面可以配置多个environment
       属性： default ，必须是某个environment的id属性值。 表示mybatis默认连接的数据库
environment： 表示一个数据库的连接信息。
       属性： id 自定义的环境的标识。 唯一值。
transactionManager：事务管理器
       属性：  type 表示事务管理器的类型。
       属性值：1）JDBC: 使用Connection对象， 由mybatis自己完成事务的处理。
             2） MANAGED: 管理，表示把事务的处理交给容器实现（由其他软件完成事务的提交，回滚）
dataSource： 数据源，创建的Connection对象，连接数据库。
       属性：  type 数据源的类型
       属性值：1） POOLED， mybatis会在内存中创建PooledDataSource类，管理多个Connection连接对象，使用的连接池
             2） UNPOOLED ，不使用连接池， mybatis创建一个UnPooledDataSource这个类， 每次执行sql语句先创建Connection对象，再执行sql语句，最后关闭Connection
             3) JNDI : java的命名和目录服务。

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>online<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
            <span class="token comment">&lt;!--配置数据源： 创建Connection对象。--&gt;</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                <span class="token comment">&lt;!--driver:驱动的内容--&gt;</span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
                <span class="token comment">&lt;!--连接数据库的url--&gt;</span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span>
                          <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbc:mysql://localhost:3306/springdb<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
                <span class="token comment">&lt;!--用户名--&gt;</span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
                <span class="token comment">&lt;!--密码--&gt;</span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>123<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 项目上线后使用的数据库 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>online<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
            <span class="token comment">&lt;!--配置数据源： 创建Connection对象。--&gt;</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                <span class="token comment">&lt;!--driver:驱动的内容--&gt;</span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
                <span class="token comment">&lt;!--连接数据库的url--&gt;</span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span>
                          <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbc:mysql://localhost:3306/springdb<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
                <span class="token comment">&lt;!--用户名--&gt;</span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>admin<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
                <span class="token comment">&lt;!--密码--&gt;</span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>123456<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="5-4-使用数据库属性配置文件（-）"><a href="#5-4-使用数据库属性配置文件（-）" class="headerlink" title="5.4 使用数据库属性配置文件（*）"></a>5.4 使用数据库属性配置文件（*）</h2><p>需要把数据库的配置信息放到一个单独文件中， 独立管理。 这个文件扩展名是 properties. 在这个文件中，使用自定义的key=value的格式表示数据</p>
<p>使用步骤：</p>
<p>1.在resources目录中，创建xxxx.properties</p>
<p>2.在文件中，使用 key=value的格式定义数据。</p>
<p>   例如 jdbc.url=jdbc:mysq://localhost:3306/springdb</p>
<p>3.在mybatis主配置文件， 使用properties标签引用外部的属性配置文件</p>
<p>4.在使用值的位置， 使用${key}获取key对应的value（等号右侧的值）</p>
<p>例子：</p>
<p>jdbc.properties</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/springdb?useUnicode=true<span class="token entity named-entity" title="&amp;">&amp;amp;</span>characterEncoding=utf-8
jdbc.username=root
jdbc.password=123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<p>mybatis主配置文件</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--使用外部属性配置文件
    resource:指定类路径下的某个属性配置文件
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jdbc.properties<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
            <span class="token comment">&lt;!--配置数据源： 创建Connection对象。--&gt;</span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
                <span class="token comment">&lt;!--driver:驱动的内容--&gt;</span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${jdbc.driver}<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
                <span class="token comment">&lt;!--连接数据库的url--&gt;</span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${jdbc.url}<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
                <span class="token comment">&lt;!--用户名--&gt;</span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${jdbc.username}<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
                <span class="token comment">&lt;!--密码--&gt;</span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${jdbc.password}<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="5-5-mapper-标签"><a href="#5-5-mapper-标签" class="headerlink" title="5.5 mapper 标签(*)"></a>5.5 mapper 标签(*)</h2><p>使用mapper指定其他mapper文件的位置， </p>
<p>mapper标签使用的格式有两个常用的方式：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--第一种方式， resources="mapper文件的路径"
        优点：文件清晰。 加载的文件是明确的。
              文件的位置比较灵活。
        缺点：文件比较多， 代码量会比较大， 管理难度大
    --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com/bjpowernode/dao/StudentDao.xml<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com/bjpowernode/dao/OrderDao.xml<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token comment">&lt;!--
       第二种方式，使用&lt;package&gt;
       name:包名， mapper文件所在的包名。
       特点： 把这个包中的所有mapper文件，一次加载。

       使用要求：
        1. mapper文件和dao接口在同一目录
        2. mapper文件和dao接口名称完全一样。
    --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.dao<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.bjpowernode.dao1<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="第六章-PageHelper"><a href="#第六章-PageHelper" class="headerlink" title="第六章 PageHelper"></a>第六章 PageHelper</h1><p>PageHelper做数据分页。 在你的select语句后面加入 分页的 sql 内容， 如果你使用的mysql数据库， 它就是在select * from student 后面加入 limit 语句。</p>
<p>使用步骤：</p>
<p>1.加入依赖pagehelper依赖</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.github.pagehelper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>pagehelper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.1.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>2.在mybatis主配置文件， 加入plugin声明</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">在<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span><span class="token punctuation">&gt;</span></span> 之前加入
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span> <span class="token attr-name">interceptor</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.github.pagehelper.PageInterceptor<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<p>3.在select语句之前，调用PageHelper.startPage(页码， 每页大小)</p>
<p>对比：</p>
<p>没有使用PageHelper</p>
<p>select * from student order by id</p>
<p>使用PageHelper</p>
<p>SELECT count(0) FROM student </p>
<p>select * from student order by id LIMIT ? </p>
<p><a href="https://www.bilibili.com/video/BV1Tv411b7Dp/">来源教程</a></p>
]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis——BitMap</title>
    <url>/2023/03/20/redis-bitmap/</url>
    <content><![CDATA[<h3 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1 基本命令"></a>1 基本命令</h3><p>Redis提供了<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>四个常用命令用于处理二进制位数组。</p>
<blockquote>
<ul>
<li><code>SETBIT</code>：为位数组指定偏移量上的二进制位设置值，偏移量从0开始计数，二进制位的值只能为0或1。返回原位置值。</li>
<li><code>GETBIT</code>：获取指定偏移量上二进制位的值。</li>
<li><code> BITCOUNT</code>：统计位数组中值为1的二进制位数量。</li>
<li><code>BITOP</code>：对多个位数组进行按位与、或、异或运算。</li>
</ul>
</blockquote>
<h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h3><h4 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h4><blockquote>
<p><strong>扩展：Redis 中的每个对象都是有一个 redisObject 结构表示的。</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
     <span class="token comment">// 类型</span>
     <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
     <span class="token comment">// 编码</span>
     <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
     <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>REDIS_LRU_BITS<span class="token punctuation">;</span> <span class="token comment">/* lru time (relative to server.lruclock) */</span>
     <span class="token comment">// 引用计数</span>
     <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>
     <span class="token comment">// 执行底层实现的数据结构的指针</span>
     <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</blockquote>
<p><img src="/2023/03/20/redis-bitmap/640.png"></p>
<ul>
<li><code>type</code> 的值为 <code>REDIS_STRING</code>表示这是一个字符串对象</li>
<li><code>sdshdr.len</code> 的值为1表示这个SDS保存了一个1字节大小的位数组</li>
<li>buf数组中的<code>buf[0]</code>实际保存了位数组</li>
<li>buf数组中的<code>buf[1]</code>为自动追加的<code>\0</code>字符</li>
</ul>
<h4 id="3-2-GETBIT"><a href="#3-2-GETBIT" class="headerlink" title="3.2 GETBIT"></a>3.2 GETBIT</h4><p><code>GETBIT</code>用于返回位数组在偏移量上的二进制位的值。**<code>GETBIT</code>的时间复杂度是<code>O(1)</code>。**</p>
<p><code>GETBIT</code>命令的执行过程如下：</p>
<ol>
<li>计算byte=⌊offset÷8⌋ (即<code>&gt;&gt;3</code>)，byte 值表示指定的 <em>offset</em> 位于位数组的哪个字节(计算在第几行)；</li>
<li>指定 buf[i]中的i了，接下来就要计算在8个字节中的第几位：使用 <code>bit=(offset % 8)+1</code>（取模运算用位运算取最低三位代替）计算可得；</li>
<li>根据 byte 和 bit在位数组中定位到目标值返回即可。</li>
</ol>
<p>源码:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">getbitCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    robj <span class="token operator">*</span>o<span class="token punctuation">;</span>
    <span class="token keyword">char</span> llbuf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> bitoffset<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> byte<span class="token punctuation">,</span> bit<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> bitval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取offset</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getBitOffsetFromArgument</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>bitoffset<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">// 查找对应的位图对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>o <span class="token operator">=</span> <span class="token function">lookupKeyReadOrReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>shared<span class="token punctuation">.</span>czero<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span>
        <span class="token function">checkType</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>o<span class="token punctuation">,</span>OBJ_STRING<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token comment">// 计算offset位于位数组的哪一行</span>
    byte <span class="token operator">=</span> bitoffset <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token comment">// 计算offset在一行中的第几位，等同于取模，取最后几位</span>
    bit <span class="token operator">=</span> <span class="token number">7</span> <span class="token operator">-</span> <span class="token punctuation">(</span>bitoffset <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// #define sdsEncodedObject(objptr) (objptr-&gt;encoding == OBJ_ENCODING_RAW || objptr-&gt;encoding == OBJ_ENCODING_EMBSTR)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sdsEncodedObject</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// SDS 是RAW 或者 EMBSTR类型</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>byte <span class="token operator">&lt;</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>o<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment">// 获取指定位置的值</span>
            <span class="token comment">// 注意它不是真正的一个二维数组不能用((uint8_t*)o-&gt;ptr)[byte][bit]去获取呀~</span>
            bitval <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span>o<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span>byte<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">//  SDS 是 REDIS_ENCODING_INT 类型的整数，先转为String</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>byte <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token function">ll2string</span><span class="token punctuation">(</span>llbuf<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>llbuf<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>o<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span>
            bitval <span class="token operator">=</span> llbuf<span class="token punctuation">[</span>byte<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> bitval <span class="token operator">?</span> shared<span class="token punctuation">.</span>cone <span class="token operator">:</span> shared<span class="token punctuation">.</span>czero<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2023/03/20/redis-bitmap/640-16792863934224.png"></p>
<h4 id="3-3-SETBIT"><a href="#3-3-SETBIT" class="headerlink" title="3.3 SETBIT"></a>3.3 SETBIT</h4><p><code>SETBIT</code>用于将位数组在偏移量的二进制位的值设为value，并向客户端返回旧值。</p>
<p><code>SITBIT</code>命令的执行过程如下：</p>
<ol>
<li>计算len=⌊offset÷8⌋+1，len值记录了保存offset偏移量指定的二进制位至少需要多少字节</li>
<li>检查位数组的长度是否小于len，如果是的话，将SDS的长度扩展为len字节,并将所有新扩展空间的二进制位设置为0</li>
<li>计算byte=⌊offset÷8⌋，byte值表示指定的offset位于位数组的那个字节(就是计算在那个buf[i]中的iii)</li>
<li>使用bit=(offset mod 8)+1计算可得目标buf[i]的具体第几位</li>
<li>根据byte和bit的值，首先保存oldValue，然后将新值value设置到目标位上</li>
<li>返回旧值</li>
</ol>
<blockquote>
<p><strong>因为SETBIT命令执行的所有操作都可以在常数时间内完成，所以该命令的算法复杂度为O(1)。</strong></p>
</blockquote>
<p><code>SETBIT</code>命令源码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">setbitCommand</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    robj <span class="token operator">*</span>o<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>err <span class="token operator">=</span> <span class="token string">"bit is not an integer or out of range"</span><span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> bitoffset<span class="token punctuation">;</span>
    <span class="token class-name">ssize_t</span> byte<span class="token punctuation">,</span> bit<span class="token punctuation">;</span>
    <span class="token keyword">int</span> byteval<span class="token punctuation">,</span> bitval<span class="token punctuation">;</span>
    <span class="token keyword">long</span> on<span class="token punctuation">;</span>
    <span class="token comment">// 获取offset</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getBitOffsetFromArgument</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>bitoffset<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取我们需要设置的值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getLongFromObjectOrReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>on<span class="token punctuation">,</span>err<span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>

    <span class="token comment">/* 判断指定值是否为0或1 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>on <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 设置了0和1之外的值，直接报错</span>
        <span class="token function">addReplyError</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 根据key查询SDS对象（会自动扩容）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>o <span class="token operator">=</span> <span class="token function">lookupStringForBitCommand</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>bitoffset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

    <span class="token comment">/* 获得当前值 */</span>
    byte <span class="token operator">=</span> bitoffset <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">;</span>
    byteval <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span>o<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span>byte<span class="token punctuation">]</span><span class="token punctuation">;</span>
    bit <span class="token operator">=</span> <span class="token number">7</span> <span class="token operator">-</span> <span class="token punctuation">(</span>bitoffset <span class="token operator">&amp;</span> <span class="token number">0x7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bitval <span class="token operator">=</span> byteval <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* 更新值并返回旧值 */</span>
    byteval <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    byteval <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>on <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> bit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span>o<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span><span class="token punctuation">[</span>byte<span class="token punctuation">]</span> <span class="token operator">=</span> byteval<span class="token punctuation">;</span>
    <span class="token comment">// 发送数据修改通知</span>
    <span class="token function">signalModifiedKey</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>db<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">notifyKeyspaceEvent</span><span class="token punctuation">(</span>NOTIFY_STRING<span class="token punctuation">,</span><span class="token string">"setbit"</span><span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>db<span class="token operator">-&gt;</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    server<span class="token punctuation">.</span>dirty<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token function">addReply</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> bitval <span class="token operator">?</span> shared<span class="token punctuation">.</span>cone <span class="token operator">:</span> shared<span class="token punctuation">.</span>czero<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>（这个图我真的，我哭鼠，他是真的想让我学会的😭）</p>
<p><img src="/2023/03/20/redis-bitmap/640-16792866625376.png"></p>
<h4 id="2-4-BITCOUNT"><a href="#2-4-BITCOUNT" class="headerlink" title="2.4 BITCOUNT"></a>2.4 BITCOUNT</h4><p><code>BITCOUNT</code>命令用于统计给定位数组中值为1的二进制位的数量。功能似乎不复杂，但实际上要高效地实现这个命令并不容易，需要用到一些精巧的算法。</p>
<blockquote>
<p><strong>统计一个位数组中非0二进制位的数量在数学上被称为”计算汉明重量”。</strong></p>
</blockquote>
<h5 id="二进制位统计算法-variable-precision-SWAR"><a href="#二进制位统计算法-variable-precision-SWAR" class="headerlink" title="二进制位统计算法:variable-precision SWAR"></a>二进制位统计算法:variable-precision SWAR</h5><p>目前已知效率最好的通用算法为<code>variable-precision SWAR</code>算法，该算法通过一系列位移和位运算操作，可以在常数时间内计算多个字节的汉明重量，并且不需要使用任何额外的内存</p>
<p>算法代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> <span class="token function">swar</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 5的二进制：0101</span>
    i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3的二进制：0011</span>
    i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0F</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    i <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x01010101</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token comment">//——————————上面为展开版，下面为更简洁版——————————————</span>
    i <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0F</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0x01010101</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">24</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>步骤一计算出的值i的二进制表示可以按<strong>每两个二进制位为一组进行分组</strong>，各组的十进制表示就是该组的1的数量；</li>
<li>步骤二计算出的值i的二进制表示可以按<strong>每四个二进制位为一组进行分组</strong>，各组的十进制表示就是该组的1的数量；</li>
<li>步骤三计算出的值i的二进制表示可以按<strong>每八个二进制位为一组进行分组</strong>，各组的十进制表示就是该组的1的数量；</li>
<li>步骤四的<code>i*0x01010101</code>语句计算出bitarray中1的数量并记录在二进制位的最高八位，而<code>&gt;&gt;24</code>语句则通过右移运算，将bitarray的汉明重量移动到最低八位，得出的结果就是bitarray的汉明重量。</li>
</ol>
<blockquote>
<p> <strong>Integer.bitCount方法，也是基于SWAR算法的思想</strong></p>
</blockquote>
<h5 id="2-4-4-源码分析"><a href="#2-4-4-源码分析" class="headerlink" title="2.4.4 源码分析"></a>2.4.4 源码分析</h5><p>Redis 中通过调用<code>redisPopcount</code>方法统计汉明重量，源码如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">redisPopcount</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">long</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> bits <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> s<span class="token punctuation">;</span>
    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>p4<span class="token punctuation">;</span>
    <span class="token comment">// 为查表法准备的表</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> bitsinbyte<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// CPU一次性读取8个字节，如果4字节跨了两个8字节，需要读取两次才行</span>
    <span class="token comment">// 所以考虑4字节对齐，只需读取一次就可以读取完毕</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>p <span class="token operator">&amp;</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        bits <span class="token operator">+=</span> bitsinbyte<span class="token punctuation">[</span><span class="token operator">*</span>p<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 一次性处理28字节，单独看一个aux就容易理解了，其实就是SWAR算法</span>
    <span class="token comment">// uint32_t：4字节</span>
    p4 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token operator">&gt;=</span><span class="token number">28</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">uint32_t</span> aux1<span class="token punctuation">,</span> aux2<span class="token punctuation">,</span> aux3<span class="token punctuation">,</span> aux4<span class="token punctuation">,</span> aux5<span class="token punctuation">,</span> aux6<span class="token punctuation">,</span> aux7<span class="token punctuation">;</span>

        aux1 <span class="token operator">=</span> <span class="token operator">*</span>p4<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 一次性读取4字节</span>
        aux2 <span class="token operator">=</span> <span class="token operator">*</span>p4<span class="token operator">++</span><span class="token punctuation">;</span>
        aux3 <span class="token operator">=</span> <span class="token operator">*</span>p4<span class="token operator">++</span><span class="token punctuation">;</span>
        aux4 <span class="token operator">=</span> <span class="token operator">*</span>p4<span class="token operator">++</span><span class="token punctuation">;</span>
        aux5 <span class="token operator">=</span> <span class="token operator">*</span>p4<span class="token operator">++</span><span class="token punctuation">;</span>
        aux6 <span class="token operator">=</span> <span class="token operator">*</span>p4<span class="token operator">++</span><span class="token punctuation">;</span>
        aux7 <span class="token operator">=</span> <span class="token operator">*</span>p4<span class="token operator">++</span><span class="token punctuation">;</span>
        count <span class="token operator">-=</span> <span class="token number">28</span><span class="token punctuation">;</span><span class="token comment">// 共处理了4*7=28个字节，所以count需要减去28</span>

        aux1 <span class="token operator">=</span> aux1 <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>aux1 <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        aux1 <span class="token operator">=</span> <span class="token punctuation">(</span>aux1 <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>aux1 <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        aux2 <span class="token operator">=</span> aux2 <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>aux2 <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        aux2 <span class="token operator">=</span> <span class="token punctuation">(</span>aux2 <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>aux2 <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        aux3 <span class="token operator">=</span> aux3 <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>aux3 <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        aux3 <span class="token operator">=</span> <span class="token punctuation">(</span>aux3 <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>aux3 <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        aux4 <span class="token operator">=</span> aux4 <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>aux4 <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        aux4 <span class="token operator">=</span> <span class="token punctuation">(</span>aux4 <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>aux4 <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        aux5 <span class="token operator">=</span> aux5 <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>aux5 <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        aux5 <span class="token operator">=</span> <span class="token punctuation">(</span>aux5 <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>aux5 <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        aux6 <span class="token operator">=</span> aux6 <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>aux6 <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        aux6 <span class="token operator">=</span> <span class="token punctuation">(</span>aux6 <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>aux6 <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        aux7 <span class="token operator">=</span> aux7 <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>aux7 <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x55555555</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        aux7 <span class="token operator">=</span> <span class="token punctuation">(</span>aux7 <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>aux7 <span class="token operator">&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x33333333</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        bits <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>aux1 <span class="token operator">+</span> <span class="token punctuation">(</span>aux1 <span class="token operator">&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0F</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>aux2 <span class="token operator">+</span> <span class="token punctuation">(</span>aux2 <span class="token operator">&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0F</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>aux3 <span class="token operator">+</span> <span class="token punctuation">(</span>aux3 <span class="token operator">&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0F</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>aux4 <span class="token operator">+</span> <span class="token punctuation">(</span>aux4 <span class="token operator">&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0F</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>aux5 <span class="token operator">+</span> <span class="token punctuation">(</span>aux5 <span class="token operator">&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0F</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>aux6 <span class="token operator">+</span> <span class="token punctuation">(</span>aux6 <span class="token operator">&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0F</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>aux7 <span class="token operator">+</span> <span class="token punctuation">(</span>aux7 <span class="token operator">&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x0F0F0F0F</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span> <span class="token number">0x01010101</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">24</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* 剩余的不足28字节，使用查表法统计 */</span>
    p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>p4<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token operator">--</span><span class="token punctuation">)</span> bits <span class="token operator">+=</span> bitsinbyte<span class="token punctuation">[</span><span class="token operator">*</span>p<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> bits<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Redis 中同时运用了<strong>查表法</strong>和<strong>SWAR算法</strong>完成<code>BITCOUNT</code>功能。</p>
<h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3 应用"></a>3 应用</h3><p>大量数据去重、排序、用户签到、统计活跃用户、实现布隆过滤器，下面详细介绍布隆过滤器</p>
<h4 id="布隆过滤器简介和算法流程"><a href="#布隆过滤器简介和算法流程" class="headerlink" title="布隆过滤器简介和算法流程"></a>布隆过滤器简介和算法流程</h4><blockquote>
<p><strong>主要特征</strong></p>
<p>一种紧凑型的、比较巧妙的概率型数据结构，它由一个很长的二进制向量( 位向量)和一系列随机均匀分布的散列( 哈希)函数组成 此种方式不仅可以提升查询效率，也可以节省大量的内存空间。</p>
<p>存在假阳性（将不在集合中的元素误判为在集合中），不存在假阴性（将在集合中的元素误判为不在集合中）。过滤器中的元素个数越多，假阳性的可能性越大，总的来说，当不考虑集合中元素个数的情况下，每个元素由10个以下的bit来表示就可以保证1%以内的假阳性概率。</p>
<p>元素可以被加入过滤器，但不可从过滤器中删除（因为删除的时候有可能会影响到其他元素，之后会细说）。</p>
<p><strong>空间和时间优势</strong></p>
<p>布隆过滤器不需要存储数据项，但是同时它需要在其他地方单独存储真正的数据项。对于一个拥有最优k值且误判率在1%的布隆过滤器，每个元素只需要9.6bits（与元素的大小无关）。这个优点一部分继承自数组的紧凑性，另一方面由它本身的概率性决定。若给每个元素增加4.8bits左右，误判率将会减少十倍。</p>
<p>布隆过滤器在添加和查找元素时，所需要的时间是一个常数，O(k)，完全与集合中元素个数无关。没有其他固定空间的集合数据结构有这样的效率，但是对于稀疏散列表来说，平均访问时长在实际使用中比一些布隆过滤器要短。在硬件实现方式中，布隆过滤器的优势在于他的k个查询之间不相关，因此<strong>可以并行处理</strong>。</p>
</blockquote>
<p>布隆过滤器（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k</p>
<p><img src="/2023/03/20/redis-bitmap/1030776-20170106143141784-1475031003.png"></p>
<p>以上图为例，具体的操作流程：</p>
<p>假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。</p>
<ol>
<li><p>首先将位数组进行初始化，将里面每个位都设置位0。</p>
</li>
<li><p>对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1。</p>
</li>
<li><p>查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。</p>
<ul>
<li><p>如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。</p>
</li>
<li><p>反之，如果3个点都为1，则该元素可能存在集合中。</p>
<blockquote>
<p>注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这3个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是1，这是误判率存在的原因。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h4><p>谷歌公司提供的Guava 工具提供了布隆过滤器的实现，先不分析源码了吧，有机会补上【【flag】】</p>
<h4 id="布隆过滤器应用（反正过滤就对了）"><a href="#布隆过滤器应用（反正过滤就对了）" class="headerlink" title="布隆过滤器应用（反正过滤就对了）"></a>布隆过滤器应用（反正过滤就对了）</h4><ul>
<li>字处理软件中，需要检查一个英语单词是否拼写正确</li>
<li>在 FBI，一个嫌疑人的名字是否已经在嫌疑名单上</li>
<li>在网络爬虫里，一个网址是否被访问过</li>
<li>yahoo, gmail等邮箱垃圾邮件过滤功能</li>
</ul>
<p>联想一下：分布式数据库TiDB的TiKV使用的底层RocksDB查询就利用了bloom filter不存在假阴性加快查找速度。</p>
<p><a href="https://juejin.cn/post/7074747080492711943">完整含详细解释来源1</a></p>
<p>（布隆过滤器的内容也来源网络，看了好几个都大差不差，所以就省略哩）</p>
]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis——RDB快照</title>
    <url>/2023/03/23/redis-rdb-kuai-zhao/</url>
    <content><![CDATA[<p>Redis为数据的持久化提供了两个技术——「 AOF 日志和 RDB 快照」。</p>
<p>这两种技术都会用各用一个日志文件来记录信息，但是记录的内容是不同的。</p>
<ul>
<li>AOF 文件的内容是操作命令；</li>
<li>RDB 文件的内容是二进制数据。</li>
</ul>
<h3 id="常用指令及配置"><a href="#常用指令及配置" class="headerlink" title="常用指令及配置"></a>常用指令及配置</h3><p>Redis 提供了两个命令来生成 RDB 文件，分别是 <code>save</code> 和 <code>bgsave</code>，他们的区别就在于是否在「主线程」里执行：</p>
<ul>
<li>执行了 <code>save </code>命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li>
<li>执行了<code> bgsave</code> 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li>
</ul>
<p>RDB 文件的加载工作是在服务器启动时自动执行的，Redis 并没有提供专门用于加载 RDB 文件的命令。</p>
<p>Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">save</span> <span class="token number">900</span> <span class="token number">1</span> <span class="token comment"># 900 秒之内，对数据库进行了至少 1 次修改；</span>
<span class="token keyword">save</span> <span class="token number">300</span> <span class="token number">10</span> <span class="token comment"># 300 秒之内，对数据库进行了至少 10 次修改；</span>
<span class="token keyword">save</span> <span class="token number">60</span> <span class="token number">10000</span> <span class="token comment"># 60 秒之内，对数据库进行了至少 10000 次修改。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>别看选项名叫 save，实际上执行的是 bgsave 命令，也就是会创建子进程来生成 RDB 快照文件。只要满足上面条件的任意一个，就会执行 bgsave。</p>
<p>这里提一点，Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。</p>
<p>所以可以认为，执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p>
<p>通常可能设置至少 5 分钟才保存一次快照，这时如果 Redis 出现宕机等情况，则意味着最多可能丢失 5 分钟数据。</p>
<p>这就是 RDB 快照的缺点，<strong>在服务器发生故障时，丢失的数据会比 AOF 持久化的方式更多</strong>，因为 RDB 快照是全量快照的方式，因此执行的频率不能太频繁，否则会影响 Redis 性能，而 AOF 日志可以以秒级的方式记录操作命令，所以丢失的数据就相对更少。</p>
<h3 id="老大难的修改数据问题"><a href="#老大难的修改数据问题" class="headerlink" title="老大难的修改数据问题"></a>老大难的修改数据问题</h3><p>执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的。</p>
<p>那具体如何做到到呢？关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p>
<p>（还是上一篇的那个图，解释也相同</p>
<p>如果主线程（父进程）要<strong>修改共享数据里的某一块数据</strong>（比如键值对 <code>A</code>）时，就会发生写时复制，于是这块数据的<strong>物理内存就会被复制一份（键值对 <code>A'</code>）</strong>，然后<strong>主线程在这个数据副本（键值对 <code>A'</code>）进行修改操作</strong>。与此同时，<strong>bgsave 子进程可以继续把原来的数据（键值对 <code>A</code>）写入到 RDB 文件</strong>。</p>
<p>就是这样，Redis 使用 bgsave 对当前内存中的所有数据做快照，这个操作是由 bgsave 子进程在后台完成的，执行时不会阻塞主线程，这就使得主线程同时可以修改数据。</p>
<p>也就是说，<strong>发生了写时复制后，RDB 快照保存的是原本的内存数据</strong>，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。</p>
<p>所以 Redis 在使用 bgsave 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时主线程（父进程）的内存数据和子进程的内存数据已经分离了，子进程写入到 RDB 文件的内存数据只能是原本的内存数据。</p>
<p>如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。</p>
<p>另外，写时复制的时候会出现这么个极端的情况。</p>
<p>在 Redis 执行 RDB 持久化期间，刚 fork 时，主进程和子进程共享同一物理内存，但是途中主进程处理了写操作，修改了共享内存，于是当前被修改的数据的物理内存就会被复制一份。</p>
<p>那么极端情况下，<strong>如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍。</strong></p>
<p>所以，针对写操作多的场景，我们要留意下快照过程中内存的变化，防止内存被占满了。</p>
<h3 id="RDB-和-AOF-合体"><a href="#RDB-和-AOF-合体" class="headerlink" title="RDB 和 AOF 合体"></a>RDB 和 AOF 合体</h3><p>将 RDB 和 AOF 合体使用，这个方法是在 Redis 4.0 提出的，该方法叫<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化。</p>
<p>如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：</p>
<blockquote>
<p> aof-use-rdb-preamble yes</p>
</blockquote>
<p>混合持久化工作在 <strong>AOF 日志重写过程</strong>。</p>
<p>当开启了混合持久化时，在 AOF 重写日志时，<code>fork</code> 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p>
<p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p>
<p><img src="/2023/03/23/redis-rdb-kuai-zhao/f67379b60d151262753fec3b817b8617.png"></p>
<p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p>
<p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p>
<p>以上只是整理一些笔记方便日后查阅，完整来源如下：</p>
<p><a href="https://xiaolincoding.com/redis/storage/rdb.html">小林coding——图解Redis系列（持久化篇）</a></p>
]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis——SDS结构模型</title>
    <url>/2023/03/19/redis-sds/</url>
    <content><![CDATA[<h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h2><p> SDS（Simple Dynamic String，简单动态字符串）,源码底层就是<code>typedef char *sds;</code></p>
<p>Redis3.x  SDS的数据结构定义</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sdshdr</span> <span class="token punctuation">{</span>
    <span class="token comment">//记录buf数组中已使用字节的数量</span>
    <span class="token comment">//等于SDS所保存字符串的长度</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">;</span>

    <span class="token comment">//记录buf数组中未使用字节的数量</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> free<span class="token punctuation">;</span>

    <span class="token comment">//char数组，用于保存字符串</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>buf 尾部自动追加一个’\0’字符并不会计算在 SDS 的len中，这是为了遵循 C 字符串以空字符串结尾的惯例，使得 SDS 可以直接使用一部分string.h库中的函数，如strlen</p>
</blockquote>
<h2 id="2-数据优化"><a href="#2-数据优化" class="headerlink" title="2 数据优化"></a>2 数据优化</h2><h3 id="2-1-数据结构优化"><a href="#2-1-数据结构优化" class="headerlink" title="2.1 数据结构优化"></a>2.1 数据结构优化</h3><p>在 Redis3.x 版本中<strong>不同长度的字符串占用的头部是相同的</strong>，如果某一字符串很短但是头部却占用了更多的空间造成空间浪费。所以SDS 分为三种级别的字符串：<strong>共有五种类型的SDS（长度小于1字节、1字节、2字节、4字节、8字节）</strong></p>
<ul>
<li>短字符串(长度小于32)，len和free的长度用1字节即可；</li>
<li>长字符串，用2字节或者4字节；</li>
<li>超长字符串，用8字节。</li>
</ul>
<blockquote>
<p>低三位存储类型，高5位存储长度，最多能标识的长度为32，所以短字符串的长度必定小于32。</p>
<p><strong>无需free字段了，32-len即为free</strong></p>
</blockquote>
<h4 id="Redis6-x实现"><a href="#Redis6-x实现" class="headerlink" title="Redis6.x实现"></a><strong>Redis6.x</strong>实现</h4><p>注意其中flags标识字段为char类型</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 注意：sdshdr5从未被使用，Redis中只是访问flags。</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr5</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 低3位存储类型, 高5位存储长度 */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* 已使用 */</span>
    <span class="token class-name">uint8_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* 总长度，用1字节存储 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 低3位存储类型, 高5位预留 */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr16</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint16_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* 已使用 */</span>
    <span class="token class-name">uint16_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* 总长度，用2字节存储 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 低3位存储类型, 高5位预留 */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr32</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* 已使用 */</span>
    <span class="token class-name">uint32_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* 总长度，用4字节存储 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 低3位存储类型, 高5位预留 */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr64</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint64_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* 已使用 */</span>
    <span class="token class-name">uint64_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* 总长度，用8字节存储 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 低3位存储类型, 高5位预留 */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-2-uintX-t"><a href="#2-2-uintX-t" class="headerlink" title="2.2 uintX_t"></a>2.2 uintX_t</h3><p>Redis6.x 中 int 类型也多出了几种：<code>uint8_t / uint16_t / uint32_t /uint64_t</code>。</p>
<p>定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token class-name">uint8_t</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token class-name">uint16_t</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token class-name">uint32_t</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token class-name">uint64_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-3-对齐填充"><a href="#2-3-对齐填充" class="headerlink" title="2.3 对齐填充"></a>2.3 对齐填充</h3><p>现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。</p>
<p>但实际中在访问特定类型变量时经常在特定的内存地址访问，这就<strong>需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。</strong></p>
<p>对齐的原因：由于各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。最常见的是如果不按照适合其平台的要求对数据存放进行对齐，会在存取效率上带来损失。</p>
<blockquote>
<p>注：我们写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略。</p>
</blockquote>
<h5 id="Redis为什么不对齐呢？"><a href="#Redis为什么不对齐呢？" class="headerlink" title="Redis为什么不对齐呢？"></a>Redis为什么不对齐呢？</h5><p>综上所述我们知道了对齐填充可以提高 CPU 的数据读取效率，作为 IO 频繁的 <strong>Redis 为什么选择不对齐呢？</strong></p>
<p>Redis6.x 中的 SDS 结构：</p>
<p><img src="/2023/03/19/redis-sds/640-16792039812082.png"></p>
<blockquote>
<p>细节：SDS 的指针并不是指向 SDS 的起始位置（len位置），而是直接指向buf[]，使得 SDS 可以直接使用 C 语言string.h库中的某些函数，做到了兼容</p>
</blockquote>
<p>如果不进行对齐填充，那么在获取当前 SDS 的类型时则只需要后退一步即可<code>flagsPointer = ((unsigned char*)s)-1</code>；相反，若进行对齐填充，由于 Padding 的存在，我们在不同的系统中不知道退多少才能获得flags，并且我们也不能将 sds 的指针指向flags，这样就无法兼容 C 语言的函数了，也不知道前进多少才能得到 buf[]。</p>
<h2 id="3-SDS-优势"><a href="#3-SDS-优势" class="headerlink" title="3 SDS 优势"></a>3 SDS 优势</h2><h3 id="3-1-O-1-时间复杂度获取字符串长度"><a href="#3-1-O-1-时间复杂度获取字符串长度" class="headerlink" title="3.1 O(1)时间复杂度获取字符串长度"></a>3.1 O(1)时间复杂度获取字符串长度</h3><p>由于C字符串不记录自身的长度，所以为了获取一个字符串的长度程序必须遍历这个字符串，直至遇到’＼0’为止，整个操作的时间复杂度为O(N)。而我们使用SDS封装字符串则直接获取<code>len</code>属性值即可，时间复杂度为O(1)。</p>
<h3 id="3-2-二进制安全"><a href="#3-2-二进制安全" class="headerlink" title="3.2 二进制安全"></a>3.2 二进制安全</h3><p>通俗地讲，C语言中，用’\0’表示字符串的结束，如果字符串本身就有’\0’字符，字符串就会被截断，即非二进制安全；若通过某种机制，保证读写字符串时不损害其内容，则是二进制安全。</p>
<p>C字符串中的字符除了末尾字符为’\0’外其他字符不能为空字符，否则会被认为是字符串结尾(即使实际上不是)。</p>
<p>这限制了C字符串只能保存文本数据，而不能保存二进制数据。而SDS使用<code>len</code>属性的值判断字符串是否结束，所以不会受’\0’的影响。</p>
<h3 id="3-3-杜绝缓冲区溢出"><a href="#3-3-杜绝缓冲区溢出" class="headerlink" title="3.3 杜绝缓冲区溢出"></a>3.3 杜绝缓冲区溢出</h3><p>字符串的拼接操作是使用十分频繁的，在C语言开发中使用<code>char *strcat(char *dest,const char *src)</code>方法将<code>src</code>字符串中的内容拼接到<code>dest</code>字符串的末尾。由于C字符串不记录自身的长度，所有<code>strcat</code>方法已经认为用户在执行此函数时已经为<code>dest</code>分配了足够多的内存，足以容纳<code>src</code>字符串中的所有内容，而一旦这个条件不成立就会产生缓冲区溢出，会把其他数据覆盖掉。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// strcat 源码</span>
<span class="token keyword">char</span> <span class="token operator">*</span> __cdecl <span class="token function">strcat</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> src<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span> cp <span class="token operator">=</span> dst<span class="token punctuation">;</span>
 
    <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token operator">*</span>cp <span class="token punctuation">)</span>
        cp<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">/* 找到 dst 的结尾 */</span>
 
    <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token operator">*</span>cp<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">/* 无脑将 src 复制到 dst 中 */</span>
 
    <span class="token keyword">return</span><span class="token punctuation">(</span> dst <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 返回 dst */</span>
<span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>与C字符串不同，SDS 的<strong>自动扩容机制</strong>完全杜绝了发生缓冲区溢出的可能性：</p>
<p><strong>当SDS API需要对SDS进行修改时，API会先检查 SDS 的空间是否满足修改所需的要求，如果不满足，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改SDS的空间大小，也不会出现缓冲区溢出问题。</strong> </p>
<p>SDS 的<code>sds sdscat(sds s, const char *t)</code>方法在字符串拼接时会进行扩容相关操作。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">sds <span class="token function">sdscatsds</span><span class="token punctuation">(</span>sds s<span class="token punctuation">,</span> <span class="token keyword">const</span> sds t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">sdscatlen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* s: 源字符串
 * t: 待拼接字符串
 * len: 待拼接字符串长度
 */</span>
sds <span class="token function">sdscatlen</span><span class="token punctuation">(</span>sds s<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>t<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取源字符串长度</span>
    <span class="token class-name">size_t</span> curlen <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token comment">// SDS 分配空间（自动扩容机制）</span>
    s <span class="token operator">=</span> <span class="token function">sdsMakeRoomFor</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment">// 将目标字符串拷贝至源字符串末尾</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>s<span class="token operator">+</span>curlen<span class="token punctuation">,</span> t<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 更新 SDS 长度</span>
    <span class="token function">sdssetlen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> curlen<span class="token operator">+</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 追加结束符</span>
    s<span class="token punctuation">[</span>curlen<span class="token operator">+</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="自动扩容机制——sdsMakeRoomFor方法"><a href="#自动扩容机制——sdsMakeRoomFor方法" class="headerlink" title="自动扩容机制——sdsMakeRoomFor方法"></a>自动扩容机制——sdsMakeRoomFor方法</h5><p><code>strcatlen</code>中调用<code>sdsMakeRoomFor</code>完成字符串的容量检查及扩容操作，重点分析此方法：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* s: 源字符串
 * addlen: 新增长度
 */</span>
sds <span class="token function">sdsMakeRoomFor</span><span class="token punctuation">(</span>sds s<span class="token punctuation">,</span> <span class="token class-name">size_t</span> addlen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>sh<span class="token punctuation">,</span> <span class="token operator">*</span>newsh<span class="token punctuation">;</span>
    <span class="token comment">// sdsavail: s-&gt;alloc - s-&gt;len, 获取 SDS 的剩余长度</span>
    <span class="token class-name">size_t</span> avail <span class="token operator">=</span> <span class="token function">sdsavail</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> newlen<span class="token punctuation">,</span> reqlen<span class="token punctuation">;</span>
    <span class="token comment">// 根据 flags 获取 SDS 的类型 oldtype</span>
    <span class="token keyword">char</span> type<span class="token punctuation">,</span> oldtype <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> SDS_TYPE_MASK<span class="token punctuation">;</span>
    <span class="token keyword">int</span> hdrlen<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> usable<span class="token punctuation">;</span>

    <span class="token comment">/* Return ASAP if there is enough space left. */</span>
    <span class="token comment">// 剩余空间大于等于新增空间，无需扩容，直接返回源字符串</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>avail <span class="token operator">&gt;=</span> addlen<span class="token punctuation">)</span> <span class="token keyword">return</span> s<span class="token punctuation">;</span>
    <span class="token comment">// 获取当前长度</span>
    len <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// </span>
    sh <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token operator">-</span><span class="token function">sdsHdrSize</span><span class="token punctuation">(</span>oldtype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 新长度</span>
    reqlen <span class="token operator">=</span> newlen <span class="token operator">=</span> <span class="token punctuation">(</span>len<span class="token operator">+</span>addlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 断言新长度比原长度长，否则终止执行</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>newlen <span class="token operator">&gt;</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* 防止数据溢出 */</span>
    <span class="token comment">// SDS_MAX_PREALLOC = 1024*1024, 即1MB</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newlen <span class="token operator">&lt;</span> SDS_MAX_PREALLOC<span class="token punctuation">)</span>
        <span class="token comment">// 新增后长度小于 1MB ，则按新长度的两倍扩容</span>
        newlen <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token comment">// 新增后长度大于 1MB ，则按新长度加上 1MB 扩容</span>
        newlen <span class="token operator">+=</span> SDS_MAX_PREALLOC<span class="token punctuation">;</span>
    <span class="token comment">// 重新计算 SDS 的类型</span>
    type <span class="token operator">=</span> <span class="token function">sdsReqType</span><span class="token punctuation">(</span>newlen<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Don't use type 5: the user is appending to the string and type 5 is
     * not able to remember empty space, so sdsMakeRoomFor() must be called
     * at every appending operation. */</span>
    <span class="token comment">// 不使用 sdshdr5 </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> SDS_TYPE_5<span class="token punctuation">)</span> type <span class="token operator">=</span> SDS_TYPE_8<span class="token punctuation">;</span>
    <span class="token comment">// 获取新的 header 大小</span>
    hdrlen <span class="token operator">=</span> <span class="token function">sdsHdrSize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>hdrlen <span class="token operator">+</span> newlen <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;</span> reqlen<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Catch size_t overflow */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldtype<span class="token operator">==</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 类型没变</span>
        <span class="token comment">// 调用 s_realloc_usable 重新分配可用内存，返回新 SDS 的头部指针</span>
        <span class="token comment">// usable 会被设置为当前分配的大小</span>
        newsh <span class="token operator">=</span> <span class="token function">s_realloc_usable</span><span class="token punctuation">(</span>sh<span class="token punctuation">,</span> hdrlen<span class="token operator">+</span>newlen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>usable<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newsh <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 分配失败直接返回NULL</span>
        <span class="token comment">// 获取指向 buf 的指针</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>newsh<span class="token operator">+</span>hdrlen<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 类型变化导致 header 的大小也变化，需要向前移动字符串，不能使用 realloc</span>
        newsh <span class="token operator">=</span> <span class="token function">s_malloc_usable</span><span class="token punctuation">(</span>hdrlen<span class="token operator">+</span>newlen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>usable<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newsh <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token comment">// 将原字符串copy至新空间中</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>newsh<span class="token operator">+</span>hdrlen<span class="token punctuation">,</span> s<span class="token punctuation">,</span> len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 释放原字符串内存</span>
        <span class="token function">s_free</span><span class="token punctuation">(</span>sh<span class="token punctuation">)</span><span class="token punctuation">;</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>newsh<span class="token operator">+</span>hdrlen<span class="token punctuation">;</span>
        <span class="token comment">// 更新 SDS 类型</span>
        s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> type<span class="token punctuation">;</span>
        <span class="token comment">// 设置长度</span>
        <span class="token function">sdssetlen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 获取 buf 总长度(待定)</span>
    usable <span class="token operator">=</span> usable<span class="token operator">-</span>hdrlen<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>usable <span class="token operator">&gt;</span> <span class="token function">sdsTypeMaxSize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment">// 若可用空间大于当前类型支持的最大长度则截断</span>
        usable <span class="token operator">=</span> <span class="token function">sdsTypeMaxSize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置 buf 总长度</span>
    <span class="token function">sdssetalloc</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> usable<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="自动扩容机制总结："><a href="#自动扩容机制总结：" class="headerlink" title="自动扩容机制总结："></a>自动扩容机制总结：</h5><p><strong>扩容阶段：</strong></p>
<ul>
<li>若 SDS 中剩余空闲空间 avail 大于新增内容的长度 addlen，则无需扩容；</li>
<li>若 SDS 中剩余空闲空间 avail 小于或等于新增内容的长度 addlen：<ul>
<li>若新增后总长度 len+addlen &lt; 1MB，则按新长度的两倍扩容；</li>
<li>若新增后总长度 len+addlen &gt; 1MB，则按新长度加上 1MB 扩容。</li>
</ul>
</li>
</ul>
<p><strong>内存分配阶段：</strong></p>
<ul>
<li>根据扩容后的长度选择对应的 SDS 类型：<ul>
<li>若类型不变，则只需通过 <code>s_realloc_usable</code>扩大 buf 数组即可；</li>
<li>若类型变化，则需要为整个 SDS 重新分配内存，并将原来的 SDS 内容拷贝至新位置。</li>
</ul>
</li>
</ul>
<p><strong>自动扩容流程图：</strong></p>
<p><img src="/2023/03/19/redis-sds/640.png"></p>
<blockquote>
<p>扩容后的 SDS 不会恰好容纳下新增的字符，而是多分配了一些空间(预分配策略)，这减少了修改字符串时带来的内存重分配次数</p>
</blockquote>
<h5 id="根据不同的type确定对应的数据结构——sdsHdrSize方法"><a href="#根据不同的type确定对应的数据结构——sdsHdrSize方法" class="headerlink" title="根据不同的type确定对应的数据结构——sdsHdrSize方法"></a>根据不同的type确定对应的数据结构——sdsHdrSize方法</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">sdsHdrSize</span><span class="token punctuation">(</span><span class="token keyword">char</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// #define SDS_TYPE_MASK 7，二进制为0000 0111</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>type<span class="token operator">&amp;</span>SDS_TYPE_MASK<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// #define SDS_TYPE_5  0</span>
        <span class="token keyword">case</span> SDS_TYPE_5<span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sdshdr5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// #define SDS_TYPE_8  1</span>
        <span class="token keyword">case</span> SDS_TYPE_8<span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sdshdr8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// #define SDS_TYPE_16 2</span>
        <span class="token keyword">case</span> SDS_TYPE_16<span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sdshdr16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// #define SDS_TYPE_32 3</span>
        <span class="token keyword">case</span> SDS_TYPE_32<span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sdshdr32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// #define SDS_TYPE_64 4</span>
        <span class="token keyword">case</span> SDS_TYPE_64<span class="token operator">:</span>
            <span class="token keyword">return</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sdshdr64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="根据字符串长度选择对应数据结构——sdsReqType方法"><a href="#根据字符串长度选择对应数据结构——sdsReqType方法" class="headerlink" title="根据字符串长度选择对应数据结构——sdsReqType方法"></a>根据字符串长度选择对应数据结构——sdsReqType方法</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">char</span> <span class="token function">sdsReqType</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> string_size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>string_size <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span>
       <span class="token comment">// #define SDS_TYPE_5  0</span>
        <span class="token keyword">return</span> SDS_TYPE_5<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>string_size <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span>
        <span class="token comment">// #define SDS_TYPE_8  1</span>
        <span class="token keyword">return</span> SDS_TYPE_8<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>string_size <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span>
        <span class="token comment">// #define SDS_TYPE_16 2</span>
        <span class="token keyword">return</span> SDS_TYPE_16<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>LONG_MAX <span class="token operator">==</span> LLONG_MAX<span class="token punctuation">)</span></span></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>string_size <span class="token operator">&lt;</span> <span class="token number">1ll</span><span class="token operator">&lt;&lt;</span><span class="token number">32</span><span class="token punctuation">)</span>
        <span class="token comment">// #define SDS_TYPE_32 3</span>
        <span class="token keyword">return</span> SDS_TYPE_32<span class="token punctuation">;</span>
    <span class="token comment">// #define SDS_TYPE_64 4</span>
    <span class="token keyword">return</span> SDS_TYPE_64<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token keyword">return</span> SDS_TYPE_32<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过位运算<code>type&amp;SDS_TYPE_MASK</code>选择对应的数据结构，和子网划分有点相似，都是和一个MASK做位运算。</p>
<h3 id="3-4-内存重分配次数优化"><a href="#3-4-内存重分配次数优化" class="headerlink" title="3.4 内存重分配次数优化"></a>3.4 内存重分配次数优化</h3><h5 id="1-空间预分配策略"><a href="#1-空间预分配策略" class="headerlink" title="(1) 空间预分配策略"></a>(1) 空间预分配策略</h5><p>因为 SDS 的空间预分配策略， SDS 字符串在增长过程中不会频繁的进行空间分配。</p>
<p>通过这种分配策略，SDS 将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次。</p>
<h5 id="2-惰性空间释放机制"><a href="#2-惰性空间释放机制" class="headerlink" title="(2) 惰性空间释放机制"></a>(2) 惰性空间释放机制</h5><p>空间预分配策略用于优化 SDS 增长时频繁进行空间分配，而惰性空间释放机制则用于优化 SDS 字符串缩短时并不立即使用内存重分配来回收缩短后多出来的空间，而仅仅更新 SDS 的len属性，多出来的空间供将来使用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* sdstrim 方法删除字符串cset中出现的所有字符
 */</span>
sds <span class="token function">sdstrim</span><span class="token punctuation">(</span>sds s<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cset<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>start<span class="token punctuation">,</span> <span class="token operator">*</span>end<span class="token punctuation">,</span> <span class="token operator">*</span>sp<span class="token punctuation">,</span> <span class="token operator">*</span>ep<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> len<span class="token punctuation">;</span>

    sp <span class="token operator">=</span> start <span class="token operator">=</span> s<span class="token punctuation">;</span>
    ep <span class="token operator">=</span> end <span class="token operator">=</span> s<span class="token operator">+</span><span class="token function">sdslen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// strchr()函数用于查找给定字符串中某一个特定字符</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>sp <span class="token operator">&lt;=</span> end <span class="token operator">&amp;&amp;</span> <span class="token function">strchr</span><span class="token punctuation">(</span>cset<span class="token punctuation">,</span> <span class="token operator">*</span>sp<span class="token punctuation">)</span><span class="token punctuation">)</span> sp<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>ep <span class="token operator">&gt;</span> sp <span class="token operator">&amp;&amp;</span> <span class="token function">strchr</span><span class="token punctuation">(</span>cset<span class="token punctuation">,</span> <span class="token operator">*</span>ep<span class="token punctuation">)</span><span class="token punctuation">)</span> ep<span class="token operator">--</span><span class="token punctuation">;</span>
    len <span class="token operator">=</span> <span class="token punctuation">(</span>sp <span class="token operator">&gt;</span> ep<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ep<span class="token operator">-</span>sp<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> sp<span class="token punctuation">)</span> <span class="token function">memmove</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> sp<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    s<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
    <span class="token comment">// 仅仅更新了len</span>
    <span class="token function">sdssetlen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>在《Redis的设计与实现》一书中针对 sdstrim方法的讲解为：<strong>删除字符串中 cset 出现的所有字符</strong>，而不是首尾。</p>
<p>比如：调用sdstrim(“XYXaYYbcXyY”,”XY”)，后移除了所有的’X’和’Y’。这是错误❌的~</p>
</blockquote>
<p>SDS 并没有释放多出来的5字节空间，仅仅将 len 设置成了7，剩余空间为5。如果后续字符串增长时则可以派上用场（可能不需要再分配内存）。</p>
<p>也许各位又会有疑问了，<strong>这没真正释放空间，是否会导致内存泄漏呢</strong>？</p>
<p>放心，SDS为我们提供了真正释放SDS未使用空间的方法<code>sdsRemoveFreeSpace</code>。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">sds <span class="token function">sdsRemoveFreeSpace</span><span class="token punctuation">(</span>sds s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>sh<span class="token punctuation">,</span> <span class="token operator">*</span>newsh<span class="token punctuation">;</span>
    <span class="token comment">// 获取类型</span>
    <span class="token keyword">char</span> type<span class="token punctuation">,</span> oldtype <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> SDS_TYPE_MASK<span class="token punctuation">;</span>
    <span class="token comment">// 获取 header 大小</span>
    <span class="token keyword">int</span> hdrlen<span class="token punctuation">,</span> oldhdrlen <span class="token operator">=</span> <span class="token function">sdsHdrSize</span><span class="token punctuation">(</span>oldtype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取原字符串长度</span>
    <span class="token class-name">size_t</span> len <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取可用长度</span>
    <span class="token class-name">size_t</span> avail <span class="token operator">=</span> <span class="token function">sdsavail</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取指向头部的指针</span>
    sh <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token operator">-</span>oldhdrlen<span class="token punctuation">;</span>

    <span class="token comment">/* Return ASAP if there is no space left. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>avail <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> s<span class="token punctuation">;</span>

    <span class="token comment">// 查找适合这个字符串长度的最优 SDS 类型</span>
    type <span class="token operator">=</span> <span class="token function">sdsReqType</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    hdrlen <span class="token operator">=</span> <span class="token function">sdsHdrSize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* 如果类型相同，或者至少仍然需要一个足够大的类型，我们只需 realloc buf即可；
     * 否则，说明变化很大，则手动重新分配字符串以使用不同的头文件类型。
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldtype<span class="token operator">==</span>type <span class="token operator">||</span> type <span class="token operator">&gt;</span> SDS_TYPE_8<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        newsh <span class="token operator">=</span> <span class="token function">s_realloc</span><span class="token punctuation">(</span>sh<span class="token punctuation">,</span> oldhdrlen<span class="token operator">+</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newsh <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>newsh<span class="token operator">+</span>oldhdrlen<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        newsh <span class="token operator">=</span> <span class="token function">s_malloc</span><span class="token punctuation">(</span>hdrlen<span class="token operator">+</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newsh <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>newsh<span class="token operator">+</span>hdrlen<span class="token punctuation">,</span> s<span class="token punctuation">,</span> len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 释放内存</span>
        <span class="token function">s_free</span><span class="token punctuation">(</span>sh<span class="token punctuation">)</span><span class="token punctuation">;</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>newsh<span class="token operator">+</span>hdrlen<span class="token punctuation">;</span>
        s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> type<span class="token punctuation">;</span>
        <span class="token function">sdssetlen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 重新设置总长度为len</span>
    <span class="token function">sdssetalloc</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="4-SDS-最长多少？"><a href="#4-SDS-最长多少？" class="headerlink" title="4 SDS 最长多少？"></a>4 SDS 最长多少？</h2><p><strong>在 Reids3.x 版本中<code>len</code>是使用int修饰的，这就会导致 buf 最长就是<code>2147483647</code>，无形中限制了字符串的最大长度为512MB。</strong></p>
<p>在<code>_sdsnewlen</code>方法创建 SDS 中都会调用<code>sdsTypeMaxSize</code>方法获取每种类型所能创建的最大buf长度，不难发现此方法最大的返回值为<code>2147483647</code>，即512MB。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//Redis3.0.0中不存在</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token class-name">size_t</span> <span class="token function">sdsTypeMaxSize</span><span class="token punctuation">(</span><span class="token keyword">char</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> SDS_TYPE_5<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> SDS_TYPE_8<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> SDS_TYPE_16<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span>LONG_MAX <span class="token operator">==</span> LLONG_MAX<span class="token punctuation">)</span></span></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> SDS_TYPE_32<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1ll</span><span class="token operator">&lt;&lt;</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 不管方法啥意思，最大返回2147483647。OVER~</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* this is equivalent to the max SDS_TYPE_64 or SDS_TYPE_32 */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="5-部分-API-源码解读"><a href="#5-部分-API-源码解读" class="headerlink" title="5 部分 API 源码解读"></a>5 部分 API 源码解读</h2><h4 id="创建SDS"><a href="#创建SDS" class="headerlink" title="创建SDS"></a>创建SDS</h4><p>Redis 通过<code>sdsnewlen</code>方法创建 SDS。在方法中会根据字符串初始化长度选择合适的类型。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">sds <span class="token function">_sdsnewlen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>init<span class="token punctuation">,</span> <span class="token class-name">size_t</span> initlen<span class="token punctuation">,</span> <span class="token keyword">int</span> trymalloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>sh<span class="token punctuation">;</span>
    sds s<span class="token punctuation">;</span>
    <span class="token comment">// 根据初始化长度判断 SDS 的类型</span>
    <span class="token keyword">char</span> type <span class="token operator">=</span> <span class="token function">sdsReqType</span><span class="token punctuation">(</span>initlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// SDS_TYPE_5 强制转换为 SDS_TYPE_8</span>
    <span class="token comment">// 这样侧面验证了 sdshdr5 从未被使用</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> SDS_TYPE_5 <span class="token operator">&amp;&amp;</span> initlen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> type <span class="token operator">=</span> SDS_TYPE_8<span class="token punctuation">;</span>
    <span class="token comment">// 获取头部大小</span>
    <span class="token keyword">int</span> hdrlen <span class="token operator">=</span> <span class="token function">sdsHdrSize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 指向 flags 的指针</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>fp<span class="token punctuation">;</span> <span class="token comment">/* flags pointer. */</span>
    <span class="token comment">// 分配的空间</span>
    <span class="token class-name">size_t</span> usable<span class="token punctuation">;</span>
    <span class="token comment">// 防止溢出</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>initlen <span class="token operator">+</span> hdrlen <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;</span> initlen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Catch size_t overflow */</span>
    <span class="token comment">// 分配空间</span>
    <span class="token comment">// s_trymalloc_usable: 尝试分配内存，失败则返回NULL</span>
    <span class="token comment">// s_malloc_usable: 分配内存或者抛异常[不友好]</span>
    sh <span class="token operator">=</span> trymalloc<span class="token operator">?</span>
        <span class="token function">s_trymalloc_usable</span><span class="token punctuation">(</span>hdrlen<span class="token operator">+</span>initlen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>usable<span class="token punctuation">)</span> <span class="token operator">:</span>
        <span class="token function">s_malloc_usable</span><span class="token punctuation">(</span>hdrlen<span class="token operator">+</span>initlen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>usable<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sh <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>init<span class="token operator">==</span>SDS_NOINIT<span class="token punctuation">)</span>
        init <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>init<span class="token punctuation">)</span>
        <span class="token function">memset</span><span class="token punctuation">(</span>sh<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> hdrlen<span class="token operator">+</span>initlen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// s 此时指向buf</span>
    s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>sh<span class="token operator">+</span>hdrlen<span class="token punctuation">;</span>
    <span class="token comment">// 指向flags</span>
    fp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    usable <span class="token operator">=</span> usable<span class="token operator">-</span>hdrlen<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 对不同类型的 SDS 可分配空间进行截断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>usable <span class="token operator">&gt;</span> <span class="token function">sdsTypeMaxSize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span>
        usable <span class="token operator">=</span> <span class="token function">sdsTypeMaxSize</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> SDS_TYPE_5<span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token operator">*</span>fp <span class="token operator">=</span> type <span class="token operator">|</span> <span class="token punctuation">(</span>initlen <span class="token operator">&lt;&lt;</span> SDS_TYPE_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">case</span> SDS_TYPE_8<span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token function">SDS_HDR_VAR</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
            sh<span class="token operator">-&gt;</span>len <span class="token operator">=</span> initlen<span class="token punctuation">;</span>
            sh<span class="token operator">-&gt;</span>alloc <span class="token operator">=</span> usable<span class="token punctuation">;</span>
            <span class="token operator">*</span>fp <span class="token operator">=</span> type<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// ... 省略</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>initlen <span class="token operator">&amp;&amp;</span> init<span class="token punctuation">)</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> init<span class="token punctuation">,</span> initlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 末尾添加\0</span>
    s<span class="token punctuation">[</span>initlen<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过<code>sdsnewlen</code>方法我们可以获得以下信息：</p>
<ul>
<li><code>SDS_TYPE_5</code> 会被强制转换为 <code>SDS_TYPE_8</code> 类型；</li>
<li>创建时默认会在末尾加<code>'\0'</code>；</li>
<li>返回值是指向 SDS 结构中 buf 的指针；</li>
<li>返回值是<code>char *sds</code>类型，可以兼容部分C函数。</li>
</ul>
<h4 id="释放SDS"><a href="#释放SDS" class="headerlink" title="释放SDS"></a>释放SDS</h4><p>为了优化性能，SDS 提供了不直接释放内存，而是通过重置len达到清空 SDS 目的的方法——<code>sdsclear</code>。</p>
<p>改方法仅仅将 SDS 的len归零，而buf的空间并为真正被清空，新的数据可以复写，而不用重新申请内存。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sdsclear</span><span class="token punctuation">(</span>sds s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">sdssetlen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置len为0</span>
    s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span><span class="token comment">//“清空”buf</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>若真正想清空 SDS 则可以调用<code>sdsfree</code>方法，底层通过调用<code>s_free</code>释放内存。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sdsfree</span><span class="token punctuation">(</span>sds s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">s_free</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>s<span class="token operator">-</span><span class="token function">sdsHdrSize</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>







<p><a href="https://mp.weixin.qq.com/s/uYUQ1P8Dq1Cdknxif7lF-g">完整含详细解释来源</a></p>
]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>一些单例模式的对比</title>
    <url>/2023/03/20/dan-li-mo-shi-zui-hao-shi-xian-fang-shi/</url>
    <content><![CDATA[<h3 id="结论先行"><a href="#结论先行" class="headerlink" title="结论先行"></a>结论先行</h3><table>
<thead>
<tr>
<th></th>
<th>Lazy<br>初始化</th>
<th>多线程<br>安全</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>饿汉式</td>
<td>是</td>
<td>是</td>
<td>没有加锁，执行效率会提高</td>
<td>类加载时就初始化，浪费内存</td>
</tr>
<tr>
<td>懒汉式</td>
<td>否</td>
<td>是</td>
<td>第一次调用才初始化，避免内存浪费</td>
<td>必须加锁 synchronized 才能保证单例，但加锁会影响效率</td>
</tr>
<tr>
<td>双重校验锁<br>的懒汉式</td>
<td>是</td>
<td>是</td>
<td>安全且在多线程情况下能保持高性能</td>
<td>getInstance() 的性能对应用程序很关键</td>
</tr>
<tr>
<td>静态内部类</td>
<td>是</td>
<td>是</td>
<td>-达到 lazy loading 效果<br>-只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance</td>
<td>可以被反射破坏</td>
</tr>
<tr>
<td>枚举类</td>
<td>否</td>
<td>是</td>
<td>-支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化<br>-不能被反射破坏</td>
<td></td>
</tr>
</tbody></table>
<h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 饿汉式实现单例模式
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 懒汉式单例模式(线程安全)
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="双重校验锁的懒汉式"><a href="#双重校验锁的懒汉式" class="headerlink" title="双重校验锁的懒汉式"></a>双重校验锁的懒汉式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 懒汉式单例模式（同步代码块双重检查） 此处注意引用需要用volatile修饰，防止指令重排序
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton4</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 静态内部类实现单例模式
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span>  <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> <span class="token constant">INSTANCE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 枚举实现单例模式
 */</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token constant">INSTANCE</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whateverMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//方法体</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">//想要使用时</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">.</span><span class="token function">whateverMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="关于单例模式"><a href="#关于单例模式" class="headerlink" title="关于单例模式"></a>关于单例模式</h3><p>用来创建独一无二的，只有一个实例对象，是一种最简单的设计模式。</p>
<p>特点：</p>
<ul>
<li>一个类只能有一个实例</li>
<li>自己创建这个实例</li>
<li>整个系统都要使用这个实例</li>
</ul>
<p>对于有一些对象，其实例我们只需要一个，比方说：线程池、缓存（cache）、日志对象等，如果创建多个实例，就会导致许多问题产生，比如资源使用过量、程序行为不可控，或者导致不一致的结果。</p>
<p><a href="https://cloud.tencent.com/developer/article/1535893">本文部分参考</a></p>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis——AOF持久化</title>
    <url>/2023/03/22/redis-aof-chi-jiu-hua/</url>
    <content><![CDATA[<p>AOF持久化就是保存写操作命令到日志的持久化方式，<strong>只会记录写操作命令，读操作命令是不会被记录的</strong></p>
<p><img src="/2023/03/22/redis-aof-chi-jiu-hua/6f0ab40396b7fc2c15e6f4487d3a0ad7.png" alt="AOF持久化流程图"></p>
<p><img src="/2023/03/22/redis-aof-chi-jiu-hua/337021a153944fd0f964ca834e34d0f2.png"></p>
<p>先执行写操作再进行持久化</p>
<ul>
<li>优点：<ul>
<li>避免额外的检查开销（能写入到日志的内容一定可执行，恢复时一定无错）</li>
<li>不会阻塞当前写操作的执行</li>
</ul>
</li>
<li>缺点：<ul>
<li>有丢失风险</li>
<li>可能会给「下一个」命令带来阻塞风险</li>
</ul>
</li>
</ul>
<h3 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h3><img src="/2023/03/22/redis-aof-chi-jiu-hua/4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png" style="zoom: 50%;">

<ol>
<li>Redis 执行完写操作命令后，会将命令追加到 <code>server.aof_buf</code> 缓冲区；</li>
<li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li>
<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li>
</ol>
<p>Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。</p>
<p>在 <code>redis.conf</code> 配置文件中的 <code>appendfsync</code> 配置项可以有以下 3 种参数可填：</p>
<p><img src="/2023/03/22/redis-aof-chi-jiu-hua/98987d9417b2bab43087f45fc959d32a.png"></p>
<p>三种策略只是在控制 <code>fsync()</code> 函数的调用时机</p>
<h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><p>Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p>
<p>（他真的，真的很喜欢用图表达，我哭鼠，一整个爱住）</p>
<p><img src="/2023/03/22/redis-aof-chi-jiu-hua/723d6c580c05400b3841bc69566dd61b.png"></p>
<p>注意重写时，是先写到新的AOF文件再覆盖过去，否则重写过程失败会造成污染。</p>
<h3 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h3><p>写入 AOF 日志的操作虽然是在主进程完成的，因为它写入的内容不多，所以一般不太影响命令的操作。</p>
<p>但是在触发 AOF 重写时，需要读取所有缓存的键值对数据，并为每个键值对生成一条命令，然后将其写入到新的 AOF 文件，重写完后，就把现在的 AOF 文件替换掉。</p>
<p>这个过程其实是很耗时的，所以重写的操作不能放在主进程里。</p>
<p>所以，Redis 的<strong>重写 AOF 过程是由后台子进程 <em>bgrewriteaof</em> 来完成的</strong>，这么做可以达到两个好处：</p>
<ul>
<li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li>
<li>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li>
</ul>
<h4 id="父子进程之间的副本问题"><a href="#父子进程之间的副本问题" class="headerlink" title="父子进程之间的副本问题"></a>父子进程之间的副本问题</h4><p>子进程是怎么拥有主进程一样的数据副本的呢？</p>
<p>主进程在通过 <code>fork</code> 系统调用生成 bgrewriteaof 子进程时，操作系统会把主进程的「<strong>页表</strong>」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。</p>
<p><img src="/2023/03/22/redis-aof-chi-jiu-hua/5a1f2a90b5f3821c19bea3b7a5f27fa1.png"></p>
<p>这样一来，子进程就共享了父进程的物理内存数据了，这样能够<strong>节约物理内存资源</strong>，页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong>。</p>
<p>不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发<strong>写保护中断</strong>，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行<strong>物理内存的复制</strong>，并重新设置其内存映射关系，将父子进程的内存读写权限设置为<strong>可读写</strong>，最后才会对内存进行写操作，这个过程被称为「**写时复制(<em>Copy On Write</em>)**」。</p>
<p><img src="/2023/03/22/redis-aof-chi-jiu-hua/d4cfac545377b54dd035c775603b4936.png"></p>
<p>写时复制就是<strong>在发生写操作的时候，操作系统才会去复制物理内存</strong>，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。</p>
<p>当然，操作系统复制父进程页表的时候，父进程也是阻塞中的，不过页表的大小相比实际的物理内存小很多，所以通常复制页表的过程是比较快的。</p>
<p>不过，如果父进程的内存数据非常大，那自然页表也会很大，这时父进程在通过 fork 创建子进程的时候，阻塞的时间也越久。</p>
<p>所以，以下阶段会导致阻塞父进程：</p>
<ul>
<li>创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</li>
<li>创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；</li>
<li>子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后向主进程发送一条信号（异步），主进程收到该信号后，会调用一个信号处理函数，信号处理函数执行时，函数的主要功能如下：<ul>
<li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li>
<li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li>
</ul>
</li>
</ul>
<h4 id="具体的重写过程："><a href="#具体的重写过程：" class="headerlink" title="具体的重写过程："></a>具体的重写过程：</h4><p>触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。</p>
<p>但是子进程重写过程中，主进程依然可以正常处理命令。</p>
<p>如果此时<strong>主进程修改了已经存在 key-value，就会发生写时复制，注意这里只会复制主进程修改的物理内存数据，没修改物理内存还是与子进程共享的</strong>。</p>
<p>所以如果这个阶段修改的是一个 bigkey，也就是数据量比较大的 key-value 的时候，这时复制的物理内存数据的过程就会比较耗时，有阻塞主进程的风险。</p>
<h4 id="AOF-重写缓冲区"><a href="#AOF-重写缓冲区" class="headerlink" title="AOF 重写缓冲区"></a>AOF 重写缓冲区</h4><p>新的问题：重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</p>
<p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。</p>
<p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p>
<p><img src="/2023/03/22/redis-aof-chi-jiu-hua/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309231944807.png"></p>
<p>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p>
<ul>
<li>执行客户端发来的命令；</li>
<li>将执行后的写命令追加到 「AOF 缓冲区」；</li>
<li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li>
</ul>
<p>以上只是整理一些笔记方便日后查阅，完整来源如下：</p>
<p><a href="https://xiaolincoding.com/redis/storage/aof.html">小林coding——图解Redis系列（持久化篇）</a></p>
]]></content>
      <categories>
        <category>面试准备</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章、介绍introduction</title>
    <url>/2023/01/11/di-yi-zhang-ji-suan-ji-wang-luo-jie-shao/</url>
    <content><![CDATA[<h1 id="第一章、介绍introduction"><a href="#第一章、介绍introduction" class="headerlink" title="第一章、介绍introduction"></a>第一章、介绍introduction</h1><h2 id="术语terms"><a href="#术语terms" class="headerlink" title="术语terms"></a>术语terms</h2><p>TCP: Transmission Control Protocol</p>
<p>UDP: User Datagram Protocol</p>
<p>ISP: Internet Service Provider</p>
<p>LAN: Local Area Network</p>
<p>WAN: Wide Area Network</p>
<p>FDM: Frequency Division Multiplexing</p>
<p>TDM: Time Division Multiplexing</p>
<h2 id="1-1-what’s-the-Internet"><a href="#1-1-what’s-the-Internet" class="headerlink" title="1.1 what’s the Internet"></a>1.1 what’s the Internet</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>连通性connected和共享性sharing，是基本功能<br>计算机网络：一般地说，将分散的多台计算机、终端和外部设备用通信线路互联起来，彼此间实现互相通信，并且计算机的硬件、软件和数据资源大家都可以共同使用，实现资源共享的整个系统就叫做计算机网络。</p>
<p>计算机网络连接两台或多台自主计算机。<br>计算机可以位于地理位置上的任何位置。<br>如果两台计算机能够交换信息，则称它们相互连接。<br>网络有多种规模size、形状shape和形式form。</p>
<p>自动计算机Autonomous computer 由软件和硬件组成，可以独立实现各种功能。<br>与通信模型和接口互连。<br>计算机网络连接在一起，组成更大的网络。<br>互联网：网络网络中最广为人知的例子。</p>
<ul>
<li><p>Hardware</p>
<ul>
<li>End Systems终端: Host, PC, Mainframe(大型机), Client, Workstation, Server</li>
<li>Intermediate Systems中间系统: Communications: Switch, Router</li>
<li>Interface接口: Network interface card(NIC), Modem</li>
<li>Medium: Twisted pair, Coaxial cable, Fiber, Wireless</li>
</ul>
</li>
<li><p>Software</p>
<ul>
<li>Protocol: CSMA/CD, TCP/IP, UDP, PPP, ATM </li>
<li>Applications: HTTP, SMTP, FTP, Telnet</li>
</ul>
</li>
</ul>
<h3 id="Applications-of-Networks"><a href="#Applications-of-Networks" class="headerlink" title="Applications of Networks"></a>Applications of Networks</h3><ul>
<li><p>Resource Sharing</p>
<ul>
<li>Hardware (computing resources, disks, printers)</li>
<li>Software (application software)</li>
</ul>
</li>
<li><p>Information Sharing</p>
<ul>
<li>Easy accessibility from anywhere (files, databases)</li>
<li>Search Capability (WWW)</li>
</ul>
</li>
<li><p>Communication</p>
<ul>
<li>Email</li>
<li>Message broadcast</li>
</ul>
</li>
<li><p>Ubiquitous computing(普适计算)</p>
</li>
<li><p>Mobile Users</p>
<ul>
<li>802.11 hotspot, 3G and 4G, wearable computer</li>
</ul>
</li>
</ul>
<h3 id="Category-of-Computer-Networks分类"><a href="#Category-of-Computer-Networks分类" class="headerlink" title="Category of Computer Networks分类"></a>Category of Computer Networks分类</h3><ul>
<li><p>Classified by Topology根据拓扑结构分类</p>
<ul>
<li><p>Bus Topology总线拓扑</p>
<ul>
<li>通常称为线性总线，总线拓扑上的所有设备都通过一根电缆连接。</li>
</ul>
</li>
<li><p>Star &amp; Tree Topology星形或树形拓扑</p>
<ul>
<li>星形拓扑是Enternet LAN 中最常用的架构。</li>
<li>安装后，星形拓扑类似于自行车车轮中的辐条spokes。</li>
<li>较大的网络使用扩展的星形拓扑，也称为树形拓扑。当与筛选帧或数据包的网络设备（如网桥、交换机和路由器）一起使用时，此拓扑仅将数据包发送到目标主机的线路，从而显著减少线路上的流量。</li>
</ul>
</li>
<li><p>Ring Topology环形拓扑</p>
<ul>
<li><p>帧围绕环行进，在每个节点处停止。如果节点想要传输数据，它会将数据以及目标地址添加到帧中。</p>
</li>
<li><p>然后，帧继续围绕环，直到找到目标节点，这会将数据从帧中取出。</p>
<ul>
<li>单环 – 网络上的所有设备共享一根电缆</li>
<li>双环 – 双环拓扑允许数据在两个方向上发送。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Classified by scale根据规模进行分类</p>
<ul>
<li><p>LAN(MAN)</p>
<ul>
<li>在小地理small geographic区域内共享公共通信线路或无线链路的计算机和相关设备。</li>
</ul>
</li>
<li><p>WAN</p>
<ul>
<li>广域网 （WAN） 是地理位置分散的电信网络。该术语将更广泛的电信结构与局域网（LAN）区分开来。</li>
</ul>
</li>
<li><p>Internet</p>
<ul>
<li>一个全球性的计算机网络系统 - 一个网络网络，其中任何一台计算机的用户都可以在获得许可的情况下，从任何其他计算机获取信息，甚至可以使用远程计算机。</li>
</ul>
</li>
</ul>
</li>
<li><p>Classified by boundary按边界分类</p>
<ul>
<li><p>Intranet （Private Networks）内网（专用网络）</p>
<ul>
<li>内部网是包含在企业中的专用网络。它可以由许多相互连接的局域网组成，也可以在广域网中使用租用线路。</li>
</ul>
</li>
<li><p>Extranet （Public Networks）外联网（公共网络）</p>
<ul>
<li>外联网是一种专用网络，它使用互联网技术和公共电信系统与供应商、销售商、合作伙伴、客户或其他企业安全地共享部分企业信息或运营。可以将 Extranet 视为公司 Intranet 的一部分，该 Intranet 扩展到公司外部的用户。它也被描述为一种“心态”，在这种状态下，互联网被视为与其他公司开展业务以及向客户销售产品的一种方式。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="What’s-the-Internet"><a href="#What’s-the-Internet" class="headerlink" title="What’s the Internet?"></a>What’s the Internet?</h3><ul>
<li><p>“nuts and bolts” view</p>
<ul>
<li><p>数十亿计的，互联的计算设备：主机 = 终端系统hosts = end systems </p>
<ul>
<li>运行网络应用network apps</li>
</ul>
</li>
<li><p>通信链接communication links</p>
<ul>
<li>光纤fiber、铜缆copper、无线电radio、卫星satellite</li>
<li>传输速率 = 带宽bandwidth(bps)</li>
</ul>
</li>
<li><p>路由器routers：转发数据包（数据块chunks of data）</p>
</li>
<li><p>nuts and bolts螺母和螺栓</p>
<p>通信链路：同轴电缆、铜线、光纤、无线电频谱，不同速率传输数据。传输速率bps。</p>
<p>分组交换机：路由器和链路层交换机。向目的地转发分组。分组经历的通信链路和分组交换机成为路径。承载运输车辆的运输网络，一堆货物，首先分成几份，装车。桥和路口可以看做是分组交换机，路牌可以看做转发表，目的地卸下货物，重新堆放在一起。</p>
<ul>
<li><p>协议控制消息的发送、接收</p>
<ul>
<li>例如，TCP，IP，HTTP，FTP，PPP</li>
</ul>
</li>
<li><p>互联网：“网络中的网络”</p>
<ul>
<li>松散的层次结构loosely hierarchical</li>
<li>公共互联网public Internet与私有内联网private intranet</li>
</ul>
</li>
<li><p>互联网标准</p>
<ul>
<li>RFC：征求意见</li>
<li>IETF：互联网工程任务组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="network-structure网络结构："><a href="#network-structure网络结构：" class="headerlink" title="network structure网络结构："></a>network structure网络结构：</h3><ul>
<li><p>network edge网络边缘：应用程序和主机</p>
</li>
<li><p>access networks, physical media接入网、物理介质：有线、无线通信链路</p>
</li>
<li><p>network core网络核心: </p>
<ul>
<li>interconnected 互连路由器</li>
<li>网络中的网络</li>
</ul>
</li>
</ul>
<h3 id="What’s-the-Internet-a-service-view"><a href="#What’s-the-Internet-a-service-view" class="headerlink" title="What’s the Internet: a service view"></a>What’s the Internet: a service view</h3><ul>
<li><p>通信基础(communication infrastructure)设施支持分布式应用程序：</p>
<ul>
<li>网络、电子邮件、游戏、电子商务(e-commerce)、文件共享</li>
</ul>
</li>
<li><p>提供给应用程序的通信服务communication services provided to apps:</p>
<ul>
<li>无连接不可靠</li>
<li>面向连接可靠</li>
</ul>
</li>
</ul>
<h2 id="1-2-what’s-aprotocol"><a href="#1-2-what’s-aprotocol" class="headerlink" title="1.2 what’s aprotocol"></a>1.2 what’s aprotocol</h2><h3 id="协议定义网络实体之间发送和接收的msgs的格式，顺序，以及对msg传输，接收执行的操作"><a href="#协议定义网络实体之间发送和接收的msgs的格式，顺序，以及对msg传输，接收执行的操作" class="headerlink" title="协议定义网络实体之间发送和接收的msgs的格式，顺序，以及对msg传输，接收执行的操作"></a>协议定义网络实体之间发送和接收的msgs的格式，顺序，以及对msg传输，接收执行的操作</h3><h3 id="protocols-define-format-order-of-msgs-sent-and-received-among-network-entities-and-actions-taken-on-msg-transmission-receipt"><a href="#protocols-define-format-order-of-msgs-sent-and-received-among-network-entities-and-actions-taken-on-msg-transmission-receipt" class="headerlink" title="protocols define format, order of msgs sent and received among network entities, and actions taken on msg transmission, receipt"></a>protocols define format, order of msgs sent and received among network entities, and actions taken on msg transmission, receipt</h3><h2 id="1-3-network-edge"><a href="#1-3-network-edge" class="headerlink" title="1.3 network edge"></a>1.3 network edge</h2><h3 id="端系统（主机）："><a href="#端系统（主机）：" class="headerlink" title="端系统（主机）："></a>端系统（主机）：</h3><ul>
<li><p>运行应用程序</p>
<ul>
<li>如Web、email</li>
</ul>
</li>
<li><p>在 “网络的边缘”</p>
</li>
</ul>
<h3 id="客户-x2F-服务器模式client-x2F-server-model"><a href="#客户-x2F-服务器模式client-x2F-server-model" class="headerlink" title="客户/服务器模式client/server model"></a>客户/服务器模式client/server model</h3><ul>
<li>客户端向服务器请求、接收服务</li>
<li>如Web浏览器/服务器；email客户端/服务器</li>
</ul>
<h3 id="对等（peer-peer-）模式"><a href="#对等（peer-peer-）模式" class="headerlink" title="对等（peer-peer ）模式"></a>对等（peer-peer ）模式</h3><ul>
<li>很少（甚至没有）专门的dedicated服务器</li>
<li>如 Gnutella、KaZaA、Emule</li>
</ul>
<h3 id="面向连接的服务connection-oriented-service"><a href="#面向连接的服务connection-oriented-service" class="headerlink" title="面向连接的服务connection-oriented service"></a>面向连接的服务connection-oriented service</h3><ul>
<li><p>端点上的设备使用协议在发送任何数据之前建立端到端的逻辑或物理连接。面向连接的协议在以下三个步骤或过程中提供服务：握手Handshaking、数据传输Data Transfer、连接终止Connection Termination。</p>
</li>
<li><p>目标：终端系统之间的数据传输</p>
</li>
<li><p>握手：提前设置（准备）数据传输</p>
<ul>
<li>在两个通信主机中设置“状态”</li>
</ul>
</li>
<li><p>TCP - Transmission Control Protocol 传输控制协议</p>
<ul>
<li>互联网的连接导向型服务</li>
</ul>
</li>
<li><p>TCP 服务 [RFC 793]</p>
<ul>
<li><p>可靠、有序的字节流数据传输</p>
<ul>
<li>丢失：确认acknowledgements和转播retransmissions</li>
</ul>
</li>
</ul>
</li>
<li><p>flow control（流控制） </p>
<ul>
<li>发送方不会压倒overwhelm接收方</li>
</ul>
</li>
<li><p>congestion control: （拥塞控制）</p>
<ul>
<li>发件人在网络拥塞时“降低发送速率”</li>
</ul>
</li>
<li><p>应用程序</p>
<ul>
<li>HTTP (Web), FTP (file transfer), Telnet (remote login), SMTP (email)</li>
</ul>
</li>
</ul>
<h3 id="无连接服务connectionless-service"><a href="#无连接服务connectionless-service" class="headerlink" title="无连接服务connectionless service"></a>无连接服务connectionless service</h3><ul>
<li><p>一种服务，其中不需要在设备之间建立连接来传输数据。<br>每当设备有要发送的数据时，它就会将数据发送到另一个设备。<br>此服务不提供可靠的接送服务。</p>
</li>
<li><p>目标：终端系统之间的数据传输</p>
</li>
<li><p>UDP - User Datagram Protocol 用户数据报协议 [RFC 768]：</p>
<ul>
<li>无连接</li>
<li>不可靠的数据传输</li>
<li>无流量控制</li>
<li>无拥塞控制</li>
</ul>
</li>
<li><p>应用程序</p>
<ul>
<li>streaming media, teleconferencing, DNS, Internet telephony<br>QQ</li>
</ul>
</li>
</ul>
<h2 id="1-4-network-core"><a href="#1-4-network-core" class="headerlink" title="1.4 network core"></a>1.4 network core</h2><h3 id="network-structure"><a href="#network-structure" class="headerlink" title="network structure"></a>network structure</h3><h3 id="路由器的网状网络Mesh"><a href="#路由器的网状网络Mesh" class="headerlink" title="路由器的网状网络Mesh"></a>路由器的网状网络Mesh</h3><h3 id="基本问题：数据如何通过网络传输？"><a href="#基本问题：数据如何通过网络传输？" class="headerlink" title="基本问题：数据如何通过网络传输？"></a>基本问题：数据如何通过网络传输？</h3><ul>
<li><p>电路交换circuit switching：</p>
<ul>
<li>每次呼叫专用电路：电话网</li>
</ul>
</li>
<li><p>分组交换packet-switching：</p>
<ul>
<li>通过网络以离散(discrete)“块chunks”形式发送的数据</li>
</ul>
</li>
</ul>
<h3 id="端到端的资源被分配给从源端"><a href="#端到端的资源被分配给从源端" class="headerlink" title="端到端的资源被分配给从源端"></a>端到端的资源被分配给从源端</h3><p>到目标端的呼叫 “call”：</p>
<h3 id="circuit-switching电路交换"><a href="#circuit-switching电路交换" class="headerlink" title="circuit switching电路交换"></a>circuit switching电路交换</h3><ul>
<li><p>链路带宽、交换机容量</p>
</li>
<li><p>专用dedicated资源：无共享</p>
</li>
<li><p>类似电路（保证）的性能</p>
</li>
<li><p>需要呼叫设置</p>
</li>
<li><p>面向连接的服务</p>
</li>
<li><p>电路保证信道的全部带宽，并在通信会话期间保持连接</p>
</li>
<li><p>网络资源（例如带宽）分为“pieces”</p>
<ul>
<li><p>pieces被分配给调用</p>
</li>
<li><p>frequency division频分</p>
<ul>
<li>FDM</li>
</ul>
</li>
<li><p>time division时分</p>
<ul>
<li>TDM</li>
</ul>
</li>
<li><p>code division代码划分</p>
<ul>
<li>CDMA</li>
</ul>
</li>
<li><p>计算的例子：P53、54</p>
</li>
</ul>
</li>
<li><p>资源段空闲idle，如果未由拥有调用使用（无共享）</p>
</li>
<li><p>电路交换不适合计算机之间的通信</p>
<ul>
<li>连接建立时间长</li>
<li>计算机之间的通信有突发性，如果使用线路交换，则浪费的片较多 </li>
<li>即使这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用</li>
</ul>
</li>
</ul>
<h3 id="Packet-switching分组交换"><a href="#Packet-switching分组交换" class="headerlink" title="Packet switching分组交换"></a>Packet switching分组交换</h3><ul>
<li><p>每个端到端数据流划分为数据包</p>
<ul>
<li>用户 A、B 数据包共享网络资源</li>
<li>每个数据包使用全链路带宽</li>
<li>根据需要使用的资源</li>
</ul>
</li>
<li><p>资源争用：</p>
<ul>
<li><p>资源需求总量可能超过可用量</p>
</li>
<li><p>拥塞：数据包队列，等待链路使用</p>
</li>
<li><p>存储和转发：数据包一次移动一个跃点hop</p>
<ul>
<li>节点在转发之前接收完整的数据包</li>
</ul>
</li>
</ul>
</li>
<li><p>Statistical Multiplexing统计多路复用</p>
<ul>
<li>A和B数据包的序列没有固定的模式，按需共享统计多路复用。</li>
<li>TDM：每个主机在旋转TDM帧中获得相同的时间间隔slot。</li>
<li>为了提高TDM系统的利用率,可以使用按需分配的技术,即根据用户需求动态分配时隙,以避免每帧中出现空闲的时隙.此时复用器传输的数据只来自正在工作的设备,这种动态分配时隙的工作方式称为统计时分复用(Statistical Time Division Multiplexing,STDM).</li>
</ul>
</li>
<li><p>store-and-forward存储转发</p>
<ul>
<li>被传输到下一个链路之前，整个分组必须到达路由器：存储-转发</li>
<li>在一个速率为R bps的链路，一个长度为L bits 的分组的存储转发延时： L/R s（此处忽略）</li>
</ul>
</li>
<li><p>forwarding转发</p>
<ul>
<li><p>目标：通过路由器将数据包从源移动到目标</p>
</li>
<li><p>数据报网络datagram network：</p>
<ul>
<li>数据包中的目标地址确定下一跃点</li>
<li>路由在会话期间可能会更改</li>
</ul>
</li>
<li><p>虚拟电路网络virtual circuit network：</p>
<ul>
<li>每个数据包携带标签（虚拟电路ID），标签tag决定下一跃点hop</li>
<li>在呼叫建立时确定的固定路径，通过呼叫保持固定</li>
<li>路由器维护每个呼叫状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分组交换与电路交换对比"><a href="#分组交换与电路交换对比" class="headerlink" title="分组交换与电路交换对比"></a>分组交换与电路交换对比</h3><ul>
<li><p>分组交换没有：</p>
<ul>
<li>带宽划分为“块”</li>
<li>专用分配</li>
<li>资源预留</li>
</ul>
</li>
<li><p>分组交换让更多用户使用网络</p>
</li>
<li><p>分组交换非常适合突发数据</p>
<ul>
<li>资源共享</li>
<li>更简单，无需呼叫设置</li>
</ul>
</li>
<li><p>分组交换过度拥塞：数据包延迟和丢失</p>
<ul>
<li>可靠数据传输、拥塞控制所需的协议</li>
</ul>
</li>
</ul>
<h3 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h3><p>数据报网络既不面向连接 或无连接。<br>互联网提供面向连接的（TCP）和 到应用的无连接服务 （UDP）。</p>
<p>- </p>
<h2 id="1-5-access-net-physical-media接入网络和物理媒体"><a href="#1-5-access-net-physical-media接入网络和物理媒体" class="headerlink" title="1.5 access net, physical media接入网络和物理媒体"></a>1.5 access net, physical media接入网络和物理媒体</h2><h3 id="怎样将端系统和边缘路由器连接？"><a href="#怎样将端系统和边缘路由器连接？" class="headerlink" title="怎样将端系统和边缘路由器连接？"></a>怎样将端系统和边缘路由器连接？</h3><ul>
<li><p>residential access nets住宅接入网络</p>
<ul>
<li><p>point to point access</p>
<ul>
<li>拨号调制解调器Dialup via modem</li>
<li>高达 56Kbps 的直接访问路由器（通常更少）</li>
<li>不能同时上网和打电话：不能“始终在线”</li>
</ul>
</li>
<li><p>非对称数字用户专线Asymmetric Digital Subscriber Line（ADSL）</p>
</li>
<li><p>cable modems电缆调制解调器</p>
<ul>
<li>光纤将电缆头端连接到邻域级结点。</li>
<li>然后使用传统的同轴电缆到达单独的房屋和公寓。</li>
</ul>
</li>
<li><p>Cable Network Architecture有线网络架构</p>
<ul>
<li><p>HFC：混合光纤同轴电缆</p>
<ul>
<li>非对称：高达30Mbps的下行传输速率，2 Mbps的上行传输速率</li>
</ul>
</li>
<li><p>电缆网络，光纤将家庭连接到ISP路由器</p>
<ul>
<li>家庭共享接入网络到电缆头端</li>
<li>与DSL不同，DSL具有对中央办公室的专用访问权限</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>institutional access networks (school, company)单位接入网络</p>
<ul>
<li><p>企业接入网络(Ethernet)</p>
<ul>
<li>经常被企业或者大学等机构采用</li>
<li>10 Mbps, 100Mbps, 1Gbps, 10Gbps传输率</li>
<li>现在，端系统经常直接接到以太网络交换机上</li>
</ul>
</li>
</ul>
</li>
<li><p>mobile access networks无线接入网络</p>
<ul>
<li><p>各无线端系统共享无线接入网络（端系统到无线路由器）</p>
<ul>
<li>通过基站或者叫接入点</li>
</ul>
</li>
<li><p>无线LANs:</p>
<ul>
<li>建筑物内部 (100 ft) </li>
<li>802.11b/g (WiFi): 11, 54Mbps 传输速率</li>
</ul>
</li>
<li><p>广域无线接入</p>
<ul>
<li>由电信运营商提供 (cellular) ,10’s km</li>
<li>1 到 10 Mbps</li>
<li>3G, 4G: LTE</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Physical-Media物理媒体"><a href="#Physical-Media物理媒体" class="headerlink" title="Physical Media物理媒体"></a>Physical Media物理媒体</h3><ul>
<li><p>Bit: 在发送-接收对间传播</p>
</li>
<li><p>物理链路：连接每个发送-接收对之间的物理媒体</p>
</li>
<li><p>导引型媒体: </p>
<ul>
<li>信号沿着固体媒介被导引：同轴电缆、光纤、 双绞线</li>
</ul>
</li>
<li><p>非导引型媒体：</p>
<ul>
<li>开放的空间传输电磁波或者光信号，在电磁或者光信号中承载数字数据</li>
</ul>
</li>
<li><p>Twisted Pair 双绞线 (TP)<br>P83-90</p>
<ul>
<li>两根绝缘铜导线拧合</li>
<li>3类：传统电话线，10 Mbps以太网</li>
<li>5类：100Mbps 以太网，Gbps 千兆位以太网</li>
<li>6类：10Gbps万兆以太网</li>
</ul>
</li>
<li><p>同轴电缆Coaxial cable：</p>
<ul>
<li><p>两根同轴concentric的铜copper导线conductors</p>
</li>
<li><p>双向bidirectional</p>
</li>
<li><p>基带baseband：</p>
<ul>
<li>电缆上一个单个信道</li>
<li>Ethernet</li>
</ul>
</li>
<li><p>宽带broadband：</p>
<ul>
<li>电缆上有多个信道</li>
<li>HFC</li>
</ul>
</li>
</ul>
</li>
<li><p>光纤和光缆Fiber optic cable：</p>
<ul>
<li><p>光脉冲，每个脉冲表示一个bit，在玻璃纤维中传输</p>
</li>
<li><p>高速：</p>
<ul>
<li>点到点的高速传输（如10 Gps-100Gbps传输速率 ）</li>
</ul>
</li>
<li><p>低误码率：在两个中继器之间可以有很长的距离，不受电磁噪声的干扰 </p>
</li>
<li><p>安全</p>
</li>
</ul>
</li>
<li><p>无线链路radio</p>
<ul>
<li><p>开放空间传输电磁波，携带要传输的数据</p>
</li>
<li><p>无需物理“线缆”</p>
</li>
<li><p>双向</p>
</li>
<li><p>传播环境效应：</p>
<ul>
<li>反射reflection </li>
<li>吸收Obstruction by objects</li>
<li>干扰Interference</li>
</ul>
</li>
<li><p>无线链路类型:</p>
<ul>
<li>terrestrial  microwave地面微波</li>
<li>LAN (e.g., WiFi)</li>
<li>wide-area (e.g., 蜂窝)</li>
<li>卫星satellite</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-6-Internet-x2F-ISP-structure"><a href="#1-6-Internet-x2F-ISP-structure" class="headerlink" title="1.6 Internet/ ISP structure"></a>1.6 Internet/ ISP structure</h2><h3 id="Internet-structure-network-of-networks"><a href="#Internet-structure-network-of-networks" class="headerlink" title="Internet structure: network of networks"></a>Internet structure: network of networks</h3><ul>
<li><p>大致分层</p>
</li>
<li><p>在中心：“Tier-1”ISP（例如，MCI，Sprint，AT&amp;T，Cable and Wireless），全国national/国际international覆盖coverage</p>
<ul>
<li>平等相待</li>
</ul>
</li>
<li><p>“Tier-2”ISP：较小的（通常是区域性的）ISP</p>
<ul>
<li>连接到一个或多个第 1 层 ISP，可能还有其他第 2 层 ISP</li>
</ul>
</li>
<li><p>“Tier-3”ISP 和本地 ISP</p>
<ul>
<li>最后一跳（“访问”）网络（最接近终端系统）</li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<h2 id="1-7-Delay-amp-loss-in-packet-switched-networks分组延时、丢失和吞吐量"><a href="#1-7-Delay-amp-loss-in-packet-switched-networks分组延时、丢失和吞吐量" class="headerlink" title="1.7 Delay &amp; loss in packet-switched networks分组延时、丢失和吞吐量"></a>1.7 Delay &amp; loss in packet-switched networks分组延时、丢失和吞吐量</h2><h3 id="计算机网络性能Performance-of-Computer-network"><a href="#计算机网络性能Performance-of-Computer-network" class="headerlink" title="计算机网络性能Performance of Computer network"></a>计算机网络性能Performance of Computer network</h3><ul>
<li><p>Data rate(数据率)：计算机网络上的主机在数字信道上的传送数据的速率。</p>
<ul>
<li>100M Ethernet</li>
</ul>
</li>
<li><p>Bandwidth(带宽）</p>
<ul>
<li>Frequency</li>
<li>Transmission rate</li>
</ul>
</li>
<li><p>Throughput(吞吐量)</p>
<ul>
<li>rate (bits/time unit) at which bits transferred between sender/receiver</li>
<li>Restricted by rated speed(额定速率)</li>
</ul>
</li>
</ul>
<h3 id="Communication-channel沟通频道"><a href="#Communication-channel沟通频道" class="headerlink" title="Communication channel沟通频道"></a>Communication channel沟通频道</h3><ul>
<li><p>连接到物理传输介质（如导线），或连接到多路复用介质（如无线电信道）上的逻辑连接。</p>
<ul>
<li>将信息信号从一个或多个发送器（或发射器）传送到一个或多个接收器</li>
<li>传输信息的能力 - 以Hz为单位的带宽或其以比特/秒为单位的数据速率</li>
</ul>
</li>
<li><p>单向通信One-way communication：</p>
<ul>
<li>从一个点传输到另一个点或同时传输到多个点。</li>
<li>在发送点不接收信息，也不从接收点传输信息。</li>
</ul>
</li>
<li><p>半双工Half-duplex</p>
<ul>
<li>双向沟通，但一次只能沟通一个方向</li>
</ul>
</li>
<li><p>全双工Full-duplex</p>
<ul>
<li>允许双向通信</li>
</ul>
</li>
</ul>
<h3 id="丢失和时延发生原因：数据包在路由器缓冲区中排队"><a href="#丢失和时延发生原因：数据包在路由器缓冲区中排队" class="headerlink" title="丢失和时延发生原因：数据包在路由器缓冲区中排队"></a>丢失和时延发生原因：数据包在路由器缓冲区中排队</h3><ul>
<li>链路的数据包到达率超过输出链路容量</li>
<li>数据包队列，等待轮次</li>
</ul>
<h3 id="delay时延"><a href="#delay时延" class="headerlink" title="delay时延"></a>delay时延</h3><ul>
<li><p>四个分组时延的来源</p>
<ul>
<li><p>nodal processing节点处理延时：</p>
<ul>
<li>检查 bit级差错</li>
<li>检查分组首部和决定将分组导向何处</li>
</ul>
</li>
<li><p>queueing排队延时</p>
<ul>
<li>在输出链路上等待传输的时间</li>
<li>依赖于路由器的拥塞程度</li>
</ul>
</li>
<li><p>Transmission传输延时</p>
<ul>
<li>R=链路带宽(bps)</li>
<li>L=分组长度(bits)</li>
<li>将分组发送到链路上的时间= L/R</li>
</ul>
</li>
<li><p>Propagation传播延时:</p>
<ul>
<li>d = 物理链路的长度</li>
<li>s = 在媒体上的传播速度(~2x108 m/sec)</li>
<li>传播延时 = d/s</li>
</ul>
</li>
<li><ul>
<li>一个栗子：P110</li>
</ul>
</li>
<li><p>节点延时计算：</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p>Queueing delay(revisited)排队延时</p>
<p>R=link bandwidth (bps)<br>L=packet length (bits)<br>a=average packet arrival rate </p>
<p>traffic intensity = La/R</p>
<p>La/R ~ 0: average queueing delay small<br>La/R -&gt; 1: delays become large<br>La/R &gt; 1: more “work” arriving than can be serviced, average delay infinite! </p>
</li>
<li><p>Internet的延时和路由</p>
<ul>
<li><p>Internet 的延时和路由是什么样的呢?</p>
</li>
<li><p>Traceroute program诊断程序: 提供从源端，经过路由器，到目的的延时测量</p>
<ul>
<li>For all i:<br>沿着目的的路径，向每个路由器发送3个探测分组<br> 路由器 i 将向发送方返回一个分组<br> 发送方对发送和回复之间间隔计时</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分组丢失loss"><a href="#分组丢失loss" class="headerlink" title="分组丢失loss"></a>分组丢失loss</h3><ul>
<li>链路的队列缓冲区容量有限</li>
<li>当分组到达一个满的队列时，该分组将会丢失</li>
<li>丢失的分组可能会被前一个节点或源端系统重传，或根本不重传</li>
<li>吞吐量Throughput</li>
</ul>
<h2 id="1-8-Protocol-layers-service-models"><a href="#1-8-Protocol-layers-service-models" class="headerlink" title="1.8 Protocol layers, service models"></a>1.8 Protocol layers, service models</h2><h2 id="1-9-Network-Security"><a href="#1-9-Network-Security" class="headerlink" title="1.9 Network Security"></a>1.9 Network Security</h2><p>​	因为知识点很多，这部分的笔记最开始是用思维导图记的，但是图片都不能导出，xmind格式的到<a href="https://pan.baidu.com/s/1UUYss9XOIEMDWFRIlwcjgw?pwd=tuw7">百度网盘</a>自行下载或者联系我私发叭，笔记效果如下（也不是那么好看，建议还是看PPT或者自己整理效率较高，我的笔记整理效果稍稍欠缺）：</p>

<div class="markmap-container" style="height:800px">
  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;第一章、介绍introduction&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;术语terms&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;1.1 what’s the Internet&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;定义：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;Hardware&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;End Systems终端: Host, PC, Mainframe(大型机), Client, Workstation, Server&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;Intermediate Systems中间系统: Communications: Switch, Router&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;Interface接口: Network interface card(NIC), Modem&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;Medium: Twisted pair, Coaxial cable, Fiber, Wireless&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;Software&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;Protocol: CSMA/CD, TCP/IP, UDP, PPP, ATM&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;Applications: HTTP, SMTP, FTP, Telnet&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;Applications of Networks&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;Resource Sharing&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;Hardware (computing resources, disks, printers)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;Software (application software)&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;Information Sharing&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;Easy accessibility from anywhere (files, databases)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;Search Capability (WWW)&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;Communication&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;Email&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;Message broadcast&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;Ubiquitous computing(普适计算)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;Mobile Users&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;802.11 hotspot, 3G and 4G, wearable computer&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;Category of Computer Networks分类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;Classified by Topology根据拓扑结构分类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;Bus Topology总线拓扑&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;通常称为线性总线，总线拓扑上的所有设备都通过一根电缆连接。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;Star &amp;amp; Tree Topology星形或树形拓扑&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;星形拓扑是Enternet LAN 中最常用的架构。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;安装后，星形拓扑类似于自行车车轮中的辐条spokes。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;较大的网络使用扩展的星形拓扑，也称为树形拓扑。当与筛选帧或数据包的网络设备（如网桥、交换机和路由器）一起使用时，此拓扑仅将数据包发送到目标主机的线路，从而显著减少线路上的流量。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;Ring Topology环形拓扑&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[87,88]},&quot;v&quot;:&quot;帧围绕环行进，在每个节点处停止。如果节点想要传输数据，它会将数据以及目标地址添加到帧中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;然后，帧继续围绕环，直到找到目标节点，这会将数据从帧中取出。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[90,91]},&quot;v&quot;:&quot;单环 – 网络上的所有设备共享一根电缆&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[91,92]},&quot;v&quot;:&quot;双环 – 双环拓扑允许数据在两个方向上发送。&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;Classified by scale根据规模进行分类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;LAN(MAN)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[97,98]},&quot;v&quot;:&quot;在小地理small geographic区域内共享公共通信线路或无线链路的计算机和相关设备。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[99,100]},&quot;v&quot;:&quot;WAN&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[101,102]},&quot;v&quot;:&quot;广域网 （WAN） 是地理位置分散的电信网络。该术语将更广泛的电信结构与局域网（LAN）区分开来。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[103,104]},&quot;v&quot;:&quot;Internet&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[105,106]},&quot;v&quot;:&quot;一个全球性的计算机网络系统 - 一个网络网络，其中任何一台计算机的用户都可以在获得许可的情况下，从任何其他计算机获取信息，甚至可以使用远程计算机。&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[107,108]},&quot;v&quot;:&quot;Classified by boundary按边界分类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[109,110]},&quot;v&quot;:&quot;Intranet （Private Networks）内网（专用网络）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[111,112]},&quot;v&quot;:&quot;内部网是包含在企业中的专用网络。它可以由许多相互连接的局域网组成，也可以在广域网中使用租用线路。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[113,114]},&quot;v&quot;:&quot;Extranet （Public Networks）外联网（公共网络）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[115,116]},&quot;v&quot;:&quot;外联网是一种专用网络，它使用互联网技术和公共电信系统与供应商、销售商、合作伙伴、客户或其他企业安全地共享部分企业信息或运营。可以将 Extranet 视为公司 Intranet 的一部分，该 Intranet 扩展到公司外部的用户。它也被描述为一种“心态”，在这种状态下，互联网被视为与其他公司开展业务以及向客户销售产品的一种方式。&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[117,118]},&quot;v&quot;:&quot;What’s the Internet?&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[119,120]},&quot;v&quot;:&quot;“nuts and bolts” view&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[121,122]},&quot;v&quot;:&quot;数十亿计的，互联的计算设备：主机 = 终端系统hosts = end systems&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[123,124]},&quot;v&quot;:&quot;运行网络应用network apps&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[125,126]},&quot;v&quot;:&quot;通信链接communication links&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[127,128]},&quot;v&quot;:&quot;光纤fiber、铜缆copper、无线电radio、卫星satellite&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[128,129]},&quot;v&quot;:&quot;传输速率 = 带宽bandwidth(bps)&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[130,131]},&quot;v&quot;:&quot;路由器routers：转发数据包（数据块chunks of data）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[132,133]},&quot;v&quot;:&quot;nuts and bolts螺母和螺栓&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[138,139]},&quot;v&quot;:&quot;协议控制消息的发送、接收&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[140,141]},&quot;v&quot;:&quot;例如，TCP，IP，HTTP，FTP，PPP&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[142,143]},&quot;v&quot;:&quot;互联网：“网络中的网络”&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[144,145]},&quot;v&quot;:&quot;松散的层次结构loosely hierarchical&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[145,146]},&quot;v&quot;:&quot;公共互联网public Internet与私有内联网private intranet&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[147,148]},&quot;v&quot;:&quot;互联网标准&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[149,150]},&quot;v&quot;:&quot;RFC：征求意见&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[150,151]},&quot;v&quot;:&quot;IETF：互联网工程任务组&quot;}]}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[152,153]},&quot;v&quot;:&quot;network structure网络结构：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[154,155]},&quot;v&quot;:&quot;network edge网络边缘：应用程序和主机&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[155,156]},&quot;v&quot;:&quot;access networks, physical media接入网、物理介质：有线、无线通信链路&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[156,157]},&quot;v&quot;:&quot;network core网络核心:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[158,159]},&quot;v&quot;:&quot;interconnected 互连路由器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[159,160]},&quot;v&quot;:&quot;网络中的网络&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[161,162]},&quot;v&quot;:&quot;What’s the Internet: a service view&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[163,164]},&quot;v&quot;:&quot;通信基础(communication infrastructure)设施支持分布式应用程序：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[165,166]},&quot;v&quot;:&quot;网络、电子邮件、游戏、电子商务(e-commerce)、文件共享&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[167,168]},&quot;v&quot;:&quot;提供给应用程序的通信服务communication services provided to apps:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[169,170]},&quot;v&quot;:&quot;无连接不可靠&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[170,171]},&quot;v&quot;:&quot;面向连接可靠&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[172,173]},&quot;v&quot;:&quot;1.2 what’s aprotocol&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[174,175]},&quot;v&quot;:&quot;协议定义网络实体之间发送和接收的msgs的格式，顺序，以及对msg传输，接收执行的操作&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[176,177]},&quot;v&quot;:&quot;protocols define format, order of msgs sent and received among network entities, and actions taken on msg transmission, receipt&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[178,179]},&quot;v&quot;:&quot;1.3 network edge&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[180,181]},&quot;v&quot;:&quot;端系统（主机）：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[182,183]},&quot;v&quot;:&quot;运行应用程序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[184,185]},&quot;v&quot;:&quot;如Web、email&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[186,187]},&quot;v&quot;:&quot;在 “网络的边缘”&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[188,189]},&quot;v&quot;:&quot;客户/服务器模式client/server model&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[190,191]},&quot;v&quot;:&quot;客户端向服务器请求、接收服务&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[191,192]},&quot;v&quot;:&quot;如Web浏览器/服务器；email客户端/服务器&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[193,194]},&quot;v&quot;:&quot;对等（peer-peer ）模式&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[195,196]},&quot;v&quot;:&quot;很少（甚至没有）专门的dedicated服务器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[196,197]},&quot;v&quot;:&quot;如 Gnutella、KaZaA、Emule&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[198,199]},&quot;v&quot;:&quot;面向连接的服务connection-oriented service&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[200,201]},&quot;v&quot;:&quot;端点上的设备使用协议在发送任何数据之前建立端到端的逻辑或物理连接。面向连接的协议在以下三个步骤或过程中提供服务：握手Handshaking、数据传输Data Transfer、连接终止Connection Termination。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[201,202]},&quot;v&quot;:&quot;目标：终端系统之间的数据传输&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[202,203]},&quot;v&quot;:&quot;握手：提前设置（准备）数据传输&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[204,205]},&quot;v&quot;:&quot;在两个通信主机中设置“状态”&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[206,207]},&quot;v&quot;:&quot;TCP - Transmission Control Protocol 传输控制协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[208,209]},&quot;v&quot;:&quot;互联网的连接导向型服务&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[210,211]},&quot;v&quot;:&quot;TCP 服务 [RFC 793]&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[212,213]},&quot;v&quot;:&quot;可靠、有序的字节流数据传输&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[214,215]},&quot;v&quot;:&quot;丢失：确认acknowledgements和转播retransmissions&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[216,217]},&quot;v&quot;:&quot;flow control（流控制）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[218,219]},&quot;v&quot;:&quot;发送方不会压倒overwhelm接收方&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[220,221]},&quot;v&quot;:&quot;congestion control: （拥塞控制）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[222,223]},&quot;v&quot;:&quot;发件人在网络拥塞时“降低发送速率”&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[224,225]},&quot;v&quot;:&quot;应用程序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[226,227]},&quot;v&quot;:&quot;HTTP (Web), FTP (file transfer), Telnet (remote login), SMTP (email)&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[228,229]},&quot;v&quot;:&quot;无连接服务connectionless service&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[230,233]},&quot;v&quot;:&quot;一种服务，其中不需要在设备之间建立连接来传输数据。<br>\n每当设备有要发送的数据时，它就会将数据发送到另一个设备。<br>\n此服务不提供可靠的接送服务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[233,234]},&quot;v&quot;:&quot;目标：终端系统之间的数据传输&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[234,235]},&quot;v&quot;:&quot;UDP - User Datagram Protocol 用户数据报协议 [RFC 768]：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[236,237]},&quot;v&quot;:&quot;无连接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[237,238]},&quot;v&quot;:&quot;不可靠的数据传输&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[238,239]},&quot;v&quot;:&quot;无流量控制&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[239,240]},&quot;v&quot;:&quot;无拥塞控制&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[241,242]},&quot;v&quot;:&quot;应用程序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[243,245]},&quot;v&quot;:&quot;streaming media, teleconferencing, DNS, Internet telephony<br>\nQQ&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[246,247]},&quot;v&quot;:&quot;1.4 network core&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[248,249]},&quot;v&quot;:&quot;network structure&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[250,251]},&quot;v&quot;:&quot;路由器的网状网络Mesh&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[252,253]},&quot;v&quot;:&quot;基本问题：数据如何通过网络传输？&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[254,255]},&quot;v&quot;:&quot;电路交换circuit switching：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[256,257]},&quot;v&quot;:&quot;每次呼叫专用电路：电话网&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[258,259]},&quot;v&quot;:&quot;分组交换packet-switching：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[260,261]},&quot;v&quot;:&quot;通过网络以离散(discrete)“块chunks”形式发送的数据&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[262,263]},&quot;v&quot;:&quot;端到端的资源被分配给从源端&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[266,267]},&quot;v&quot;:&quot;circuit switching电路交换&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[268,269]},&quot;v&quot;:&quot;链路带宽、交换机容量&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[269,270]},&quot;v&quot;:&quot;专用dedicated资源：无共享&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[270,271]},&quot;v&quot;:&quot;类似电路（保证）的性能&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[271,272]},&quot;v&quot;:&quot;需要呼叫设置&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[272,273]},&quot;v&quot;:&quot;面向连接的服务&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[273,274]},&quot;v&quot;:&quot;电路保证信道的全部带宽，并在通信会话期间保持连接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[274,275]},&quot;v&quot;:&quot;网络资源（例如带宽）分为“pieces”&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[276,277]},&quot;v&quot;:&quot;pieces被分配给调用&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[277,278]},&quot;v&quot;:&quot;frequency division频分&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[279,280]},&quot;v&quot;:&quot;FDM&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[281,282]},&quot;v&quot;:&quot;time division时分&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[283,284]},&quot;v&quot;:&quot;TDM&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[285,286]},&quot;v&quot;:&quot;code division代码划分&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[287,288]},&quot;v&quot;:&quot;CDMA&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[289,290]},&quot;v&quot;:&quot;计算的例子：P53、54&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[291,292]},&quot;v&quot;:&quot;资源段空闲idle，如果未由拥有调用使用（无共享）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[292,293]},&quot;v&quot;:&quot;电路交换不适合计算机之间的通信&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[294,295]},&quot;v&quot;:&quot;连接建立时间长&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[295,296]},&quot;v&quot;:&quot;计算机之间的通信有突发性，如果使用线路交换，则浪费的片较多&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[296,297]},&quot;v&quot;:&quot;即使这个呼叫没有数据传递，其所占据的片也不能够被别的呼叫使用&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[298,299]},&quot;v&quot;:&quot;Packet switching分组交换&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[300,301]},&quot;v&quot;:&quot;每个端到端数据流划分为数据包&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[302,303]},&quot;v&quot;:&quot;用户 A、B 数据包共享网络资源&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[303,304]},&quot;v&quot;:&quot;每个数据包使用全链路带宽&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[304,305]},&quot;v&quot;:&quot;根据需要使用的资源&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[306,307]},&quot;v&quot;:&quot;资源争用：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[308,309]},&quot;v&quot;:&quot;资源需求总量可能超过可用量&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[309,310]},&quot;v&quot;:&quot;拥塞：数据包队列，等待链路使用&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[310,311]},&quot;v&quot;:&quot;存储和转发：数据包一次移动一个跃点hop&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[312,313]},&quot;v&quot;:&quot;节点在转发之前接收完整的数据包&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[314,315]},&quot;v&quot;:&quot;Statistical Multiplexing统计多路复用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[316,317]},&quot;v&quot;:&quot;A和B数据包的序列没有固定的模式，按需共享统计多路复用。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[317,318]},&quot;v&quot;:&quot;TDM：每个主机在旋转TDM帧中获得相同的时间间隔slot。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[318,319]},&quot;v&quot;:&quot;为了提高TDM系统的利用率,可以使用按需分配的技术,即根据用户需求动态分配时隙,以避免每帧中出现空闲的时隙.此时复用器传输的数据只来自正在工作的设备,这种动态分配时隙的工作方式称为统计时分复用(Statistical Time Division Multiplexing,STDM).&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[320,321]},&quot;v&quot;:&quot;store-and-forward存储转发&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[322,323]},&quot;v&quot;:&quot;被传输到下一个链路之前，整个分组必须到达路由器：存储-转发&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[323,324]},&quot;v&quot;:&quot;在一个速率为R bps的链路，一个长度为L bits 的分组的存储转发延时： L/R s（此处忽略）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[325,326]},&quot;v&quot;:&quot;forwarding转发&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[327,328]},&quot;v&quot;:&quot;目标：通过路由器将数据包从源移动到目标&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[328,329]},&quot;v&quot;:&quot;数据报网络datagram network：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[330,331]},&quot;v&quot;:&quot;数据包中的目标地址确定下一跃点&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[331,332]},&quot;v&quot;:&quot;路由在会话期间可能会更改&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[333,334]},&quot;v&quot;:&quot;虚拟电路网络virtual circuit network：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[335,336]},&quot;v&quot;:&quot;每个数据包携带标签（虚拟电路ID），标签tag决定下一跃点hop&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[336,337]},&quot;v&quot;:&quot;在呼叫建立时确定的固定路径，通过呼叫保持固定&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[337,338]},&quot;v&quot;:&quot;路由器维护每个呼叫状态&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[339,340]},&quot;v&quot;:&quot;分组交换与电路交换对比&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[341,342]},&quot;v&quot;:&quot;分组交换没有：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[343,344]},&quot;v&quot;:&quot;带宽划分为“块”&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[344,345]},&quot;v&quot;:&quot;专用分配&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[345,346]},&quot;v&quot;:&quot;资源预留&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[347,348]},&quot;v&quot;:&quot;分组交换让更多用户使用网络&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[348,349]},&quot;v&quot;:&quot;分组交换非常适合突发数据&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[350,351]},&quot;v&quot;:&quot;资源共享&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[351,352]},&quot;v&quot;:&quot;更简单，无需呼叫设置&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[353,354]},&quot;v&quot;:&quot;分组交换过度拥塞：数据包延迟和丢失&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[355,356]},&quot;v&quot;:&quot;可靠数据传输、拥塞控制所需的协议&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[357,358]},&quot;v&quot;:&quot;网络分类&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[364,365]},&quot;v&quot;:&quot;1.5 access net, physical media接入网络和物理媒体&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[366,367]},&quot;v&quot;:&quot;怎样将端系统和边缘路由器连接？&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[368,369]},&quot;v&quot;:&quot;residential access nets住宅接入网络&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[370,371]},&quot;v&quot;:&quot;point to point access&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[372,373]},&quot;v&quot;:&quot;拨号调制解调器Dialup via modem&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[373,374]},&quot;v&quot;:&quot;高达 56Kbps 的直接访问路由器（通常更少）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[374,375]},&quot;v&quot;:&quot;不能同时上网和打电话：不能“始终在线”&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[376,377]},&quot;v&quot;:&quot;非对称数字用户专线Asymmetric Digital Subscriber Line（ADSL）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[377,378]},&quot;v&quot;:&quot;cable modems电缆调制解调器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[379,380]},&quot;v&quot;:&quot;光纤将电缆头端连接到邻域级结点。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[380,381]},&quot;v&quot;:&quot;然后使用传统的同轴电缆到达单独的房屋和公寓。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[382,383]},&quot;v&quot;:&quot;Cable Network Architecture有线网络架构&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[384,385]},&quot;v&quot;:&quot;HFC：混合光纤同轴电缆&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[386,387]},&quot;v&quot;:&quot;非对称：高达30Mbps的下行传输速率，2 Mbps的上行传输速率&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[388,389]},&quot;v&quot;:&quot;电缆网络，光纤将家庭连接到ISP路由器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[390,391]},&quot;v&quot;:&quot;家庭共享接入网络到电缆头端&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[391,392]},&quot;v&quot;:&quot;与DSL不同，DSL具有对中央办公室的专用访问权限&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[393,394]},&quot;v&quot;:&quot;institutional access networks (school, company)单位接入网络&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[395,396]},&quot;v&quot;:&quot;企业接入网络(Ethernet)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[397,398]},&quot;v&quot;:&quot;经常被企业或者大学等机构采用&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[398,399]},&quot;v&quot;:&quot;10 Mbps, 100Mbps, 1Gbps, 10Gbps传输率&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[399,400]},&quot;v&quot;:&quot;现在，端系统经常直接接到以太网络交换机上&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[401,402]},&quot;v&quot;:&quot;mobile access networks无线接入网络&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[403,404]},&quot;v&quot;:&quot;各无线端系统共享无线接入网络（端系统到无线路由器）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[405,406]},&quot;v&quot;:&quot;通过基站或者叫接入点&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[407,408]},&quot;v&quot;:&quot;无线LANs:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[409,410]},&quot;v&quot;:&quot;建筑物内部 (100 ft)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[410,411]},&quot;v&quot;:&quot;802.11b/g (WiFi): 11, 54Mbps 传输速率&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[412,413]},&quot;v&quot;:&quot;广域无线接入&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[414,415]},&quot;v&quot;:&quot;由电信运营商提供 (cellular) ,10’s km&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[415,416]},&quot;v&quot;:&quot;1 到 10 Mbps&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[416,417]},&quot;v&quot;:&quot;3G, 4G: LTE&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[418,419]},&quot;v&quot;:&quot;Physical Media物理媒体&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[420,421]},&quot;v&quot;:&quot;Bit: 在发送-接收对间传播&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[421,422]},&quot;v&quot;:&quot;物理链路：连接每个发送-接收对之间的物理媒体&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[422,423]},&quot;v&quot;:&quot;导引型媒体:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[424,425]},&quot;v&quot;:&quot;信号沿着固体媒介被导引：同轴电缆、光纤、 双绞线&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[426,427]},&quot;v&quot;:&quot;非导引型媒体：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[428,429]},&quot;v&quot;:&quot;开放的空间传输电磁波或者光信号，在电磁或者光信号中承载数字数据&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[430,432]},&quot;v&quot;:&quot;Twisted Pair 双绞线 (TP)<br>\nP83-90&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[433,434]},&quot;v&quot;:&quot;两根绝缘铜导线拧合&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[434,435]},&quot;v&quot;:&quot;3类：传统电话线，10 Mbps以太网&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[435,436]},&quot;v&quot;:&quot;5类：100Mbps 以太网，Gbps 千兆位以太网&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[436,437]},&quot;v&quot;:&quot;6类：10Gbps万兆以太网&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[438,439]},&quot;v&quot;:&quot;同轴电缆Coaxial cable：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[440,441]},&quot;v&quot;:&quot;两根同轴concentric的铜copper导线conductors&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[441,442]},&quot;v&quot;:&quot;双向bidirectional&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[442,443]},&quot;v&quot;:&quot;基带baseband：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[444,445]},&quot;v&quot;:&quot;电缆上一个单个信道&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[445,446]},&quot;v&quot;:&quot;Ethernet&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[447,448]},&quot;v&quot;:&quot;宽带broadband：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[449,450]},&quot;v&quot;:&quot;电缆上有多个信道&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[450,451]},&quot;v&quot;:&quot;HFC&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[452,453]},&quot;v&quot;:&quot;光纤和光缆Fiber optic cable：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[454,455]},&quot;v&quot;:&quot;光脉冲，每个脉冲表示一个bit，在玻璃纤维中传输&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[455,456]},&quot;v&quot;:&quot;高速：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[457,458]},&quot;v&quot;:&quot;点到点的高速传输（如10 Gps-100Gbps传输速率 ）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[459,460]},&quot;v&quot;:&quot;低误码率：在两个中继器之间可以有很长的距离，不受电磁噪声的干扰&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[460,461]},&quot;v&quot;:&quot;安全&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[462,463]},&quot;v&quot;:&quot;无线链路radio&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[464,465]},&quot;v&quot;:&quot;开放空间传输电磁波，携带要传输的数据&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[465,466]},&quot;v&quot;:&quot;无需物理“线缆”&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[466,467]},&quot;v&quot;:&quot;双向&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[467,468]},&quot;v&quot;:&quot;传播环境效应：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[469,470]},&quot;v&quot;:&quot;反射reflection&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[470,471]},&quot;v&quot;:&quot;吸收Obstruction by objects&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[471,472]},&quot;v&quot;:&quot;干扰Interference&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[473,474]},&quot;v&quot;:&quot;无线链路类型:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[475,476]},&quot;v&quot;:&quot;terrestrial  microwave地面微波&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[476,477]},&quot;v&quot;:&quot;LAN (e.g., WiFi)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[477,478]},&quot;v&quot;:&quot;wide-area (e.g., 蜂窝)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[478,479]},&quot;v&quot;:&quot;卫星satellite&quot;}]}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[480,481]},&quot;v&quot;:&quot;1.6 Internet/ ISP structure&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[482,483]},&quot;v&quot;:&quot;Internet structure: network of networks&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[484,485]},&quot;v&quot;:&quot;大致分层&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[485,486]},&quot;v&quot;:&quot;在中心：“Tier-1”ISP（例如，MCI，Sprint，AT&amp;amp;T，Cable and Wireless），全国national/国际international覆盖coverage&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[487,488]},&quot;v&quot;:&quot;平等相待&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[489,490]},&quot;v&quot;:&quot;“Tier-2”ISP：较小的（通常是区域性的）ISP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[491,492]},&quot;v&quot;:&quot;连接到一个或多个第 1 层 ISP，可能还有其他第 2 层 ISP&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[493,494]},&quot;v&quot;:&quot;“Tier-3”ISP 和本地 ISP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[495,496]},&quot;v&quot;:&quot;最后一跳（“访问”）网络（最接近终端系统）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[497,501]},&quot;v&quot;:&quot;&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[501,502]},&quot;v&quot;:&quot;1.7 Delay &amp;amp; loss in packet-switched networks分组延时、丢失和吞吐量&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[503,504]},&quot;v&quot;:&quot;计算机网络性能Performance of Computer network&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[505,506]},&quot;v&quot;:&quot;Data rate(数据率)：计算机网络上的主机在数字信道上的传送数据的速率。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[507,508]},&quot;v&quot;:&quot;100M Ethernet&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[509,510]},&quot;v&quot;:&quot;Bandwidth(带宽）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[511,512]},&quot;v&quot;:&quot;Frequency&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[512,513]},&quot;v&quot;:&quot;Transmission rate&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[514,515]},&quot;v&quot;:&quot;Throughput(吞吐量)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[516,517]},&quot;v&quot;:&quot;rate (bits/time unit) at which bits transferred between sender/receiver&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[517,518]},&quot;v&quot;:&quot;Restricted by rated speed(额定速率)&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[519,520]},&quot;v&quot;:&quot;Communication channel沟通频道&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[521,522]},&quot;v&quot;:&quot;连接到物理传输介质（如导线），或连接到多路复用介质（如无线电信道）上的逻辑连接。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[523,524]},&quot;v&quot;:&quot;将信息信号从一个或多个发送器（或发射器）传送到一个或多个接收器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[524,525]},&quot;v&quot;:&quot;传输信息的能力 - 以Hz为单位的带宽或其以比特/秒为单位的数据速率&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[526,527]},&quot;v&quot;:&quot;单向通信One-way communication：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[528,529]},&quot;v&quot;:&quot;从一个点传输到另一个点或同时传输到多个点。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[529,530]},&quot;v&quot;:&quot;在发送点不接收信息，也不从接收点传输信息。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[531,532]},&quot;v&quot;:&quot;半双工Half-duplex&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[533,534]},&quot;v&quot;:&quot;双向沟通，但一次只能沟通一个方向&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[535,536]},&quot;v&quot;:&quot;全双工Full-duplex&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[537,538]},&quot;v&quot;:&quot;允许双向通信&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[539,540]},&quot;v&quot;:&quot;丢失和时延发生原因：数据包在路由器缓冲区中排队&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[541,542]},&quot;v&quot;:&quot;链路的数据包到达率超过输出链路容量&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[542,543]},&quot;v&quot;:&quot;数据包队列，等待轮次&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[544,545]},&quot;v&quot;:&quot;delay时延&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[546,547]},&quot;v&quot;:&quot;四个分组时延的来源&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[548,549]},&quot;v&quot;:&quot;nodal processing节点处理延时：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[550,551]},&quot;v&quot;:&quot;检查 bit级差错&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[551,552]},&quot;v&quot;:&quot;检查分组首部和决定将分组导向何处&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[553,554]},&quot;v&quot;:&quot;queueing排队延时&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[555,556]},&quot;v&quot;:&quot;在输出链路上等待传输的时间&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[556,557]},&quot;v&quot;:&quot;依赖于路由器的拥塞程度&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[558,559]},&quot;v&quot;:&quot;Transmission传输延时&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[560,561]},&quot;v&quot;:&quot;R=链路带宽(bps)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[561,562]},&quot;v&quot;:&quot;L=分组长度(bits)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[562,563]},&quot;v&quot;:&quot;将分组发送到链路上的时间= L/R&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[564,565]},&quot;v&quot;:&quot;Propagation传播延时:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[566,567]},&quot;v&quot;:&quot;d = 物理链路的长度&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[567,568]},&quot;v&quot;:&quot;s = 在媒体上的传播速度(~2x108 m/sec)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[568,569]},&quot;v&quot;:&quot;传播延时 = d/s&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[570,574]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[572,573]},&quot;v&quot;:&quot;一个栗子：P110&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[574,575]},&quot;v&quot;:&quot;节点延时计算：&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[578,579]},&quot;v&quot;:&quot;Queueing delay(revisited)排队延时&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[590,591]},&quot;v&quot;:&quot;Internet的延时和路由&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[592,593]},&quot;v&quot;:&quot;Internet 的延时和路由是什么样的呢?&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[593,594]},&quot;v&quot;:&quot;Traceroute program诊断程序: 提供从源端，经过路由器，到目的的延时测量&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[595,599]},&quot;v&quot;:&quot;For all i:<br>\n沿着目的的路径，向每个路由器发送3个探测分组<br>\n路由器 i 将向发送方返回一个分组<br>\n发送方对发送和回复之间间隔计时&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[600,601]},&quot;v&quot;:&quot;分组丢失loss&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[602,603]},&quot;v&quot;:&quot;链路的队列缓冲区容量有限&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[603,604]},&quot;v&quot;:&quot;当分组到达一个满的队列时，该分组将会丢失&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[604,605]},&quot;v&quot;:&quot;丢失的分组可能会被前一个节点或源端系统重传，或根本不重传&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[605,606]},&quot;v&quot;:&quot;吞吐量Throughput&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[607,608]},&quot;v&quot;:&quot;1.8 Protocol layers, service models&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[609,610]},&quot;v&quot;:&quot;1.9 Network Security&quot;}]}">
</svg></div>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章、链路层和局域网</title>
    <url>/2023/01/11/di-er-zhang-lian-lu-ceng-he-ju-yu-wang/</url>
    <content><![CDATA[<h1 id="第二章、链路层和局域网"><a href="#第二章、链路层和局域网" class="headerlink" title="第二章、链路层和局域网"></a>第二章、链路层和局域网</h1><h2 id="2-1介绍和链路层的服务"><a href="#2-1介绍和链路层的服务" class="headerlink" title="2.1介绍和链路层的服务"></a>2.1介绍和链路层的服务</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>datagram数据报</li>
<li>communication link链路</li>
<li>communication link链路</li>
<li>routing algorithm路由算法</li>
</ul>
<h3 id="链路层服务"><a href="#链路层服务" class="headerlink" title="链路层服务"></a>链路层服务</h3><ul>
<li><p>Framing, link access: 帧的封装和链路的访问</p>
<ul>
<li>将数据包封装成帧，加上头部和尾部<br>encapsulate datagram into frame, adding header, trailer</li>
<li>信道访问<br>channel access if shared medium</li>
<li>链路层寻址（帧的头部使用的mac地址，用于识别源和目的）<br>“MAC” addresses used in frame headers to identify source, dest</li>
</ul>
</li>
<li><p>Reliable delivery between adjacent nodes<br>相邻节点间的可靠传输</p>
<ul>
<li>至少要保证不错，很少用在低位错误链路（光纤fiber、双绞线twisted pair）</li>
<li>第三章学习如何实现</li>
</ul>
</li>
<li><p>Flow Control: 流量控制</p>
<ul>
<li>相邻发送节点和接受节点之间的步调</li>
</ul>
</li>
<li><p>Error Detection: 错误检测</p>
<ul>
<li>由信号衰减、噪声引起的误差</li>
<li>接收方检测是否存在（presence）错误</li>
<li>信号发送方用于检查是否重新传输或丢帧</li>
</ul>
</li>
<li><p>Error Correction: 错误修正</p>
<ul>
<li>接收方识别并纠正错误</li>
</ul>
</li>
<li><p>Half-duplex and full-duplex全双工和半双工</p>
<ul>
<li>使用半双工，链路两端节点不可以同时传输</li>
</ul>
</li>
</ul>
<h3 id="链路层实现位置"><a href="#链路层实现位置" class="headerlink" title="链路层实现位置"></a>链路层实现位置</h3><ul>
<li><p>网络边缘<br>in each and every host</p>
</li>
<li><p>适配器（网络接口卡网卡）和网卡<br>adaptor  chip</p>
<p>- </p>
</li>
<li><p>连接主机的系统总线</p>
</li>
<li><p>硬件、软件、固件组合</p>
</li>
<li></li>
</ul>
<h2 id="2-2校验和纠正"><a href="#2-2校验和纠正" class="headerlink" title="2.2校验和纠正"></a>2.2校验和纠正</h2><p>Error detection and correction </p>
<h3 id="EDC：Error-Detection-and-Correction-bits检错纠错码（为后添加的冗余数据）"><a href="#EDC：Error-Detection-and-Correction-bits检错纠错码（为后添加的冗余数据）" class="headerlink" title="EDC：Error Detection and Correction bits检错纠错码（为后添加的冗余数据）"></a>EDC：Error Detection and Correction bits检错纠错码（为后添加的冗余数据）</h3><p>不是百分之百可靠<br>~EDC长度越长检测效果越好</p>
<ul>
<li>检错流程（可能发生比特位发生翻转）</li>
</ul>
<h3 id="1-Parity-checking-奇偶位校验"><a href="#1-Parity-checking-奇偶位校验" class="headerlink" title="1.Parity checking(奇偶位校验)"></a>1.Parity checking(奇偶位校验)</h3><ul>
<li><p>Single Bit Parity(奇偶校验)</p>
<ul>
<li>最不实用但简单</li>
<li>缺点：不能改错，有误报情况，只能测出一半的错误（奇位错）</li>
<li></li>
</ul>
</li>
<li><p>Two Dimensional Bit Parity:二维奇偶校验</p>
<ul>
<li>优：可定位错误</li>
<li>缺：有误报</li>
<li></li>
</ul>
</li>
</ul>
<h3 id="2-Internet-checksum-校验和"><a href="#2-Internet-checksum-校验和" class="headerlink" title="2.Internet checksum(校验和)"></a>2.Internet checksum(校验和)</h3><ul>
<li><p>只能检测不能纠正，只在❗传输层使用（因为实现麻烦，需要cpu辅助）</p>
</li>
<li><p>目标：检测在传输段中的错误:<br>detect “errors” in transmitted segment </p>
</li>
<li><p>发送端sender</p>
<ul>
<li><p>将段的内容视为十六位整数<br>treat segment contents as sequence of 16-bit integers</p>
</li>
<li><p>校验和：段内容的反码和<br>addition (1’s complement sum) of segment 进位contents（最高位循环加到最后一位，不丢数据）</p>
</li>
<li><p>把校验和放到udp校验和字段中</p>
<ul>
<li>UDP(User Datagram Protocol)用户数据报协议</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p>接收端receiver</p>
<ul>
<li><p>计算接受端的校验和</p>
</li>
<li><p>检查计算的校验和是否等于校验和字段值（）</p>
<ul>
<li>如果不为0，则有错误</li>
<li>为0，则正确（发送端计算为反码）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-Checksumming-Cyclic-Redundancy-Check"><a href="#3-Checksumming-Cyclic-Redundancy-Check" class="headerlink" title="3.Checksumming: Cyclic Redundancy Check"></a>3.Checksumming: Cyclic Redundancy Check</h3><p>（校验和：循环冗余校验）（CRC❗链路层使用）</p>
<p>- </p>
<ul>
<li><p>D：要发送的数据，看成的二进制数</p>
</li>
<li><p>G：r+1位模式（生成器），一个接收方知道的数</p>
</li>
<li><p>最后R加到数据末尾</p>
</li>
<li><p>检测用到异或，计算方便</p>
</li>
<li><p>够用就行,G位数越多检测能力越强</p>
</li>
<li><p>每个CRC标准能够检测不多于r+1位的猝发错误和任意的奇数个比特错误</p>
</li>
</ul>
<h2 id="2-3-多路访问协议（解决共享信道的问题）"><a href="#2-3-多路访问协议（解决共享信道的问题）" class="headerlink" title="2.3 多路访问协议（解决共享信道的问题）"></a>2.3 多路访问协议（解决共享信道的问题）</h2><p>Multiple access Protocols（MAC协议）</p>
<h3 id="Multiple-Access-Links-and-Protocols多个访问链接和协议（两类连接）"><a href="#Multiple-Access-Links-and-Protocols多个访问链接和协议（两类连接）" class="headerlink" title="Multiple Access Links and Protocols多个访问链接和协议（两类连接）"></a>Multiple Access Links and Protocols多个访问链接和协议（两类连接）</h3><ul>
<li><p>点对点point-to-point</p>
<ul>
<li>家用或路由器</li>
<li>以太网</li>
</ul>
</li>
<li><p>广播broadcast<br>（shared wire or medium共享电路和介质</p>
</li>
</ul>
<h3 id="分类法a-taxonomy"><a href="#分类法a-taxonomy" class="headerlink" title="分类法a taxonomy"></a>分类法a taxonomy</h3><ul>
<li><p>Channel Partitioning信道划分</p>
<ul>
<li><p>特点</p>
<ul>
<li>divide channel into smaller “pieces” (time slots, frequency, code)</li>
<li>allocate piece to node for exclusive专属 use</li>
</ul>
</li>
<li><p>TDMA：time division multiple access </p>
<ul>
<li>每个站在每轮中获得固定长度的插槽（长度= pkt传输时间）</li>
</ul>
</li>
<li><p>利用率低 FDMA</p>
<ul>
<li>因为没有使用的信道都是空闲的</li>
</ul>
</li>
</ul>
</li>
<li><p>Random Access随机访问</p>
<ul>
<li><p>channel not divided, allow collisions</p>
</li>
<li><p>“recover” from collisions冲突</p>
</li>
<li><p>处理的问题</p>
<ul>
<li><p>如何检测碰撞</p>
<ul>
<li>“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。结果就是两个帧都变得无用</li>
</ul>
</li>
<li><p>如何从冲突中恢复（例如，通过延迟转播）</p>
</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li><p>slotted ALOHA（有时隙的）</p>
<ul>
<li><p>假设，所有帧都等长，时间等分时隙（slot），一个时隙恰好发送一个数据帧，只能从开始的地方发送，节点间同步，两个节点冲突，所有节点都可以检测到</p>
</li>
<li><p>操作：当节点获得新帧时，它会在下一个插槽中传输<br>如果没有冲突，节点可以在下一个槽中发送新帧<br>如果发生冲突，节点在每个后续插槽中用 prob. p 重新传输帧直到成功</p>
</li>
<li><p>优点（pros）</p>
<ul>
<li>单个主动节点可以全速率连续传输通道独占带宽</li>
<li>高度去中心化：去中心化节点中只有插槽需要同步</li>
<li>简单</li>
</ul>
</li>
<li><p>缺点cons</p>
<ul>
<li>碰撞，浪费slot</li>
<li>空闲slot</li>
<li>节点可能能够在传输数据包的不到一段时间内检测到冲突</li>
<li>时钟同步困难</li>
</ul>
</li>
<li><p>基于时间同步，n无限大时，可达到37%传输效率</p>
</li>
</ul>
</li>
<li><p>Pure (unslotted) ALOHA无时隙的（始终不用同步</p>
<ul>
<li>效率不高，但简单，最高0.18</li>
</ul>
</li>
<li><p>CSMA (Carrier Sense Multiple Access)载波监听</p>
<ul>
<li><p>传输前就监听</p>
<ul>
<li>如果通道检测到空闲：传输整个帧</li>
<li>如果信道检测到繁忙，就推迟传输</li>
</ul>
</li>
<li><p>冲突问题：由于传播时延导致没有及时监听到</p>
<ul>
<li>如果冲突，整个数据包也传输，却不能用，所以浪费时间，且半径越小越容易检测冲突</li>
<li>距离越远，带宽越低（传的慢）出现传播时延造成的冲突的可能性越大</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p>CSMA/CD (Collision Detection)载波监听冲突检测多路复用used in Ethernet</p>
<ul>
<li><p>在短时间内检测到冲突</p>
</li>
<li><p>碰撞传输中止（aborted），减少通道浪费</p>
</li>
<li><p>碰撞检测</p>
<ul>
<li>易于在有线LAN中：测量信号强度，比较发射和接收的信号</li>
<li>无线局域网中的困难：接收机在传输时关闭</li>
</ul>
</li>
<li></li>
</ul>
</li>
<li><p>CSMA/CA used in 802.11</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>“Taking turns”轮转</p>
<ul>
<li><p>Nodes take turns, but nodes with more to send can take longer turns</p>
</li>
<li><p>通道分区MAC协议（channel partitioning MAC protocols）：在高负载下高效、公平地共享通道</p>
<ul>
<li>低负载时效率低下：通道访问延迟，即使只有1个主动节点，也分配1/N带宽！</li>
</ul>
</li>
<li><p>随机访问 MAC 协议</p>
<ul>
<li>低负载时高效：单节点可充分利用通道</li>
<li>高负载：碰撞开销</li>
</ul>
</li>
<li><p>方式：</p>
<ul>
<li><p>轮询polling</p>
<ul>
<li><p>主节点”邀请”从属节点依次传输master node “invites” slave nodes to transmit in turn</p>
</li>
<li><p>通常与哑设备（“dumb” slave devices）一起使用</p>
</li>
<li><p>缺点</p>
<ul>
<li>polling overhead 轮循开销</li>
<li>latency延迟</li>
<li>single point of failure (master）一旦master主节点故障，所有都出问题</li>
</ul>
</li>
<li><p>优点：利用random优势</p>
</li>
</ul>
</li>
<li><p>token（令牌） passing依次传递</p>
<ul>
<li><p>控制令牌按顺序（sequentially）从一个节点传递到下一个节点。</p>
</li>
<li><p>令牌消息</p>
</li>
<li><p>缺点</p>
<ul>
<li>令牌开销token overhead </li>
<li>延迟latency</li>
<li>单点故障（令牌token)任何一个故障，都不能运转</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Bluetooth, FDDI使用</p>
</li>
</ul>
</li>
</ul>
<h3 id="Cable-access-network有线接入网络？？？"><a href="#Cable-access-network有线接入网络？？？" class="headerlink" title="Cable access network有线接入网络？？？"></a>Cable access network有线接入网络？？？</h3><ul>
<li><p>DOCSIS：电缆数据服务接口规范data over cable service interface spec</p>
</li>
<li><p>上行、下行频率通道上 FDM</p>
</li>
<li><p>TDM 上行：已分配某些插槽，某些插槽存在争用</p>
<ul>
<li>下行 MAP 帧：分配上游插槽</li>
<li>请求在选定插槽中传输的上游插槽（和数据）传输随机访问（二进制退避）</li>
</ul>
</li>
</ul>
<h3 id="LAN-technologies局域网技术？？？"><a href="#LAN-technologies局域网技术？？？" class="headerlink" title="LAN technologies局域网技术？？？"></a>LAN technologies局域网技术？？？</h3><ul>
<li>services, error detection/correction, multiple access</li>
<li></li>
</ul>
<h3 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h3><ul>
<li><p>最先发送数据帧的站，在发送数据帧后至多经过时间 2τ（两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。</p>
</li>
<li><p>以太网的端到端往返时延 2τ 称为争用期，或碰撞窗口。</p>
</li>
<li><p>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。   </p>
</li>
<li><p>以太网争用期：</p>
<ul>
<li>以太网取 51.2 μs 为争用期的长度。</li>
<li>对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节。</li>
<li>以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突。</li>
</ul>
</li>
</ul>
<h3 id="最短有效帧长"><a href="#最短有效帧长" class="headerlink" title="最短有效帧长"></a>最短有效帧长</h3><ul>
<li>以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。</li>
</ul>
<h3 id="帧间最小间隔"><a href="#帧间最小间隔" class="headerlink" title="帧间最小间隔"></a>帧间最小间隔</h3><ul>
<li>帧间最小间隔为 9.6 μs，相当于 96 bit 的发送时间。</li>
<li>一个站在检测到总线开始空闲后，还要等待 9.6μs 才能再次发送数据。</li>
<li>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</li>
</ul>
<h2 id="2-4-Addressing寻址"><a href="#2-4-Addressing寻址" class="headerlink" title="2.4 Addressing寻址"></a>2.4 Addressing寻址</h2><h3 id="MAC地址-or-LAN-or-physical-or-Ethernet-身份证号一样独一无二"><a href="#MAC地址-or-LAN-or-physical-or-Ethernet-身份证号一样独一无二" class="headerlink" title="MAC地址(or LAN or physical or Ethernet) 身份证号一样独一无二"></a>MAC地址(or LAN or physical or Ethernet) 身份证号一样独一无二</h3><ul>
<li><p>功能</p>
<ul>
<li>在”本地”使用，将帧从一个接口获取到另一个物理连接的接口（同一网络，在IP寻址意义上）（同一局域网）</li>
</ul>
</li>
<li><p>48 位（12位16进制） MAC 地址（对于大多数 LAN）刻录在 NIC ROM 中（写在主机的配置文件中），有时软件也可设置</p>
</li>
<li><p>每一个链路层端口都有一个mac地址</p>
</li>
<li><p>由 IEEE 管理的 MAC 地址分配</p>
</li>
<li><p>制造商购买部分MAC地址空间（以确保唯一性）</p>
</li>
<li><p>MAC 平面地址 ➜ 便携性</p>
<ul>
<li>可以将局域网卡从一个局域网移动到另一个局域网</li>
</ul>
</li>
<li><p>IP 分层地址不可移植</p>
<ul>
<li>取决于节点附加到的 IP 子网</li>
</ul>
</li>
</ul>
<h3 id="ARP协议（Address-Resolution-Protocol）地址解析协议"><a href="#ARP协议（Address-Resolution-Protocol）地址解析协议" class="headerlink" title="ARP协议（Address Resolution Protocol）地址解析协议"></a>ARP协议（Address Resolution Protocol）地址解析协议</h3><ul>
<li><p>LAN 上的每个 IP 节点（主机、路由器）都有 ARP 表</p>
</li>
<li><p>ARP 表：某些 LAN 节点的 IP/MAC 地址映射</p>
<ul>
<li><p>&lt; IP 地址;MAC 地址;TTL&gt;</p>
<ul>
<li>TTL（Time To Live生存时间）：地址映射将被遗忘的时间（通常为 20 分钟）</li>
</ul>
</li>
</ul>
</li>
<li><p>同一个局域网下查询</p>
<ul>
<li><p>A 希望将数据报发送到 B，而 B 的 MAC 地址不在 A 的 ARP 表中。</p>
</li>
<li><p>A （广播broadcasts） ARP 查询数据包（其中包含A的mac地址），其中包含 B 的 IP 地址</p>
<ul>
<li>Dest MAC 地址 = FF-FF-FF-FF-FF-FF-FF</li>
<li>LAN 上的所有计算机都接收 ARP 查询</li>
</ul>
</li>
<li><p>B 接收 ARP 数据包，使用其 （B 的） MAC 地址回复 A（ARP应答包）</p>
<ul>
<li>发送到 A 的 MAC 地址的帧（单播）</li>
</ul>
</li>
<li><p>在其 ARP 表中缓存（保存）IP 到 MAC 地址对，直到信息变旧（超时times out ），过期后需要重新问</p>
<ul>
<li>软状态soft state：除非刷新，否则超时（消失）的信息</li>
</ul>
</li>
<li><p>ARP 是”即插即用（plug-and-play）”的：</p>
<ul>
<li>节点创建其 ARP 表，无需网络管理员干预（intervention）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="寻址Addressing：路由到另一个-LAN（跨局域）（A通过R和B发数据报）"><a href="#寻址Addressing：路由到另一个-LAN（跨局域）（A通过R和B发数据报）" class="headerlink" title="寻址Addressing：路由到另一个 LAN（跨局域）（A通过R和B发数据报）"></a>寻址Addressing：路由到另一个 LAN（跨局域）（A通过R和B发数据报）</h3><ul>
<li><p>问题：</p>
<ul>
<li>专注于寻址 – 在 IP（数据报）和 MAC 层（帧）</li>
<li>A 知道 B 的 IP 地址</li>
<li>A 怎么知道第一跳路由器 R 的 IP 地址（由路由协议完成</li>
<li>A怎么知道 R 的 MAC 地址（同一个局域网可以问</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li>A 使用 IP 源 A（目标 B）创建 IP 数据报</li>
<li>A 创建链路层帧，将 R 的 MAC 地址作为目标地址，帧包含 A 到 B IP 数据报</li>
<li>R 使用 IP 源 A（目标 B）转发数据报</li>
<li>R 创建链路层帧，其中 B 的 MAC 地址为 dest，帧包含 A 到 B 的 IP 数据报</li>
</ul>
</li>
</ul>
<h2 id="2-5-Ethernet以太网"><a href="#2-5-Ethernet以太网" class="headerlink" title="2.5 Ethernet以太网"></a>2.5 Ethernet以太网</h2><h3 id="“占主导地位dominant”的有线局域网技术："><a href="#“占主导地位dominant”的有线局域网技术：" class="headerlink" title="“占主导地位dominant”的有线局域网技术："></a>“占主导地位dominant”的有线局域网技术：</h3><ul>
<li>便宜$20 100Mbs！</li>
<li>首次广泛使用局域网技术</li>
<li>比令牌 LAN 和 ATM 更简单、更便宜</li>
<li>跟上速度赛速：10 Mbps – 10 Gbps</li>
</ul>
<h3 id="物理拓扑：physical-topology"><a href="#物理拓扑：physical-topology" class="headerlink" title="物理拓扑：physical topology"></a>物理拓扑：physical topology</h3><ul>
<li><p>bus: popular through mid 90s</p>
<ul>
<li>all nodes in same collision domain (can collide with each other)</li>
</ul>
</li>
<li><p>star: prevails today现在占上风</p>
<ul>
<li>active switch in center</li>
<li>each “spoke分支” runs a (separate) Ethernet protocol (nodes do not collide冲突 with each other)</li>
</ul>
</li>
</ul>
<h3 id="以太网帧的结构v1"><a href="#以太网帧的结构v1" class="headerlink" title="以太网帧的结构v1"></a>以太网帧的结构v1</h3><ul>
<li><p>7 个字节，模式为10101010，后跟一个字节，最终模式：10101011<br>用于同步接收机、发送器时钟速率</p>
</li>
<li><p>Addresses: 6 byte source, destination MAC addresses</p>
<ul>
<li>如果适配器接收具有匹配目标地址或广播地址（例如ARP数据包）的帧，则它将帧中的数据传递到网络层协议</li>
<li>否则，适配器将丢弃帧</li>
</ul>
</li>
<li><p>Type: 表示（indicate）更高层的协议（主要是 IP，但可能支持其他协议，如 Novell IPX 和 AppleTalk）</p>
</li>
<li><p>CRC: 在接收器处检查，如果检测到错误，则浅丢一下帧（以太网中32位，4个字节）</p>
</li>
</ul>
<h3 id="以太网-V2-的-MAC-帧格式（数据字段的正式名称是-MAC-客户数据字段，最小长度-64-字节-18-字节的首部和尾部-x3D-数据字段的最小长度-）"><a href="#以太网-V2-的-MAC-帧格式（数据字段的正式名称是-MAC-客户数据字段，最小长度-64-字节-18-字节的首部和尾部-x3D-数据字段的最小长度-）" class="headerlink" title="以太网 V2 的 MAC 帧格式（数据字段的正式名称是 MAC 客户数据字段，最小长度 64 字节-18 字节的首部和尾部 = 数据字段的最小长度 ）"></a>以太网 V2 的 MAC 帧格式（数据字段的正式名称是 MAC 客户数据字段，最小长度 64 字节-18 字节的首部和尾部 = 数据字段的最小长度 ）</h3><h3 id="无效的-MAC-帧"><a href="#无效的-MAC-帧" class="headerlink" title="无效的 MAC 帧"></a>无效的 MAC 帧</h3><ul>
<li>帧的长度不是整数个字节；</li>
<li>用收到的帧检验序列 FCS 查出有差错；</li>
<li>数据字段的长度不在 46 ~ 1500 字节之间。</li>
<li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li>
<li>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧（以太网不提供有效传输）。</li>
</ul>
<h3 id="Unreliable-connectionless-service"><a href="#Unreliable-connectionless-service" class="headerlink" title="Unreliable, connectionless service"></a>Unreliable, connectionless service</h3><ul>
<li><p>无连接：发送和接收 NIC 之间无需握手</p>
</li>
<li><p>不可靠：接收 NIC 不会向发送 NIC 发送确认或 nack</p>
<ul>
<li>仅当初始发送方使用更高层 rdt（例如 TCP）时，才会恢复丢弃帧中的数据，否则丢弃的数据将丢失</li>
</ul>
</li>
<li><p>以太网的 MAC 协议：无插槽 CSMA/CD，带二进制退避</p>
</li>
</ul>
<h3 id="Ethernet-uses-CSMA-x2F-CD"><a href="#Ethernet-uses-CSMA-x2F-CD" class="headerlink" title="Ethernet uses  CSMA/CD"></a>Ethernet uses  CSMA/CD</h3><ul>
<li><p>carrier sense载波监听</p>
</li>
<li><p>collision detection冲突检测</p>
<ul>
<li><p><strong>处理采用指数退避Exponential Backoff：</strong></p>
<ul>
<li><p>目标：使重新传输尝试适应估计的当前负载</p>
<ul>
<li>负载重：随机等待会更长</li>
</ul>
</li>
<li><p>第一次冲突：从 {0，1} 中选择 K;延迟为K·512位传输次数</p>
</li>
<li><p>第二次冲突后：从 {0，1，2，3} 中选择 K…</p>
</li>
<li><p>在十次冲突后，从 {0，1，2，3，4,…,1023} 中选择 K</p>
</li>
<li><p>当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在尝试重新传输之前，适配器会等待随机时间，即随机访问</p>
</li>
<li><p>无时隙</p>
</li>
<li><p>算法实现</p>
<ul>
<li><ol>
<li>网卡（NIC）从网络层接收数据报，创建帧</li>
</ol>
</li>
<li><ol start="2">
<li>如果 NIC 检测到通道空闲，则开始帧传输。如果 NIC 检测到信道繁忙，则等待通道空闲（idle），然后进行传输。</li>
</ol>
</li>
<li><ol start="3">
<li>如果网卡传输整个帧而没检测到另一个传输，则网卡是用帧完成的！</li>
</ol>
</li>
<li><ol start="4">
<li>如果 NIC 在传输时检测到另一个传输，则中止并发送卡纸信号</li>
</ol>
</li>
<li><ol start="5">
<li>中止后，NIC 进入二进制（指数）退避：</li>
</ol>
<ul>
<li>在第 m 次冲突后，NIC 从 {0，1，2， …， 2m-1} 中随机选择 K。网卡等待 K·512 位时间，返回步骤 2</li>
<li>更长的回退间隔，更多的碰撞</li>
</ul>
</li>
</ul>
</li>
<li><p>效率</p>
<ul>
<li>Tprop = max prop between 2 nodes in LAN最远两个节点间的传播时延</li>
<li>Ttrans = time to transmit max-size frame最大帧的发送时延</li>
<li>Efficiency goes to 1 as tprop goes to 0</li>
<li>Goes to 1 as ttrans goes to infinity传播时延无限大时效率高？</li>
<li>Much better than ALOHA, but still decentralized分散, simple, and cheap</li>
<li>效率公式显示，帧越多效率越高，带宽足够低效率高，但这是不可能的，就像慢慢走，但是一直在走着</li>
</ul>
</li>
<li><p>使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。</p>
</li>
</ul>
<h3 id="节点连接到集线器（hub）：”星形拓扑”-节点和集线器之间的最大距离为-100-m"><a href="#节点连接到集线器（hub）：”星形拓扑”-节点和集线器之间的最大距离为-100-m" class="headerlink" title="节点连接到集线器（hub）：”星形拓扑”;节点和集线器之间的最大距离为 100 m"></a>节点连接到集线器（hub）：”星形拓扑”;节点和集线器之间的最大距离为 100 m</h3><h2 id="2-6-Interconnections-amp-VLAN"><a href="#2-6-Interconnections-amp-VLAN" class="headerlink" title="2.6 Interconnections &amp; VLAN"></a>2.6 Interconnections &amp; VLAN</h2><h3 id="Interconnections"><a href="#Interconnections" class="headerlink" title="Interconnections"></a>Interconnections</h3><ul>
<li><p>中继器repeater/relay: （物理层）对信号整形放大</p>
</li>
<li><p>Manchester encoding（物理层）改变编码方式，采用高低电平变化表示01，允许发送节点和接收节点中的时钟彼此同步，无需在节点间使用集中的全局时钟</p>
</li>
<li><p>转换器Translater/transformer：信号转换的中继器（两边类型不一样）</p>
<ul>
<li>如光电转换, 10base-2转换到10BaseT</li>
</ul>
</li>
<li><p>集线器hub: （物理层）（多端口中继器）</p>
<ul>
<li><p>集线器是中继器的一种形式，也称为多端口中继器。</p>
</li>
<li><p>不检测冲突（由端节点检测）</p>
</li>
<li><p>无缓存</p>
</li>
<li><p>可能会让网络很混乱</p>
</li>
<li><p>5-4-3-2-1 Rule</p>
<ul>
<li>5：允许5个网段，每网段最大长度100米。</li>
<li>4：在同一信道上允许连接4个中继器或集线器。</li>
<li>3：在其中的三个网段上可以增加节点。</li>
<li>2：在另外两个网段上，除做中继器链路外，不能接任何节点。</li>
<li>1：上述将组建一个大型的冲突域，最大站点数1024，网络直径达2500米。</li>
</ul>
</li>
</ul>
</li>
<li><p>交换机switch: （链路层）前身为网桥</p>
<ul>
<li><p>交换机是网桥的一种形式，也称为多端口网桥（网桥连接的为两个网络）</p>
</li>
<li><p>takes an active role链路层，可以存储转发，能选择性转发</p>
<ul>
<li>存储，转发以太网帧</li>
<li>检查传入帧的 MAC 地址，在要在分段上转发帧时有选择地将帧转发到一个或多个传出链路，使用 CSMA/CD 访问分段</li>
</ul>
</li>
<li><p>透明transparent</p>
<ul>
<li>主机不知道交换机的存在</li>
</ul>
</li>
<li><p>即插即用，自学plug-and-play, self-learning</p>
<ul>
<li>交换机不需要配置configured</li>
</ul>
</li>
<li><p>多个同时传输multiple simultaneous transmissions时：每个传入链路上使用以太网协议，但没有冲突;全双工，每个链路都是其自身的冲突域（隔离冲突）</p>
</li>
<li><p>Switch forwarding table交换机转发表：一个交换机一个</p>
<ul>
<li>（主机的 MAC 地址、到达主机的接口、时间戳）看起来像一个路由表！</li>
</ul>
</li>
<li><p>frame filtering/forwarding帧过滤/转发，当帧到达交换机时</p>
<ul>
<li><ol>
<li>record incoming link, MAC address of sending host</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>index switch table using MAC destination address</p>
</li>
<li><p>if entry found for destination  then {<br>if destination on segment from which frame arrived       then drop frame<br>  else forward frame on interface indicated by entry<br>  }<br> else flood  /* forward on all interfaces except arriving  interface */</p>
<ul>
<li><p>Switches vs. routers</p>
<ul>
<li><p>两者都是存储和转发：</p>
<ul>
<li>路由器：网络层设备（检查网络层标头）</li>
<li>交换机：链路层设备（检查链路层标头）</li>
</ul>
</li>
<li><p>两者都有转发表：</p>
<ul>
<li>路由器：使用路由算法的计算表，IP 地址</li>
<li>交换机：使用 flooding, learning, MAC addresses学习转发</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="VLANs-motivation虚拟局域网"><a href="#VLANs-motivation虚拟局域网" class="headerlink" title="VLANs: motivation虚拟局域网"></a>VLANs: motivation虚拟局域网</h3><ul>
<li><p>Port-based VLAN基于端口的虚拟局域网</p>
<ul>
<li><p>流量隔离traffic isolationn</p>
</li>
<li><p>动态成员资格：可以在 VLAN 之间动态分配端口</p>
</li>
<li><p>VLAN 之间的转发：通过路由完成（就像使用单独的交换机一样）</p>
<ul>
<li>在实践中，供应商销售组合交换机和路由器</li>
</ul>
</li>
</ul>
</li>
<li><p>VLANS spanning multiple switches跨多个交换机的 VLAN</p>
<ul>
<li><p>中继端口trunk port：在通过多个物理交换机定义的 VLAN 之间传输帧</p>
<ul>
<li>交换机之间在 VLAN 中转发的帧不能是普通(vanilla)的 802.1 帧（必须携带 VLAN ID 信息info）</li>
<li>802.1q 协议为中继端口之间转发的帧添加/删除了其他标头字段</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-7-PPP"><a href="#2-7-PPP" class="headerlink" title="2.7 PPP"></a>2.7 PPP</h2><h3 id="Point-to-Point-Data-Link-Control点对点数据链路控制"><a href="#Point-to-Point-Data-Link-Control点对点数据链路控制" class="headerlink" title="Point to Point Data Link Control点对点数据链路控制"></a>Point to Point Data Link Control点对点数据链路控制</h3><ul>
<li><p>一个发送方，一个接收方，一个链路：比广播链路更容易：</p>
<ul>
<li>无媒体访问控制</li>
<li>无需显式 MAC 寻址</li>
</ul>
</li>
<li><p>流行的点对点DLC协议：</p>
<ul>
<li>PPP（点对点协议）</li>
<li>HDLC：高级数据链路控制</li>
</ul>
</li>
</ul>
<h3 id="数据链路层传送的是帧（在数据链路层，规程-x3D-协议）"><a href="#数据链路层传送的是帧（在数据链路层，规程-x3D-协议）" class="headerlink" title="数据链路层传送的是帧（在数据链路层，规程=协议）"></a>数据链路层传送的是帧（在数据链路层，规程=协议）</h3><h3 id="数据链路层的三个基本问题"><a href="#数据链路层的三个基本问题" class="headerlink" title="数据链路层的三个基本问题"></a>数据链路层的三个基本问题</h3><ul>
<li><p>(1) 封装成帧</p>
<ul>
<li>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限</li>
<li>首部和尾部的一个重要作用就是进行❗帧定界。</li>
</ul>
</li>
<li><p>(2) 透明传输</p>
<ul>
<li>发送端的数据链路层在数据中出现控制字符“SOH” ”(其十六进制编码是 01)或“EOT” (其十六进制编码是 04)的前面插入一个转义字符“ESC”(其十六进制编码是 1B)。</li>
<li>字节填充(byte stuffing)或字符填充(character stuffing)——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li>
<li>如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</li>
</ul>
</li>
<li><p>(3) 差错控制 </p>
<ul>
<li><p>在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。</p>
</li>
<li><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。</p>
<ul>
<li>误码率与信噪比有很大的关系。</li>
</ul>
</li>
<li><p>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。</p>
</li>
</ul>
</li>
</ul>
<h3 id="PPP协议的三个组成部分"><a href="#PPP协议的三个组成部分" class="headerlink" title="PPP协议的三个组成部分"></a>PPP协议的三个组成部分</h3><ul>
<li><p>一个将 IP 数据报封装到串行链路的方法。</p>
<ul>
<li><p>数据包成帧：将网络层数据报封装在数据链路帧中</p>
<ul>
<li>同时承载任何网络层协议（而不仅仅是IP）的网络层数据</li>
<li>向上解复用（demultiplex upwards<br>）的能力</li>
</ul>
</li>
<li><p>位透明度：必须在数据字段中携带任何位模式</p>
</li>
<li><p>错误检测（无校正）<br>error detection (no correction)</p>
</li>
<li><p>连接活性connection liveness：检测，信号链路故障到网络层</p>
</li>
<li><p>网络层地址协商：端点可以学习/配置彼此的网络地址</p>
</li>
</ul>
</li>
<li><p>链路控制协议 LCP (Link Control Protocol)。</p>
</li>
<li><p>网络控制协议 NCP (Network Control Protocol)。   </p>
</li>
<li><p>PPP不要求</p>
<ul>
<li>no error correction/recovery不错误检测</li>
<li>no flow control没有流控制</li>
<li>out of order delivery OK 乱序也可以传输</li>
<li>no need to support multipoint links (e.g., polling)无需支持多点链接（如，轮询）</li>
</ul>
</li>
</ul>
<h3 id="PPP-Data-Frame"><a href="#PPP-Data-Frame" class="headerlink" title="PPP Data Frame"></a>PPP Data Frame</h3><p>- </p>
<ul>
<li>Flag: delimiter (framing)分隔符（框架）</li>
<li>Address:  does nothing (only one option)不执行任何操作（只有一个选项）</li>
<li>Control: 什么都不做;未来可能的多个控制领域</li>
<li>Protocol:上层协议，将帧传送到哪个帧（例如，PPP-LCP，IPCP等）</li>
<li>info: 正在承载的上层数据</li>
<li>check:  cyclic redundancy check for error detection用于错误检测的循环冗余检查</li>
</ul>
<h3 id="PPP协议的工作状态"><a href="#PPP协议的工作状态" class="headerlink" title="PPP协议的工作状态"></a>PPP协议的工作状态</h3><ul>
<li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li>
<li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li>
<li>这些分组及其响应选择一些 PPP 参数，和进行网络层配置，NCP 给新接入的 PC机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li>
<li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li>
</ul>
<p>因为知识点很多，这部分的笔记最开始是用思维导图记的，但是图片都不能导出，xmind格式的到<a href="https://pan.baidu.com/s/1ggegSKNu2UnQ8xpfmvs2dQ?pwd=5kzl">百度网盘</a>自行下载或者联系我可以发叭，笔记效果如下（也不是那么好看，建议还是看PPT或者自己整理效率较高，我的笔记整理效果稍稍欠缺）：</p>

<div class="markmap-container" style="height:800px">
  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;第二章、链路层和局域网&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;2.1介绍和链路层的服务&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;术语&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;datagram数据报&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;communication link链路&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;communication link链路&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;routing algorithm路由算法&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;链路层服务&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;Framing, link access: 帧的封装和链路的访问&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[16,18]},&quot;v&quot;:&quot;将数据包封装成帧，加上头部和尾部<br>\nencapsulate datagram into frame, adding header, trailer&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[18,20]},&quot;v&quot;:&quot;信道访问<br>\nchannel access if shared medium&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[20,22]},&quot;v&quot;:&quot;链路层寻址（帧的头部使用的mac地址，用于识别源和目的）<br>\n“MAC” addresses used in frame headers to identify source, dest&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[23,25]},&quot;v&quot;:&quot;Reliable delivery between adjacent nodes<br>\n相邻节点间的可靠传输&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;至少要保证不错，很少用在低位错误链路（光纤fiber、双绞线twisted pair）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;第三章学习如何实现&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;Flow Control: 流量控制&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;相邻发送节点和接受节点之间的步调&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;Error Detection: 错误检测&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;由信号衰减、噪声引起的误差&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;接收方检测是否存在（presence）错误&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;信号发送方用于检查是否重新传输或丢帧&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;Error Correction: 错误修正&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;接收方识别并纠正错误&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;Half-duplex and full-duplex全双工和半双工&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;使用半双工，链路两端节点不可以同时传输&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;链路层实现位置&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[49,51]},&quot;v&quot;:&quot;网络边缘<br>\nin each and every host&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[51,53]},&quot;v&quot;:&quot;适配器（网络接口卡网卡）和网卡<br>\nadaptor  chip&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;连接主机的系统总线&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;硬件、软件、固件组合&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[58,60]},&quot;v&quot;:&quot;&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;2.2校验和纠正&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;EDC：Error Detection and Correction bits检错纠错码（为后添加的冗余数据）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;检错流程（可能发生比特位发生翻转）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;1.Parity checking(奇偶位校验)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;Single Bit Parity(奇偶校验)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;最不实用但简单&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;缺点：不能改错，有误报情况，只能测出一半的错误（奇位错）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[75,77]},&quot;v&quot;:&quot;&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;Two Dimensional Bit Parity:二维奇偶校验&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;优：可定位错误&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;缺：有误报&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[81,83]},&quot;v&quot;:&quot;&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;2.Internet checksum(校验和)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;只能检测不能纠正，只在❗传输层使用（因为实现麻烦，需要cpu辅助）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[86,88]},&quot;v&quot;:&quot;目标：检测在传输段中的错误:<br>\ndetect “errors” in transmitted segment&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;发送端sender&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[90,92]},&quot;v&quot;:&quot;将段的内容视为十六位整数<br>\ntreat segment contents as sequence of 16-bit integers&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[92,94]},&quot;v&quot;:&quot;校验和：段内容的反码和<br>\naddition (1’s complement sum) of segment 进位contents（最高位循环加到最后一位，不丢数据）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[94,95]},&quot;v&quot;:&quot;把校验和放到udp校验和字段中&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;UDP(User Datagram Protocol)用户数据报协议&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[97,99]},&quot;v&quot;:&quot;&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[99,100]},&quot;v&quot;:&quot;接收端receiver&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[101,102]},&quot;v&quot;:&quot;计算接受端的校验和&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[102,103]},&quot;v&quot;:&quot;检查计算的校验和是否等于校验和字段值（）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[104,105]},&quot;v&quot;:&quot;如果不为0，则有错误&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[105,106]},&quot;v&quot;:&quot;为0，则正确（发送端计算为反码）&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[107,108]},&quot;v&quot;:&quot;3.Checksumming: Cyclic Redundancy Check&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[110,117]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[112,113]},&quot;v&quot;:&quot;D：要发送的数据，看成的二进制数&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[113,114]},&quot;v&quot;:&quot;G：r+1位模式（生成器），一个接收方知道的数&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[114,115]},&quot;v&quot;:&quot;最后R加到数据末尾&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[115,116]},&quot;v&quot;:&quot;检测用到异或，计算方便&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[117,118]},&quot;v&quot;:&quot;够用就行,G位数越多检测能力越强&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[118,119]},&quot;v&quot;:&quot;每个CRC标准能够检测不多于r+1位的猝发错误和任意的奇数个比特错误&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[120,121]},&quot;v&quot;:&quot;2.3 多路访问协议（解决共享信道的问题）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[123,124]},&quot;v&quot;:&quot;Multiple Access Links and Protocols多个访问链接和协议（两类连接）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[125,126]},&quot;v&quot;:&quot;点对点point-to-point&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[127,128]},&quot;v&quot;:&quot;家用或路由器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[128,129]},&quot;v&quot;:&quot;以太网&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[130,132]},&quot;v&quot;:&quot;广播broadcast<br>\n（shared wire or medium共享电路和介质&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[133,134]},&quot;v&quot;:&quot;分类法a taxonomy&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[135,136]},&quot;v&quot;:&quot;Channel Partitioning信道划分&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[137,138]},&quot;v&quot;:&quot;特点&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[139,140]},&quot;v&quot;:&quot;divide channel into smaller “pieces” (time slots, frequency, code)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[140,141]},&quot;v&quot;:&quot;allocate piece to node for exclusive专属 use&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[142,143]},&quot;v&quot;:&quot;TDMA：time division multiple access&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[144,145]},&quot;v&quot;:&quot;每个站在每轮中获得固定长度的插槽（长度= pkt传输时间）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[146,147]},&quot;v&quot;:&quot;利用率低 FDMA&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[148,149]},&quot;v&quot;:&quot;因为没有使用的信道都是空闲的&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[150,151]},&quot;v&quot;:&quot;Random Access随机访问&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[152,153]},&quot;v&quot;:&quot;channel not divided, allow collisions&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[153,154]},&quot;v&quot;:&quot;“recover” from collisions冲突&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[154,155]},&quot;v&quot;:&quot;处理的问题&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[156,157]},&quot;v&quot;:&quot;如何检测碰撞&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[158,159]},&quot;v&quot;:&quot;“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。结果就是两个帧都变得无用&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[160,161]},&quot;v&quot;:&quot;如何从冲突中恢复（例如，通过延迟转播）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[162,163]},&quot;v&quot;:&quot;分类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[164,165]},&quot;v&quot;:&quot;slotted ALOHA（有时隙的）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[166,167]},&quot;v&quot;:&quot;假设，所有帧都等长，时间等分时隙（slot），一个时隙恰好发送一个数据帧，只能从开始的地方发送，节点间同步，两个节点冲突，所有节点都可以检测到&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[167,170]},&quot;v&quot;:&quot;操作：当节点获得新帧时，它会在下一个插槽中传输<br>\n如果没有冲突，节点可以在下一个槽中发送新帧<br>\n如果发生冲突，节点在每个后续插槽中用 prob. p 重新传输帧直到成功&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[170,171]},&quot;v&quot;:&quot;优点（pros）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[172,173]},&quot;v&quot;:&quot;单个主动节点可以全速率连续传输通道独占带宽&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[173,174]},&quot;v&quot;:&quot;高度去中心化：去中心化节点中只有插槽需要同步&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[174,175]},&quot;v&quot;:&quot;简单&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[176,177]},&quot;v&quot;:&quot;缺点cons&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[178,179]},&quot;v&quot;:&quot;碰撞，浪费slot&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[179,180]},&quot;v&quot;:&quot;空闲slot&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[180,181]},&quot;v&quot;:&quot;节点可能能够在传输数据包的不到一段时间内检测到冲突&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[181,182]},&quot;v&quot;:&quot;时钟同步困难&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[183,184]},&quot;v&quot;:&quot;基于时间同步，n无限大时，可达到37%传输效率&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[185,186]},&quot;v&quot;:&quot;Pure (unslotted) ALOHA无时隙的（始终不用同步&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[187,188]},&quot;v&quot;:&quot;效率不高，但简单，最高0.18&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[189,190]},&quot;v&quot;:&quot;CSMA (Carrier Sense Multiple Access)载波监听&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[191,192]},&quot;v&quot;:&quot;传输前就监听&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[193,194]},&quot;v&quot;:&quot;如果通道检测到空闲：传输整个帧&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[194,195]},&quot;v&quot;:&quot;如果信道检测到繁忙，就推迟传输&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[196,197]},&quot;v&quot;:&quot;冲突问题：由于传播时延导致没有及时监听到&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[198,199]},&quot;v&quot;:&quot;如果冲突，整个数据包也传输，却不能用，所以浪费时间，且半径越小越容易检测冲突&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[199,200]},&quot;v&quot;:&quot;距离越远，带宽越低（传的慢）出现传播时延造成的冲突的可能性越大&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[200,202]},&quot;v&quot;:&quot;&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[202,203]},&quot;v&quot;:&quot;CSMA/CD (Collision Detection)载波监听冲突检测多路复用used in Ethernet&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[204,205]},&quot;v&quot;:&quot;在短时间内检测到冲突&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[205,206]},&quot;v&quot;:&quot;碰撞传输中止（aborted），减少通道浪费&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[206,207]},&quot;v&quot;:&quot;碰撞检测&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[208,209]},&quot;v&quot;:&quot;易于在有线LAN中：测量信号强度，比较发射和接收的信号&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[209,210]},&quot;v&quot;:&quot;无线局域网中的困难：接收机在传输时关闭&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[211,213]},&quot;v&quot;:&quot;&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[213,214]},&quot;v&quot;:&quot;CSMA/CA used in 802.11&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[215,216]},&quot;v&quot;:&quot;“Taking turns”轮转&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[217,218]},&quot;v&quot;:&quot;Nodes take turns, but nodes with more to send can take longer turns&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[218,219]},&quot;v&quot;:&quot;通道分区MAC协议（channel partitioning MAC protocols）：在高负载下高效、公平地共享通道&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[220,221]},&quot;v&quot;:&quot;低负载时效率低下：通道访问延迟，即使只有1个主动节点，也分配1/N带宽！&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[222,223]},&quot;v&quot;:&quot;随机访问 MAC 协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[224,225]},&quot;v&quot;:&quot;低负载时高效：单节点可充分利用通道&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[225,226]},&quot;v&quot;:&quot;高负载：碰撞开销&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[227,228]},&quot;v&quot;:&quot;方式：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[229,230]},&quot;v&quot;:&quot;轮询polling&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[231,232]},&quot;v&quot;:&quot;主节点&amp;quot;邀请&amp;quot;从属节点依次传输master node “invites” slave nodes to transmit in turn&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[232,233]},&quot;v&quot;:&quot;通常与哑设备（“dumb” slave devices）一起使用&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[233,234]},&quot;v&quot;:&quot;缺点&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[235,236]},&quot;v&quot;:&quot;polling overhead 轮循开销&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[236,237]},&quot;v&quot;:&quot;latency延迟&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[237,238]},&quot;v&quot;:&quot;single point of failure (master）一旦master主节点故障，所有都出问题&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[239,240]},&quot;v&quot;:&quot;优点：利用random优势&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[241,242]},&quot;v&quot;:&quot;token（令牌） passing依次传递&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[243,244]},&quot;v&quot;:&quot;控制令牌按顺序（sequentially）从一个节点传递到下一个节点。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[244,245]},&quot;v&quot;:&quot;令牌消息&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[245,246]},&quot;v&quot;:&quot;缺点&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[247,248]},&quot;v&quot;:&quot;令牌开销token overhead&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[248,249]},&quot;v&quot;:&quot;延迟latency&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[249,250]},&quot;v&quot;:&quot;单点故障（令牌token)任何一个故障，都不能运转&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[251,252]},&quot;v&quot;:&quot;Bluetooth, FDDI使用&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[253,254]},&quot;v&quot;:&quot;Cable access network有线接入网络？？？&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[255,256]},&quot;v&quot;:&quot;DOCSIS：电缆数据服务接口规范data over cable service interface spec&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[256,257]},&quot;v&quot;:&quot;上行、下行频率通道上 FDM&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[257,258]},&quot;v&quot;:&quot;TDM 上行：已分配某些插槽，某些插槽存在争用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[259,260]},&quot;v&quot;:&quot;下行 MAP 帧：分配上游插槽&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[260,261]},&quot;v&quot;:&quot;请求在选定插槽中传输的上游插槽（和数据）传输随机访问（二进制退避）&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[262,263]},&quot;v&quot;:&quot;LAN technologies局域网技术？？？&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[264,265]},&quot;v&quot;:&quot;services, error detection/correction, multiple access&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[265,267]},&quot;v&quot;:&quot;&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[267,268]},&quot;v&quot;:&quot;争用期&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[269,270]},&quot;v&quot;:&quot;最先发送数据帧的站，在发送数据帧后至多经过时间 2τ（两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[270,271]},&quot;v&quot;:&quot;以太网的端到端往返时延 2τ 称为争用期，或碰撞窗口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[271,272]},&quot;v&quot;:&quot;经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[272,273]},&quot;v&quot;:&quot;以太网争用期：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[274,275]},&quot;v&quot;:&quot;以太网取 51.2 μs 为争用期的长度。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[275,276]},&quot;v&quot;:&quot;对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[276,277]},&quot;v&quot;:&quot;以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突。&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[278,279]},&quot;v&quot;:&quot;最短有效帧长&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[280,281]},&quot;v&quot;:&quot;以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[282,283]},&quot;v&quot;:&quot;帧间最小间隔&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[284,285]},&quot;v&quot;:&quot;帧间最小间隔为 9.6 μs，相当于 96 bit 的发送时间。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[285,286]},&quot;v&quot;:&quot;一个站在检测到总线开始空闲后，还要等待 9.6μs 才能再次发送数据。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[286,287]},&quot;v&quot;:&quot;这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[288,289]},&quot;v&quot;:&quot;2.4 Addressing寻址&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[290,291]},&quot;v&quot;:&quot;MAC地址(or LAN or physical or Ethernet) 身份证号一样独一无二&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[292,293]},&quot;v&quot;:&quot;功能&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[294,295]},&quot;v&quot;:&quot;在&amp;quot;本地&amp;quot;使用，将帧从一个接口获取到另一个物理连接的接口（同一网络，在IP寻址意义上）（同一局域网）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[296,297]},&quot;v&quot;:&quot;48 位（12位16进制） MAC 地址（对于大多数 LAN）刻录在 NIC ROM 中（写在主机的配置文件中），有时软件也可设置&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[297,298]},&quot;v&quot;:&quot;每一个链路层端口都有一个mac地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[298,299]},&quot;v&quot;:&quot;由 IEEE 管理的 MAC 地址分配&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[299,300]},&quot;v&quot;:&quot;制造商购买部分MAC地址空间（以确保唯一性）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[300,301]},&quot;v&quot;:&quot;MAC 平面地址 ➜ 便携性&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[302,303]},&quot;v&quot;:&quot;可以将局域网卡从一个局域网移动到另一个局域网&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[304,305]},&quot;v&quot;:&quot;IP 分层地址不可移植&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[306,307]},&quot;v&quot;:&quot;取决于节点附加到的 IP 子网&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[308,309]},&quot;v&quot;:&quot;ARP协议（Address Resolution Protocol）地址解析协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[310,311]},&quot;v&quot;:&quot;LAN 上的每个 IP 节点（主机、路由器）都有 ARP 表&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[311,312]},&quot;v&quot;:&quot;ARP 表：某些 LAN 节点的 IP/MAC 地址映射&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[313,314]},&quot;v&quot;:&quot;&amp;lt; IP 地址;MAC 地址;TTL&amp;gt;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[315,316]},&quot;v&quot;:&quot;TTL（Time To Live生存时间）：地址映射将被遗忘的时间（通常为 20 分钟）&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[317,318]},&quot;v&quot;:&quot;同一个局域网下查询&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[319,320]},&quot;v&quot;:&quot;A 希望将数据报发送到 B，而 B 的 MAC 地址不在 A 的 ARP 表中。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[320,321]},&quot;v&quot;:&quot;A （广播broadcasts） ARP 查询数据包（其中包含A的mac地址），其中包含 B 的 IP 地址&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[322,323]},&quot;v&quot;:&quot;Dest MAC 地址 = FF-FF-FF-FF-FF-FF-FF&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[323,324]},&quot;v&quot;:&quot;LAN 上的所有计算机都接收 ARP 查询&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[325,326]},&quot;v&quot;:&quot;B 接收 ARP 数据包，使用其 （B 的） MAC 地址回复 A（ARP应答包）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[327,328]},&quot;v&quot;:&quot;发送到 A 的 MAC 地址的帧（单播）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[329,330]},&quot;v&quot;:&quot;在其 ARP 表中缓存（保存）IP 到 MAC 地址对，直到信息变旧（超时times out ），过期后需要重新问&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[331,332]},&quot;v&quot;:&quot;软状态soft state：除非刷新，否则超时（消失）的信息&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[333,334]},&quot;v&quot;:&quot;ARP 是&amp;quot;即插即用（plug-and-play）&amp;quot;的：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[335,336]},&quot;v&quot;:&quot;节点创建其 ARP 表，无需网络管理员干预（intervention）&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[337,338]},&quot;v&quot;:&quot;寻址Addressing：路由到另一个 LAN（跨局域）（A通过R和B发数据报）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[339,340]},&quot;v&quot;:&quot;问题：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[341,342]},&quot;v&quot;:&quot;专注于寻址 – 在 IP（数据报）和 MAC 层（帧）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[342,343]},&quot;v&quot;:&quot;A 知道 B 的 IP 地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[343,344]},&quot;v&quot;:&quot;A 怎么知道第一跳路由器 R 的 IP 地址（由路由协议完成&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[344,345]},&quot;v&quot;:&quot;A怎么知道 R 的 MAC 地址（同一个局域网可以问&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[346,347]},&quot;v&quot;:&quot;步骤&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[348,349]},&quot;v&quot;:&quot;A 使用 IP 源 A（目标 B）创建 IP 数据报&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[349,350]},&quot;v&quot;:&quot;A 创建链路层帧，将 R 的 MAC 地址作为目标地址，帧包含 A 到 B IP 数据报&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[350,351]},&quot;v&quot;:&quot;R 使用 IP 源 A（目标 B）转发数据报&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[351,352]},&quot;v&quot;:&quot;R 创建链路层帧，其中 B 的 MAC 地址为 dest，帧包含 A 到 B 的 IP 数据报&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[353,354]},&quot;v&quot;:&quot;2.5 Ethernet以太网&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[355,356]},&quot;v&quot;:&quot;&amp;quot;占主导地位dominant&amp;quot;的有线局域网技术：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[357,358]},&quot;v&quot;:&quot;便宜$20 100Mbs！&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[358,359]},&quot;v&quot;:&quot;首次广泛使用局域网技术&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[359,360]},&quot;v&quot;:&quot;比令牌 LAN 和 ATM 更简单、更便宜&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[360,361]},&quot;v&quot;:&quot;跟上速度赛速：10 Mbps – 10 Gbps&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[362,363]},&quot;v&quot;:&quot;物理拓扑：physical topology&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[364,365]},&quot;v&quot;:&quot;bus: popular through mid 90s&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[366,367]},&quot;v&quot;:&quot;all nodes in same collision domain (can collide with each other)&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[368,369]},&quot;v&quot;:&quot;star: prevails today现在占上风&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[370,371]},&quot;v&quot;:&quot;active switch in center&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[371,372]},&quot;v&quot;:&quot;each “spoke分支” runs a (separate) Ethernet protocol (nodes do not collide冲突 with each other)&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[373,374]},&quot;v&quot;:&quot;以太网帧的结构v1&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[375,377]},&quot;v&quot;:&quot;7 个字节，模式为10101010，后跟一个字节，最终模式：10101011<br>\n用于同步接收机、发送器时钟速率&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[377,378]},&quot;v&quot;:&quot;Addresses: 6 byte source, destination MAC addresses&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[379,380]},&quot;v&quot;:&quot;如果适配器接收具有匹配目标地址或广播地址（例如ARP数据包）的帧，则它将帧中的数据传递到网络层协议&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[380,381]},&quot;v&quot;:&quot;否则，适配器将丢弃帧&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[382,383]},&quot;v&quot;:&quot;Type: 表示（indicate）更高层的协议（主要是 IP，但可能支持其他协议，如 Novell IPX 和 AppleTalk）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[383,384]},&quot;v&quot;:&quot;CRC: 在接收器处检查，如果检测到错误，则浅丢一下帧（以太网中32位，4个字节）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[385,386]},&quot;v&quot;:&quot;以太网 V2 的 MAC 帧格式（数据字段的正式名称是 MAC 客户数据字段，最小长度 64 字节-18 字节的首部和尾部 = 数据字段的最小长度 ）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[387,388]},&quot;v&quot;:&quot;无效的 MAC 帧&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[389,390]},&quot;v&quot;:&quot;帧的长度不是整数个字节；&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[390,391]},&quot;v&quot;:&quot;用收到的帧检验序列 FCS 查出有差错；&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[391,392]},&quot;v&quot;:&quot;数据字段的长度不在 46 ~ 1500 字节之间。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[392,393]},&quot;v&quot;:&quot;有效的 MAC 帧长度为 64 ~ 1518 字节之间。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[393,394]},&quot;v&quot;:&quot;对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧（以太网不提供有效传输）。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[395,396]},&quot;v&quot;:&quot;Unreliable, connectionless service&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[397,398]},&quot;v&quot;:&quot;无连接：发送和接收 NIC 之间无需握手&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[398,399]},&quot;v&quot;:&quot;不可靠：接收 NIC 不会向发送 NIC 发送确认或 nack&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[400,401]},&quot;v&quot;:&quot;仅当初始发送方使用更高层 rdt（例如 TCP）时，才会恢复丢弃帧中的数据，否则丢弃的数据将丢失&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[402,403]},&quot;v&quot;:&quot;以太网的 MAC 协议：无插槽 CSMA/CD，带二进制退避&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[404,405]},&quot;v&quot;:&quot;Ethernet uses  CSMA/CD&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[406,407]},&quot;v&quot;:&quot;carrier sense载波监听&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[407,408]},&quot;v&quot;:&quot;collision detection冲突检测&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[409,410]},&quot;v&quot;:&quot;<strong>处理采用指数退避Exponential Backoff：</strong>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[411,412]},&quot;v&quot;:&quot;目标：使重新传输尝试适应估计的当前负载&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[413,414]},&quot;v&quot;:&quot;负载重：随机等待会更长&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[415,416]},&quot;v&quot;:&quot;第一次冲突：从 {0，1} 中选择 K;延迟为K·512位传输次数&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[416,417]},&quot;v&quot;:&quot;第二次冲突后：从 {0，1，2，3} 中选择 K...&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[417,418]},&quot;v&quot;:&quot;在十次冲突后，从 {0，1，2，3，4,...,1023} 中选择 K&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[418,419]},&quot;v&quot;:&quot;当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[420,421]},&quot;v&quot;:&quot;在尝试重新传输之前，适配器会等待随机时间，即随机访问&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[421,422]},&quot;v&quot;:&quot;无时隙&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[422,423]},&quot;v&quot;:&quot;算法实现&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[424,425]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[424,425],&quot;index&quot;:1},&quot;v&quot;:&quot;1. 网卡（NIC）从网络层接收数据报，创建帧&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[425,426]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[425,426],&quot;index&quot;:2},&quot;v&quot;:&quot;2. 如果 NIC 检测到通道空闲，则开始帧传输。如果 NIC 检测到信道繁忙，则等待通道空闲（idle），然后进行传输。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[426,427]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[426,427],&quot;index&quot;:3},&quot;v&quot;:&quot;3. 如果网卡传输整个帧而没检测到另一个传输，则网卡是用帧完成的！&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[427,428]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[427,428],&quot;index&quot;:4},&quot;v&quot;:&quot;4. 如果 NIC 在传输时检测到另一个传输，则中止并发送卡纸信号&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[428,433]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;ordered_list&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[428,430],&quot;start&quot;:5},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[428,429],&quot;index&quot;:5},&quot;v&quot;:&quot;5. 中止后，NIC 进入二进制（指数）退避：&quot;}]},{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[430,433]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[430,431]},&quot;v&quot;:&quot;在第 m 次冲突后，NIC 从 {0，1，2， ...， 2m-1} 中随机选择 K。网卡等待 K·512 位时间，返回步骤 2&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[431,432]},&quot;v&quot;:&quot;更长的回退间隔，更多的碰撞&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[433,434]},&quot;v&quot;:&quot;效率&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[435,436]},&quot;v&quot;:&quot;Tprop = max prop between 2 nodes in LAN最远两个节点间的传播时延&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[436,437]},&quot;v&quot;:&quot;Ttrans = time to transmit max-size frame最大帧的发送时延&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[437,438]},&quot;v&quot;:&quot;Efficiency goes to 1 as tprop goes to 0&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[438,439]},&quot;v&quot;:&quot;Goes to 1 as ttrans goes to infinity传播时延无限大时效率高？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[439,440]},&quot;v&quot;:&quot;Much better than ALOHA, but still decentralized分散, simple, and cheap&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[440,441]},&quot;v&quot;:&quot;效率公式显示，帧越多效率越高，带宽足够低效率高，但这是不可能的，就像慢慢走，但是一直在走着&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[442,443]},&quot;v&quot;:&quot;使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[444,445]},&quot;v&quot;:&quot;节点连接到集线器（hub）：&amp;quot;星形拓扑&amp;quot;;节点和集线器之间的最大距离为 100 m&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[446,447]},&quot;v&quot;:&quot;2.6 Interconnections &amp;amp; VLAN&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[448,449]},&quot;v&quot;:&quot;Interconnections&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[450,494]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[450,451]},&quot;v&quot;:&quot;中继器repeater/relay: （物理层）对信号整形放大&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[451,452]},&quot;v&quot;:&quot;Manchester encoding（物理层）改变编码方式，采用高低电平变化表示01，允许发送节点和接收节点中的时钟彼此同步，无需在节点间使用集中的全局时钟&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[452,453]},&quot;v&quot;:&quot;转换器Translater/transformer：信号转换的中继器（两边类型不一样）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[454,455]},&quot;v&quot;:&quot;如光电转换, 10base-2转换到10BaseT&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[456,457]},&quot;v&quot;:&quot;集线器hub: （物理层）（多端口中继器）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[458,459]},&quot;v&quot;:&quot;集线器是中继器的一种形式，也称为多端口中继器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[459,460]},&quot;v&quot;:&quot;不检测冲突（由端节点检测）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[460,461]},&quot;v&quot;:&quot;无缓存&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[461,462]},&quot;v&quot;:&quot;可能会让网络很混乱&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[462,463]},&quot;v&quot;:&quot;5-4-3-2-1 Rule&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[464,465]},&quot;v&quot;:&quot;5：允许5个网段，每网段最大长度100米。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[465,466]},&quot;v&quot;:&quot;4：在同一信道上允许连接4个中继器或集线器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[466,467]},&quot;v&quot;:&quot;3：在其中的三个网段上可以增加节点。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[467,468]},&quot;v&quot;:&quot;2：在另外两个网段上，除做中继器链路外，不能接任何节点。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[468,469]},&quot;v&quot;:&quot;1：上述将组建一个大型的冲突域，最大站点数1024，网络直径达2500米。&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[470,471]},&quot;v&quot;:&quot;交换机switch: （链路层）前身为网桥&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[472,473]},&quot;v&quot;:&quot;交换机是网桥的一种形式，也称为多端口网桥（网桥连接的为两个网络）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[473,474]},&quot;v&quot;:&quot;takes an active role链路层，可以存储转发，能选择性转发&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[475,476]},&quot;v&quot;:&quot;存储，转发以太网帧&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[476,477]},&quot;v&quot;:&quot;检查传入帧的 MAC 地址，在要在分段上转发帧时有选择地将帧转发到一个或多个传出链路，使用 CSMA/CD 访问分段&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[478,479]},&quot;v&quot;:&quot;透明transparent&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[480,481]},&quot;v&quot;:&quot;主机不知道交换机的存在&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[482,483]},&quot;v&quot;:&quot;即插即用，自学plug-and-play, self-learning&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[484,485]},&quot;v&quot;:&quot;交换机不需要配置configured&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[486,487]},&quot;v&quot;:&quot;多个同时传输multiple simultaneous transmissions时：每个传入链路上使用以太网协议，但没有冲突;全双工，每个链路都是其自身的冲突域（隔离冲突）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[487,488]},&quot;v&quot;:&quot;Switch forwarding table交换机转发表：一个交换机一个&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[489,490]},&quot;v&quot;:&quot;（主机的 MAC 地址、到达主机的接口、时间戳）看起来像一个路由表！&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[491,492]},&quot;v&quot;:&quot;frame filtering/forwarding帧过滤/转发，当帧到达交换机时&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[493,494],&quot;index&quot;:1},&quot;v&quot;:&quot;1. record incoming link, MAC address of sending host&quot;}]}]}]},{&quot;t&quot;:&quot;ordered_list&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[494,513],&quot;start&quot;:2},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[494,495],&quot;index&quot;:2},&quot;v&quot;:&quot;2. index switch table using MAC destination address&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[495,500],&quot;index&quot;:3},&quot;v&quot;:&quot;3. if entry found for destination\u000b  then {<br>\nif destination on segment from which frame arrived\u000b       then drop frame<br>\nelse forward frame on interface indicated by entry<br>\n}<br>\nelse flood  /* forward on all interfaces except arriving  interface */&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[501,502]},&quot;v&quot;:&quot;Switches vs. routers&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[503,504]},&quot;v&quot;:&quot;两者都是存储和转发：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[505,506]},&quot;v&quot;:&quot;路由器：网络层设备（检查网络层标头）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[506,507]},&quot;v&quot;:&quot;交换机：链路层设备（检查链路层标头）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[508,509]},&quot;v&quot;:&quot;两者都有转发表：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[510,511]},&quot;v&quot;:&quot;路由器：使用路由算法的计算表，IP 地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[511,512]},&quot;v&quot;:&quot;交换机：使用 flooding, learning, MAC addresses学习转发&quot;}]}]}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[513,514]},&quot;v&quot;:&quot;VLANs: motivation虚拟局域网&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[515,516]},&quot;v&quot;:&quot;Port-based VLAN基于端口的虚拟局域网&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[517,518]},&quot;v&quot;:&quot;流量隔离traffic isolationn&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[518,519]},&quot;v&quot;:&quot;动态成员资格：可以在 VLAN 之间动态分配端口&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[519,520]},&quot;v&quot;:&quot;VLAN 之间的转发：通过路由完成（就像使用单独的交换机一样）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[521,522]},&quot;v&quot;:&quot;在实践中，供应商销售组合交换机和路由器&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[523,524]},&quot;v&quot;:&quot;VLANS spanning multiple switches跨多个交换机的 VLAN&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[525,526]},&quot;v&quot;:&quot;中继端口trunk port：在通过多个物理交换机定义的 VLAN 之间传输帧&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[527,528]},&quot;v&quot;:&quot;交换机之间在 VLAN 中转发的帧不能是普通(vanilla)的 802.1 帧（必须携带 VLAN ID 信息info）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[528,529]},&quot;v&quot;:&quot;802.1q 协议为中继端口之间转发的帧添加/删除了其他标头字段&quot;}]}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[530,531]},&quot;v&quot;:&quot;2.7 PPP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[532,533]},&quot;v&quot;:&quot;Point to Point Data Link Control点对点数据链路控制&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[534,535]},&quot;v&quot;:&quot;一个发送方，一个接收方，一个链路：比广播链路更容易：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[536,537]},&quot;v&quot;:&quot;无媒体访问控制&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[537,538]},&quot;v&quot;:&quot;无需显式 MAC 寻址&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[539,540]},&quot;v&quot;:&quot;流行的点对点DLC协议：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[541,542]},&quot;v&quot;:&quot;PPP（点对点协议）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[542,543]},&quot;v&quot;:&quot;HDLC：高级数据链路控制&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[544,545]},&quot;v&quot;:&quot;数据链路层传送的是帧（在数据链路层，规程=协议）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[546,547]},&quot;v&quot;:&quot;数据链路层的三个基本问题&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[548,549]},&quot;v&quot;:&quot;(1) 封装成帧&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[550,551]},&quot;v&quot;:&quot;封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[551,552]},&quot;v&quot;:&quot;首部和尾部的一个重要作用就是进行❗帧定界。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[553,554]},&quot;v&quot;:&quot;(2) 透明传输&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[555,556]},&quot;v&quot;:&quot;发送端的数据链路层在数据中出现控制字符“SOH” ”(其十六进制编码是 01)或“EOT” (其十六进制编码是 04)的前面插入一个转义字符“ESC”(其十六进制编码是 1B)。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[556,557]},&quot;v&quot;:&quot;字节填充(byte stuffing)或字符填充(character stuffing)——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[557,558]},&quot;v&quot;:&quot;如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[559,560]},&quot;v&quot;:&quot;(3) 差错控制&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[561,562]},&quot;v&quot;:&quot;在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[562,563]},&quot;v&quot;:&quot;在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[564,565]},&quot;v&quot;:&quot;误码率与信噪比有很大的关系。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[566,567]},&quot;v&quot;:&quot;为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[568,569]},&quot;v&quot;:&quot;PPP协议的三个组成部分&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[570,571]},&quot;v&quot;:&quot;一个将 IP 数据报封装到串行链路的方法。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[572,573]},&quot;v&quot;:&quot;数据包成帧：将网络层数据报封装在数据链路帧中&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[574,575]},&quot;v&quot;:&quot;同时承载任何网络层协议（而不仅仅是IP）的网络层数据&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[575,577]},&quot;v&quot;:&quot;向上解复用（demultiplex upwards<br>\n）的能力&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[578,579]},&quot;v&quot;:&quot;位透明度：必须在数据字段中携带任何位模式&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[579,581]},&quot;v&quot;:&quot;错误检测（无校正）<br>\nerror detection (no correction)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[581,582]},&quot;v&quot;:&quot;连接活性connection liveness：检测，信号链路故障到网络层&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[582,583]},&quot;v&quot;:&quot;网络层地址协商：端点可以学习/配置彼此的网络地址&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[584,585]},&quot;v&quot;:&quot;链路控制协议 LCP (Link Control Protocol)。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[585,586]},&quot;v&quot;:&quot;网络控制协议 NCP (Network Control Protocol)。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[586,587]},&quot;v&quot;:&quot;PPP不要求&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[588,589]},&quot;v&quot;:&quot;no error correction/recovery不错误检测&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[589,590]},&quot;v&quot;:&quot;no flow control没有流控制&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[590,591]},&quot;v&quot;:&quot;out of order delivery OK 乱序也可以传输&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[591,592]},&quot;v&quot;:&quot;no need to support multipoint links (e.g., polling)无需支持多点链接（如，轮询）&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[593,594]},&quot;v&quot;:&quot;PPP Data Frame&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[597,598]},&quot;v&quot;:&quot;Flag: delimiter (framing)分隔符（框架）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[598,599]},&quot;v&quot;:&quot;Address:  does nothing (only one option)不执行任何操作（只有一个选项）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[599,600]},&quot;v&quot;:&quot;Control: 什么都不做;未来可能的多个控制领域&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[600,601]},&quot;v&quot;:&quot;Protocol:上层协议，将帧传送到哪个帧（例如，PPP-LCP，IPCP等）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[601,602]},&quot;v&quot;:&quot;info: 正在承载的上层数据&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[602,603]},&quot;v&quot;:&quot;check:  cyclic redundancy check for error detection用于错误检测的循环冗余检查&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[604,605]},&quot;v&quot;:&quot;PPP协议的工作状态&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[606,607]},&quot;v&quot;:&quot;当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[607,608]},&quot;v&quot;:&quot;PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[608,609]},&quot;v&quot;:&quot;这些分组及其响应选择一些 PPP 参数，和进行网络层配置，NCP 给新接入的 PC机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[609,610]},&quot;v&quot;:&quot;通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。&quot;}]}]}]}">
</svg></div>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章、应用层</title>
    <url>/2023/01/11/di-liu-zhang-ying-yong-ceng/</url>
    <content><![CDATA[<h1 id="第六章、应用层"><a href="#第六章、应用层" class="headerlink" title="第六章、应用层"></a>第六章、应用层</h1><p>Application Layer</p>
<p>编程<br>在不同的端系统上运行<br>通过网络基础设施提供的服务，应用进程彼此通信<br>如Web: Web 服务器软件与浏览器软件通信 </p>
<p>网络核心中没有应用层软件<br>网络核心没有应用层功能<br>网络应用只在端系统上存在，快速网络应用开发和部署</p>
<h2 id="5-1-Principles-of-network-applications应用层协议原理"><a href="#5-1-Principles-of-network-applications应用层协议原理" class="headerlink" title="5.1 Principles of network applications应用层协议原理"></a>5.1 Principles of network applications应用层协议原理</h2><h3 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a>网络应用的体系结构</h3><ul>
<li><p>客户-服务器模式（C/S:client/server）</p>
<ul>
<li><p>服务器:</p>
<ul>
<li><p>一直运行的主机</p>
</li>
<li><p>固定（permanent）的IP地址和周知的端口号（约定）</p>
</li>
<li><p>扩展性：服务器场（server farms for scaling）</p>
<ul>
<li>数据中心进行</li>
<li>扩展性差</li>
</ul>
</li>
</ul>
</li>
<li><p>客户端:</p>
<ul>
<li>主动与服务器通信</li>
<li>与互联网有间歇性的连接</li>
<li>可能是动态IP 地址</li>
<li>不直接与其它客户端通信</li>
</ul>
</li>
</ul>
</li>
<li><p>对等模式(P2P:Peer To Peer)</p>
<ul>
<li><p>（几乎）没有一直运行的服务器</p>
</li>
<li><p>任意（arbitrary）端系统之间可以进行通信</p>
</li>
<li><p>参与的主机间歇性连接且可以改变IP 地址</p>
</li>
<li><p>每一个节点既是客户端又是服务器</p>
<ul>
<li>自扩展性-新peer节点带来新的服务能力，当然也带来新的服务请求（高度可扩展，但难以管理）</li>
</ul>
</li>
</ul>
</li>
<li><p>混合体：客户-服务器和对等体系结构/<br>Hybrid of client-server and P2P/<br>C/S和P2P体系结构的混合体</p>
<ul>
<li><p>Napster</p>
<ul>
<li><p>文件搜索：集中 </p>
<ul>
<li>主机在中心服务器上注册其资源</li>
<li>主机向中心服务器查询资源位置</li>
</ul>
</li>
<li><p>文件传输：P2P</p>
<ul>
<li>任意Peer节点之间</li>
</ul>
</li>
</ul>
</li>
<li><p>即时通信</p>
<ul>
<li><p>在线检测：集中Presence detection/location centralized</p>
<ul>
<li>当用户上线时，向中心服务器注册其IP地址</li>
<li>用户与中心服务器联系，以找到其在线好友的位置</li>
</ul>
</li>
<li><p>两个用户之间聊天：P2P</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程通信-Processes-communicating"><a href="#进程通信-Processes-communicating" class="headerlink" title="进程通信(Processes communicating)"></a>进程通信(Processes communicating)</h3><ul>
<li><p>进程：在主机上运行的应用程序</p>
</li>
<li><p>在同一个主机内，使用进程间通信机制通信（操作系统定义）</p>
</li>
<li><p>不同主机，通过交换报文（Message）来通信</p>
<ul>
<li><p>使用OS提供的通信服务</p>
</li>
<li><p>按照应用协议交换报文</p>
<ul>
<li>借助传输层提供的服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Sockets套接字"><a href="#Sockets套接字" class="headerlink" title="Sockets套接字"></a>Sockets套接字</h3><ul>
<li><p>进程向套接字发送报文或从套接字接收报文</p>
</li>
<li><p>套接字 &lt;（类比analogous）-&gt; 门户</p>
<ul>
<li>发送进程将报文推出门户，发送进程依赖于传输层设施在另外一侧的门将报文交付给接受进程</li>
<li>接收进程从另外一端的门户收到报文（依赖于传输层设施）</li>
</ul>
</li>
<li><p>API：（1）传输协议的选择;（2）修复一些参数的能力（稍后会详细介绍）</p>
</li>
</ul>
<h3 id="寻址流程Addressing-processes"><a href="#寻址流程Addressing-processes" class="headerlink" title="寻址流程Addressing processes"></a>寻址流程Addressing processes</h3><ul>
<li><p>对于要接收消息的进程，它必须具有标识符（identifier）</p>
</li>
<li><p>主机具有唯一的 32 位 IP 地址</p>
</li>
<li><p>问：运行进程的主机的 IP 地址是否足以识别进程？</p>
</li>
<li><p>答：不可以，许多进程可以在同一主机上运行</p>
</li>
<li><p>标识符包括与主机上的进程关联的 IP 地址和端口号。</p>
</li>
<li><p>端口号示例：</p>
<ul>
<li>网络版服务器： 80<br>邮件服务器： 25</li>
</ul>
</li>
</ul>
<h3 id="应用层协议定义运行在不同端系统上"><a href="#应用层协议定义运行在不同端系统上" class="headerlink" title="应用层协议定义运行在不同端系统上"></a>应用层协议定义运行在不同端系统上</h3><p>的应用进程如何相互交换报文</p>
<ul>
<li><p>交换的报文类型：如请求和应答报文</p>
</li>
<li><p>各种报文类型的语法（syntax）：报文中的各个字段及其描述（delineate）</p>
</li>
<li><p>字段的语义（semantics）：即字段取值的含义</p>
</li>
<li><p>进程何时、如何发送报文及对报文进行响应的规则</p>
</li>
<li><p>公开协议（Public-domain protocols）：</p>
<ul>
<li><p>由RFC文档定义</p>
</li>
<li><p>允许互操作</p>
<ul>
<li>如HTTP, SMTP</li>
</ul>
</li>
</ul>
</li>
<li><p>专用（私有）协议（Proprietary protocols）：协议不公开</p>
<ul>
<li>如：Skype</li>
</ul>
</li>
</ul>
<h3 id="应用需要传输层提供什么样的服务？"><a href="#应用需要传输层提供什么样的服务？" class="headerlink" title="应用需要传输层提供什么样的服务？"></a>应用需要传输层提供什么样的服务？</h3><ul>
<li><p>数据丢失率Data loss</p>
<ul>
<li>有些应用则要求100%的可靠数据传输（如文件）</li>
<li>有些应用（如音频）能容忍一定比例以下的数据丢失</li>
</ul>
</li>
<li><p>吞吐Bandwidth</p>
<ul>
<li>一些应用（如多媒体）必须需要最小限度的吞吐，从而使得应用能够有效运转</li>
<li>一些应用能充分利用可供使用的吞吐(弹性应用)</li>
</ul>
</li>
<li><p>延迟Timing</p>
<ul>
<li><p>一些应用出于有效性考虑，对数据传输有严格的时间限制</p>
<ul>
<li>Internet 电话、交互式游戏</li>
<li>延迟、延迟差</li>
</ul>
</li>
</ul>
</li>
<li><p>安全性（扩展B）</p>
<ul>
<li>机密性</li>
<li>完整性</li>
<li>可认证性（鉴别）</li>
</ul>
</li>
<li><p>常见应用对传输服务的要求</p>
</li>
</ul>
<h3 id="Internet-传输层提供的服务"><a href="#Internet-传输层提供的服务" class="headerlink" title="Internet 传输层提供的服务"></a>Internet 传输层提供的服务</h3><ul>
<li><p>TCP 服务：</p>
<ul>
<li>面向连接connection-oriented：要求在客户端进程和服务器进程之间建立连接</li>
<li>流量控制flow control：发送方不会淹没(overwhelm)接受方</li>
<li>拥塞控制congestion control：当网络出现拥塞时，能抑制发送方</li>
<li>不能提供的服务：时间保证、最小吞吐保证和安全</li>
<li>可靠的传输服务reliable transport</li>
</ul>
</li>
<li><p>UDP 服务：不可靠数据传输</p>
<ul>
<li><p>不提供的服务：可靠，流量控制、拥塞控制、时间、带宽保证、建立连接</p>
</li>
<li><p>UDP存在的必要性</p>
<p>能够区分不同的进程，而IP服务不能<br>在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程<br>无需建立连接，省去了建立连接时间，适合事务性的应用<br>不做可靠性的工作，例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用<br>因为为了实现可靠性（准确性、保序等），必须付出时间代 价（检错重发）<br>没有拥塞控制和流量控制，应用能够按照设定的速度发送数据<br>而在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制</p>
</li>
</ul>
</li>
<li><p>Internet应用及其应用层协议和传输协议</p>
</li>
</ul>
<h2 id="5-2-Web-and-HTTP"><a href="#5-2-Web-and-HTTP" class="headerlink" title="5.2 Web and HTTP"></a>5.2 Web and HTTP</h2><h3 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h3><ul>
<li><p>Web页（Web page）：由一些对象组成</p>
<ul>
<li>对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等</li>
<li>Web页含有一个基本的HTML文件，该基本HTML文件又包含若干对象的引用（链接）</li>
</ul>
</li>
<li><p>通过URL对每个对象进行引用（addressable）</p>
<ul>
<li>访问协议，用户名，口令字，端口等；</li>
</ul>
</li>
<li><p>URL格式:</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><ul>
<li><p>HTTP: 超文本传输协议（hypertext transfer protocol）</p>
<ul>
<li>Web的应用层协议</li>
<li>客户/服务器模式 （client/server model）</li>
<li>客户端: 请求、接收和显示Web对象的浏览器（browser）</li>
<li>服务器: 对请求进行响应，发送对象的Web服务器</li>
<li>HTTP 1.0: RFC 1945<br>HTTP 1.1: RFC 2068</li>
</ul>
</li>
<li><p>使用TCP:</p>
<ul>
<li>客户发起一个与服务器的TCP连接 (建立套接字) ，端口号为 80</li>
<li>服务器接受客户端的TCP连接</li>
<li>在浏览器(HTTP客户端)与 Web服务器(HTTP服务器 server)交换HTTP报文 (应用层协议报文)</li>
<li>TCP连接关闭</li>
</ul>
</li>
<li><p>HTTP是无状态（stateless）的</p>
<ul>
<li><p>服务器并不维护关于客户的任何信息</p>
</li>
<li><p>注：维护状态的协议很复杂！</p>
<p>必须维护历史信息(状态)<br>如果服务器/客户端死机（crashes），它们的状态信息可能不一致（inconsistent），二者的信息必须进行协调（reconciled）<br>无状态的服务器能够支持更多的客户端</p>
</li>
</ul>
</li>
</ul>
<h3 id="两种类型的HTTP报文：请求request、响应response"><a href="#两种类型的HTTP报文：请求request、响应response" class="headerlink" title="两种类型的HTTP报文：请求request、响应response"></a>两种类型的HTTP报文：请求request、响应response</h3><ul>
<li><p>HTTP请求报文</p>
<ul>
<li>HTTP请求报文：ASCII (人能阅读)</li>
</ul>
</li>
<li><p>HTTP响应报文</p>
</li>
</ul>
<h3 id="用户-服务器状态User-server-state-cookies"><a href="#用户-服务器状态User-server-state-cookies" class="headerlink" title="用户-服务器状态User-server state: cookies"></a>用户-服务器状态User-server state: cookies</h3><ul>
<li><p>大多数主要的门户网站（web sites）使用 cookies</p>
</li>
<li><p>4个组成部分：</p>
<ul>
<li><ol>
<li>在HTTP响应报文中有一个cookie的首部行</li>
</ol>
</li>
<li>2)在HTTP请求报文含有一个cookie的首部行</li>
<li><ol start="3">
<li>在用户端系统中保留有一个cookie文件，由用户的浏览器(browser)管理</li>
</ol>
</li>
<li><ol start="4">
<li>在Web站点(Sites)有一个后端(back-edn)数据库</li>
</ol>
</li>
</ul>
</li>
<li><p>一个栗子</p>
<p>Susan总是用同一个PC使用Internet Explore上网<br>她第一次访问了一个使用了Cookie的电子商务网站<br>当最初的HTTP请求到达服务器时，该Web站点产生一个唯一ID，并以此作为索引在它的后 端数据库中产生一个项</p>
</li>
</ul>
<h3 id="Web缓存caches-代理服务器proxy-server"><a href="#Web缓存caches-代理服务器proxy-server" class="headerlink" title="Web缓存caches (代理服务器proxy server)"></a>Web缓存caches (代理服务器proxy server)</h3><ul>
<li><p>目标：不访问原始服务器，就满足客户的请求</p>
</li>
<li><p>用户设置浏览器： 通过缓存(cache)访问Web</p>
</li>
<li><p>浏览器将所有的HTTP请求发给缓存</p>
<ul>
<li>在缓存中的对象：缓存直接返回对象</li>
<li>如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端</li>
</ul>
</li>
</ul>
<h2 id="5-3-FTP-文件传输协议-file-transfer-protocol"><a href="#5-3-FTP-文件传输协议-file-transfer-protocol" class="headerlink" title="5.3 FTP 文件传输协议(file transfer protocol)"></a>5.3 FTP 文件传输协议(file transfer protocol)</h2><h3 id="向远程主机上传输文件或从远程主机接收文件"><a href="#向远程主机上传输文件或从远程主机接收文件" class="headerlink" title="向远程主机上传输文件或从远程主机接收文件"></a>向远程主机上传输文件或从远程主机接收文件</h3><h3 id="客户-x2F-服务器模式"><a href="#客户-x2F-服务器模式" class="headerlink" title="客户/服务器模式"></a>客户/服务器模式</h3><ul>
<li>客户端：发起传输的一方</li>
<li>服务器：远程主机</li>
</ul>
<h3 id="ftp-RFC-959"><a href="#ftp-RFC-959" class="headerlink" title="ftp: RFC 959"></a>ftp: RFC 959</h3><h3 id="ftp服务器：端口号为21"><a href="#ftp服务器：端口号为21" class="headerlink" title="ftp服务器：端口号为21"></a>ftp服务器：端口号为21</h3><h3 id="FTP-控制连接与数据连接分开"><a href="#FTP-控制连接与数据连接分开" class="headerlink" title="FTP: 控制连接与数据连接分开"></a>FTP: 控制连接与数据连接分开</h3><ul>
<li>FTP客户端与FTP服务器通过端口21联系，并指定（specifying）TCP为传输协议</li>
<li>客户端通过控制连接获得身份确认（authorization）</li>
<li>客户端通过控制连接发送命令浏览远程目录（remote directory）</li>
<li>收到一个文件传输命令时，服务器打开一个到客户端的数据连接</li>
<li>一个文件传输完成后，服务器关闭连接</li>
<li></li>
<li>服务器打开第二个TCP数据连接用来传输另一个文件</li>
<li>控制连接： 带外（ “out of band”）传送</li>
<li>FTP服务器维护用户的状态信息：当前路径、用户帐户与控制连接对应</li>
<li>有状态</li>
</ul>
<h3 id="FTP命令、响应"><a href="#FTP命令、响应" class="headerlink" title="FTP命令、响应"></a>FTP命令、响应</h3><ul>
<li><p>命令commands样例：</p>
<ul>
<li><strong>在控制连接上以ASCII文本方式传送<br>sent as ASCII text over control channel</strong></li>
<li>USER username</li>
<li>PASS password</li>
<li>LIST：请服务器返回远程主机当前目录的文件列表</li>
<li>RETR filename：从远程主机的当前目录检索文件(gets)</li>
<li>STOR filename：向远程主机的当前目录存放文件(puts)</li>
</ul>
</li>
<li><p>返回码return codes样例：</p>
<ul>
<li><strong>状态码和状态信息（status code and phrase） (同HTTP)</strong></li>
<li>331 Username OK, password required</li>
<li>125 data connection already open; transfer starting</li>
<li>425 Can’t open data connection</li>
<li>452 Error writing file</li>
</ul>
</li>
</ul>
<h2 id="5-4-Electronic-Mail"><a href="#5-4-Electronic-Mail" class="headerlink" title="5.4 Electronic Mail"></a>5.4 Electronic Mail</h2><p>（SMTP, POP3, IMAP）</p>
<h3 id="Electronic-Mail3个主要组成部分："><a href="#Electronic-Mail3个主要组成部分：" class="headerlink" title="Electronic Mail3个主要组成部分："></a>Electronic Mail3个主要组成部分：</h3><ul>
<li><p>用户代理user agents </p>
<ul>
<li>又名 “邮件阅读器mail reader”</li>
<li>撰写、编辑和阅读邮件（composing, editing, reading mail messages）</li>
<li>如., Eudora, Outlook, elm, Netscape Messenger、Foxmail</li>
<li>输出和输入（outgoing, incoming）邮件保存在服务器上</li>
</ul>
</li>
<li><p>邮件服务器mail servers</p>
<ul>
<li><p>邮箱(mailbox)中管理和维护发送给用户的邮件</p>
</li>
<li><p>输出(outgoing)报文队列(message queue)保持待发送邮件报文</p>
</li>
<li><p>邮件服务器之间的SMTP协议：发送email报文</p>
<ul>
<li>客户：发送方邮件服务器</li>
<li>服务器：接收端邮件服务器</li>
</ul>
</li>
</ul>
</li>
<li><p>简单邮件传输协议：SMTP[RFC 2821]</p>
<ul>
<li><p>使用TCP在客户端和服务器之间可靠传送报文，端口号为25</p>
</li>
<li><p>直接传输：从发送方服务器到接收方服务器</p>
</li>
<li><p>传输的3个阶段</p>
<ul>
<li>握手handshaking (greeting)</li>
<li>传输报文transfer of messages</li>
<li>关闭closure</li>
</ul>
</li>
<li><p>命令/响应交互</p>
<ul>
<li>命令commands：ASCII文本</li>
<li>响应response：状态码和状态信息</li>
</ul>
</li>
<li><p>报文必须为7位ASCII码</p>
</li>
<li><p>一个栗子</p>
<ol>
<li>Alice使用用户代理撰写邮件并发送给 <a href="mailto:bob@someschool.edu">bob@someschool.edu</a> 2) Alice的用户代理将邮件发送到她的邮件服务器；邮件放在报文队列中</li>
<li>SMTP的客户端打开到Bob邮件服务器的TCP连接</li>
<li>SMTP客户端通过TCP连接发送Alice的邮件</li>
<li>Bob的邮件服务器将邮件放到 Bob的邮箱</li>
<li>Bob调用他的用户代理阅读邮件</li>
</ol>
<ul>
<li><p>简单的SMTP交互</p>
<p>S: 220 hamburger.edu<br>C: HELO crepes.fr<br>S: 250 Hello crepes.fr, pleased to meet you<br>C: MAIL FROM:<br>S: 250 <a href="mailto:alice@crepes.fr">alice@crepes.fr</a>… Sender ok<br>C: RCPT TO:  S: 250 <a href="mailto:bob@hamburger.edu">bob@hamburger.edu</a> … Recipient ok<br>C: DATA<br>S: 354 Enter mail, end with “.” on a line by itself<br>C: Do you like ketchup?<br>C: How about pickles?<br>C: .<br>S: 250 Message accepted for delivery<br>C: QUIT<br>S: 221 hamburger.edu closing connection </p>
</li>
<li><p>尝试SMTP交互</p>
<ul>
<li>telnet servername 25</li>
<li>see 220 reply from server</li>
<li>enter HELO, MAIL FROM, RCPT TO, DATA, QUIT commands </li>
<li>上面允许您在不使用电子邮件客户端（阅读器）的情况下发送电子邮件</li>
</ul>
</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li><p>SMTP使用持久连接<br>SMTP要求报文（首部和主体）为7位ASCII编码<br>SMTP服务器使用CRLF.CRLF决定报文的尾部</p>
</li>
<li><p>HTTP比较：</p>
<ul>
<li>HTTP：拉（pull）<br>SMTP：推（push）<br>二者都是ASCII形式的命令/响应交互、状态码<br>HTTP：每个对象封装在各自的响应报文中<br>SMTP：多个对象包含在一个报文中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="邮件报文格式Mail-message-format"><a href="#邮件报文格式Mail-message-format" class="headerlink" title="邮件报文格式Mail message format"></a>邮件报文格式Mail message format</h3><h3 id="报文格式：多媒体扩展-multimedia-extensions"><a href="#报文格式：多媒体扩展-multimedia-extensions" class="headerlink" title="报文格式：多媒体扩展 multimedia extensions"></a>报文格式：多媒体扩展 multimedia extensions</h3><ul>
<li>MIME：多媒体邮件扩展（multimedia mail extension）, RFC 2045, 2056</li>
<li>在报文首部用额外的行申明MIME内容类型</li>
</ul>
<h3 id="邮件访问协议Mail-access-protocols"><a href="#邮件访问协议Mail-access-protocols" class="headerlink" title="邮件访问协议Mail access protocols"></a>邮件访问协议Mail access protocols</h3><ul>
<li><p>SMTP: 传送到接收方的邮件服务器</p>
</li>
<li><p>邮件访问协议：从服务器检索（retrieval）邮件 </p>
<ul>
<li><p>POP：邮局访问协议（Post Office Protocol）[RFC 1939]</p>
<ul>
<li>授权authorization (代理&lt;–&gt;服务器) 并下载</li>
</ul>
</li>
</ul>
</li>
<li><p>IMAP：Internet邮件访问协议（Internet Mail Access Protocol）[RFC 1730] （更多特性 (更复杂)）</p>
<ul>
<li><p><strong>在服务器上处理存储的报文（远程管理文件夹）</strong></p>
</li>
<li><p>IMAP服务器将每个报文与一个文件夹联系起来</p>
</li>
<li><p>允许用户用目录来组织报文</p>
</li>
<li><p>允许用户读取报文组件</p>
</li>
<li><p>IMAP在会话过程中保留用户状态： </p>
<ul>
<li>目录名、报文ID与目录名之间映射</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP：Hotmail , Yahoo! Mail等</p>
<ul>
<li>方便</li>
</ul>
</li>
</ul>
<h3 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h3><ul>
<li><strong>（本地管理文件夹）</strong></li>
<li>先前的例子使用 “下载并删除”模式。<br>（如果改变客户机，Bob不能阅读邮件）</li>
<li>“下载并保留”：不同客户机上为报文的拷贝</li>
<li>POP3在会话中是无状态的</li>
</ul>
<h2 id="5-5-DNS（Domain-Name-System）域名系统"><a href="#5-5-DNS（Domain-Name-System）域名系统" class="headerlink" title="5.5 DNS（Domain Name System）域名系统"></a>5.5 DNS（Domain Name System）域名系统</h2><h3 id="互联网主机、路由器："><a href="#互联网主机、路由器：" class="headerlink" title="互联网主机、路由器："></a>互联网主机、路由器：</h3><ul>
<li>IP 地址（32 位） - 用于寻址数据报</li>
<li>“名称”，例如，ww.yahoo.com - 由人类使用</li>
</ul>
<h3 id="DNS域名系统："><a href="#DNS域名系统：" class="headerlink" title="DNS域名系统："></a>DNS域名系统：</h3><ul>
<li><p>分布式数据库distributed database ：在多个名称服务器的层次结构中实现</p>
</li>
<li><p>应用层协议application-layer protocol：主机、路由器、名称服务器，用于通信以解析（resolve）名称（地址/名称转换）</p>
<ul>
<li>注：核心互联网功能，作为应用层协议实现</li>
<li>网络“边缘”的复杂性</li>
</ul>
</li>
</ul>
<h3 id="DNS的服务"><a href="#DNS的服务" class="headerlink" title="DNS的服务"></a>DNS的服务</h3><ul>
<li><p>主机名到 IP 地址的转换</p>
</li>
<li><p>主机别名Host aliasing</p>
<ul>
<li>规范名称和别名Canonical and alias names</li>
</ul>
</li>
<li><p>邮件服务器别名（aliasing）</p>
</li>
<li><p>负载分布Load distribution</p>
<ul>
<li>复制的(Replicated)Web 服务器：一个规范名称的 IP 地址集</li>
</ul>
</li>
<li><p>为什么不集中化 DNS？</p>
<ul>
<li>单点故障single point of failure</li>
<li>流量traffic volume</li>
<li>远程集中式数据库distant centralized database</li>
<li>维护maintenance</li>
</ul>
</li>
</ul>
<h3 id="分布式分层数据库"><a href="#分布式分层数据库" class="headerlink" title="分布式分层数据库"></a>分布式分层数据库</h3><p>Distributed, Hierarchical Database</p>
<h3 id="DNS-Root-name-servers"><a href="#DNS-Root-name-servers" class="headerlink" title="DNS: Root name servers"></a>DNS: Root name servers</h3><ul>
<li><p>无法解析名称的本地名称服务器联系</p>
</li>
<li><p>根名称服务器：</p>
<ul>
<li>如果名称映射未知，则联系权威名称服务器(authoritative name serve)</li>
<li>获取映射mapping</li>
<li>返回到本地名称服务器的映射</li>
</ul>
</li>
</ul>
<h3 id="TLD-and-Authoritative-Servers-TLD服务器和权威服务器"><a href="#TLD-and-Authoritative-Servers-TLD服务器和权威服务器" class="headerlink" title="TLD and Authoritative Servers(TLD服务器和权威服务器)"></a>TLD and Authoritative Servers(TLD服务器和权威服务器)</h3><ul>
<li><p>顶级域服务器（Top-level domain ，TLD servers）：负责顶级域名（如com,org, net,edu和gov）和所有国家级的顶级名（如cn, uk, fr, ca,jp ）</p>
<ul>
<li>Network solutions 公司维护com TLD服务器</li>
<li>Educause公司维护edu TLD服务器</li>
</ul>
</li>
<li><p>Authoritative DNS servers组织的 DNS 服务器，为组织的服务器（例如 Web 和邮件）提供 IP 映射的权威主机名。</p>
<ul>
<li>可由组织或服务提供商维护</li>
</ul>
</li>
</ul>
<h3 id="本地名字服务器（Local-Name-Server）"><a href="#本地名字服务器（Local-Name-Server）" class="headerlink" title="本地名字服务器（Local Name Server）"></a>本地名字服务器（Local Name Server）</h3><ul>
<li>并不严格属于层次结构</li>
<li>每个ISP (居民区的ISP、公司、大学）都有一个本地DNS服务器</li>
<li>也称为“默认名字服务器”</li>
<li>当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器</li>
<li>起着代理的作用，将查询转发到层次结构中</li>
</ul>
<h3 id="一个栗子：cis-poly-edu-的主机需要-gaia-cs-umass-edu-的-IP-地址"><a href="#一个栗子：cis-poly-edu-的主机需要-gaia-cs-umass-edu-的-IP-地址" class="headerlink" title="一个栗子：cis.poly.edu 的主机需要 gaia.cs.umass.edu 的 IP 地址"></a>一个栗子：cis.poly.edu 的主机需要 gaia.cs.umass.edu 的 IP 地址</h3><h3 id="递归查询recursive-query（根服务器的负担太重）"><a href="#递归查询recursive-query（根服务器的负担太重）" class="headerlink" title="递归查询recursive query（根服务器的负担太重）"></a>递归查询recursive query（根服务器的负担太重）</h3><ul>
<li>名字解析负担都放在当前联络的名字服务器上</li>
</ul>
<h3 id="迭代查询iterated-query"><a href="#迭代查询iterated-query" class="headerlink" title="迭代查询iterated query"></a>迭代查询iterated query</h3><ul>
<li>已联系的服务器回复要联系的服务器的名称</li>
<li>“我不知道这个名字，但问这个服务器”</li>
</ul>
<h2 id="5-6-P2P-file-sharing（P2P应用）"><a href="#5-6-P2P-file-sharing（P2P应用）" class="headerlink" title="5.6 P2P file sharing（P2P应用）"></a>5.6 P2P file sharing（P2P应用）</h2><h2 id="5-7-Socket-programming-with-TCP（TCP套接字编程）"><a href="#5-7-Socket-programming-with-TCP（TCP套接字编程）" class="headerlink" title="5.7 Socket programming with TCP（TCP套接字编程）"></a>5.7 Socket programming with TCP（TCP套接字编程）</h2><h2 id="5-8-Socket-programming-with-UDP（UDP套接字编程）"><a href="#5-8-Socket-programming-with-UDP（UDP套接字编程）" class="headerlink" title="5.8 Socket programming with UDP（UDP套接字编程）"></a>5.8 Socket programming with UDP（UDP套接字编程）</h2><h2 id="5-9-Building-a-Web-server"><a href="#5-9-Building-a-Web-server" class="headerlink" title="5.9 Building a Web server"></a>5.9 Building a Web server</h2><p>​	因为知识点很多，这部分的笔记最开始是用思维导图记的，但是图片都不能导出，xmind格式的到<a href="https://pan.baidu.com/s/1a6knCso-d6e0OU0SeSc5pQ?pwd=tgm7">百度网盘</a>自行下载或者联系我私发叭，笔记效果如下（也不是那么好看，建议还是看PPT或者自己整理效率较高，我的笔记整理效果稍稍欠缺）：</p>

<div class="markmap-container" style="height:800px">
  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;第六章、应用层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;5.1 Principles of network applications应用层协议原理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;网络应用的体系结构&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;客户-服务器模式（C/S:client/server）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;服务器:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;一直运行的主机&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;固定（permanent）的IP地址和周知的端口号（约定）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;扩展性：服务器场（server farms for scaling）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;数据中心进行&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;扩展性差&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;客户端:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;主动与服务器通信&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;与互联网有间歇性的连接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;可能是动态IP 地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;不直接与其它客户端通信&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;对等模式(P2P:Peer To Peer)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;（几乎）没有一直运行的服务器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;任意（arbitrary）端系统之间可以进行通信&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;参与的主机间歇性连接且可以改变IP 地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;每一个节点既是客户端又是服务器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;自扩展性-新peer节点带来新的服务能力，当然也带来新的服务请求（高度可扩展，但难以管理）&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[45,48]},&quot;v&quot;:&quot;混合体：客户-服务器和对等体系结构/<br>\nHybrid of client-server and P2P/<br>\nC/S和P2P体系结构的混合体&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;Napster&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;文件搜索：集中&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;主机在中心服务器上注册其资源&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;主机向中心服务器查询资源位置&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;文件传输：P2P&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;任意Peer节点之间&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;即时通信&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;在线检测：集中Presence detection/location centralized&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;当用户上线时，向中心服务器注册其IP地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;用户与中心服务器联系，以找到其在线好友的位置&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;两个用户之间聊天：P2P&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;进程通信(Processes communicating)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;进程：在主机上运行的应用程序&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;在同一个主机内，使用进程间通信机制通信（操作系统定义）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;不同主机，通过交换报文（Message）来通信&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;使用OS提供的通信服务&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;按照应用协议交换报文&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;借助传输层提供的服务&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;Sockets套接字&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;进程向套接字发送报文或从套接字接收报文&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;套接字 &amp;lt;（类比analogous）-&amp;gt; 门户&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;发送进程将报文推出门户，发送进程依赖于传输层设施在另外一侧的门将报文交付给接受进程&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;接收进程从另外一端的门户收到报文（依赖于传输层设施）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;API：（1）传输协议的选择;（2）修复一些参数的能力（稍后会详细介绍）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[90,91]},&quot;v&quot;:&quot;寻址流程Addressing processes&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[92,93]},&quot;v&quot;:&quot;对于要接收消息的进程，它必须具有标识符（identifier）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;主机具有唯一的 32 位 IP 地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[94,95]},&quot;v&quot;:&quot;问：运行进程的主机的 IP 地址是否足以识别进程？&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;答：不可以，许多进程可以在同一主机上运行&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;标识符包括与主机上的进程关联的 IP 地址和端口号。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[97,98]},&quot;v&quot;:&quot;端口号示例：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[99,101]},&quot;v&quot;:&quot;网络版服务器： 80<br>\n邮件服务器： 25&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[102,103]},&quot;v&quot;:&quot;应用层协议定义运行在不同端系统上&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[106,107]},&quot;v&quot;:&quot;交换的报文类型：如请求和应答报文&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[107,108]},&quot;v&quot;:&quot;各种报文类型的语法（syntax）：报文中的各个字段及其描述（delineate）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[108,109]},&quot;v&quot;:&quot;字段的语义（semantics）：即字段取值的含义&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[109,110]},&quot;v&quot;:&quot;进程何时、如何发送报文及对报文进行响应的规则&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[110,111]},&quot;v&quot;:&quot;公开协议（Public-domain protocols）：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[112,113]},&quot;v&quot;:&quot;由RFC文档定义&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[113,114]},&quot;v&quot;:&quot;允许互操作&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[115,116]},&quot;v&quot;:&quot;如HTTP, SMTP&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[117,118]},&quot;v&quot;:&quot;专用（私有）协议（Proprietary protocols）：协议不公开&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[119,120]},&quot;v&quot;:&quot;如：Skype&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[121,122]},&quot;v&quot;:&quot;应用需要传输层提供什么样的服务？&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[123,124]},&quot;v&quot;:&quot;数据丢失率Data loss&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[125,126]},&quot;v&quot;:&quot;有些应用则要求100%的可靠数据传输（如文件）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[126,127]},&quot;v&quot;:&quot;有些应用（如音频）能容忍一定比例以下的数据丢失&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[128,129]},&quot;v&quot;:&quot;吞吐Bandwidth&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[130,131]},&quot;v&quot;:&quot;一些应用（如多媒体）必须需要最小限度的吞吐，从而使得应用能够有效运转&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[131,132]},&quot;v&quot;:&quot;一些应用能充分利用可供使用的吞吐(弹性应用)&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[133,134]},&quot;v&quot;:&quot;延迟Timing&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[135,136]},&quot;v&quot;:&quot;一些应用出于有效性考虑，对数据传输有严格的时间限制&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[137,138]},&quot;v&quot;:&quot;Internet 电话、交互式游戏&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[138,139]},&quot;v&quot;:&quot;延迟、延迟差&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[140,141]},&quot;v&quot;:&quot;安全性（扩展B）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[142,143]},&quot;v&quot;:&quot;机密性&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[143,144]},&quot;v&quot;:&quot;完整性&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[144,145]},&quot;v&quot;:&quot;可认证性（鉴别）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[146,147]},&quot;v&quot;:&quot;常见应用对传输服务的要求&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[148,149]},&quot;v&quot;:&quot;Internet 传输层提供的服务&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[150,151]},&quot;v&quot;:&quot;TCP 服务：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[152,153]},&quot;v&quot;:&quot;面向连接connection-oriented：要求在客户端进程和服务器进程之间建立连接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[153,154]},&quot;v&quot;:&quot;流量控制flow control：发送方不会淹没(overwhelm)接受方&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[154,155]},&quot;v&quot;:&quot;拥塞控制congestion control：当网络出现拥塞时，能抑制发送方&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[155,156]},&quot;v&quot;:&quot;不能提供的服务：时间保证、最小吞吐保证和安全&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[156,157]},&quot;v&quot;:&quot;可靠的传输服务reliable transport&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[158,159]},&quot;v&quot;:&quot;UDP 服务：不可靠数据传输&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[160,161]},&quot;v&quot;:&quot;不提供的服务：可靠，流量控制、拥塞控制、时间、带宽保证、建立连接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[162,163]},&quot;v&quot;:&quot;UDP存在的必要性&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[172,173]},&quot;v&quot;:&quot;Internet应用及其应用层协议和传输协议&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[174,175]},&quot;v&quot;:&quot;5.2 Web and HTTP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[176,177]},&quot;v&quot;:&quot;一些术语&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[178,179]},&quot;v&quot;:&quot;Web页（Web page）：由一些对象组成&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[180,181]},&quot;v&quot;:&quot;对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[181,182]},&quot;v&quot;:&quot;Web页含有一个基本的HTML文件，该基本HTML文件又包含若干对象的引用（链接）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[183,184]},&quot;v&quot;:&quot;通过URL对每个对象进行引用（addressable）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[185,186]},&quot;v&quot;:&quot;访问协议，用户名，口令字，端口等；&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[187,188]},&quot;v&quot;:&quot;URL格式:&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[191,192]},&quot;v&quot;:&quot;HTTP概况&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[193,194]},&quot;v&quot;:&quot;HTTP: 超文本传输协议（hypertext transfer protocol）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[195,196]},&quot;v&quot;:&quot;Web的应用层协议&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[196,197]},&quot;v&quot;:&quot;客户/服务器模式 （client/server model）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[197,198]},&quot;v&quot;:&quot;客户端: 请求、接收和显示Web对象的浏览器（browser）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[198,199]},&quot;v&quot;:&quot;服务器: 对请求进行响应，发送对象的Web服务器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[199,201]},&quot;v&quot;:&quot;HTTP 1.0: RFC 1945<br>\nHTTP 1.1: RFC 2068&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[202,203]},&quot;v&quot;:&quot;使用TCP:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[204,205]},&quot;v&quot;:&quot;客户发起一个与服务器的TCP连接 (建立套接字) ，端口号为 80&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[205,206]},&quot;v&quot;:&quot;服务器接受客户端的TCP连接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[206,207]},&quot;v&quot;:&quot;在浏览器(HTTP客户端)与 Web服务器(HTTP服务器 server)交换HTTP报文 (应用层协议报文)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[207,208]},&quot;v&quot;:&quot;TCP连接关闭&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[209,210]},&quot;v&quot;:&quot;HTTP是无状态（stateless）的&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[211,212]},&quot;v&quot;:&quot;服务器并不维护关于客户的任何信息&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[213,214]},&quot;v&quot;:&quot;注：维护状态的协议很复杂！&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[219,220]},&quot;v&quot;:&quot;两种类型的HTTP报文：请求request、响应response&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[221,222]},&quot;v&quot;:&quot;HTTP请求报文&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[223,224]},&quot;v&quot;:&quot;HTTP请求报文：ASCII (人能阅读)&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[225,226]},&quot;v&quot;:&quot;HTTP响应报文&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[227,228]},&quot;v&quot;:&quot;用户-服务器状态User-server state: cookies&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[229,230]},&quot;v&quot;:&quot;大多数主要的门户网站（web sites）使用 cookies&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[231,232]},&quot;v&quot;:&quot;4个组成部分：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[233,234]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[233,234],&quot;index&quot;:1},&quot;v&quot;:&quot;1. 在HTTP响应报文中有一个cookie的首部行&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[234,235]},&quot;v&quot;:&quot;2)在HTTP请求报文含有一个cookie的首部行&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[235,236]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[235,236],&quot;index&quot;:3},&quot;v&quot;:&quot;3. 在用户端系统中保留有一个cookie文件，由用户的浏览器(browser)管理&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[236,238]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[236,237],&quot;index&quot;:4},&quot;v&quot;:&quot;4. 在Web站点(Sites)有一个后端(back-edn)数据库&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[238,239]},&quot;v&quot;:&quot;一个栗子&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[244,245]},&quot;v&quot;:&quot;Web缓存caches (代理服务器proxy server)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[246,247]},&quot;v&quot;:&quot;目标：不访问原始服务器，就满足客户的请求&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[247,248]},&quot;v&quot;:&quot;用户设置浏览器： 通过缓存(cache)访问Web&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[248,249]},&quot;v&quot;:&quot;浏览器将所有的HTTP请求发给缓存&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[250,251]},&quot;v&quot;:&quot;在缓存中的对象：缓存直接返回对象&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[251,252]},&quot;v&quot;:&quot;如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[253,254]},&quot;v&quot;:&quot;5.3 FTP 文件传输协议(file transfer protocol)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[255,256]},&quot;v&quot;:&quot;向远程主机上传输文件或从远程主机接收文件&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[257,258]},&quot;v&quot;:&quot;客户/服务器模式&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[259,260]},&quot;v&quot;:&quot;客户端：发起传输的一方&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[260,261]},&quot;v&quot;:&quot;服务器：远程主机&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[262,263]},&quot;v&quot;:&quot;ftp: RFC 959&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[264,265]},&quot;v&quot;:&quot;ftp服务器：端口号为21&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[266,267]},&quot;v&quot;:&quot;FTP: 控制连接与数据连接分开&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[268,269]},&quot;v&quot;:&quot;FTP客户端与FTP服务器通过端口21联系，并指定（specifying）TCP为传输协议&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[269,270]},&quot;v&quot;:&quot;客户端通过控制连接获得身份确认（authorization）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[270,271]},&quot;v&quot;:&quot;客户端通过控制连接发送命令浏览远程目录（remote directory）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[271,272]},&quot;v&quot;:&quot;收到一个文件传输命令时，服务器打开一个到客户端的数据连接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[272,273]},&quot;v&quot;:&quot;一个文件传输完成后，服务器关闭连接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[273,274]},&quot;v&quot;:&quot;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[274,275]},&quot;v&quot;:&quot;服务器打开第二个TCP数据连接用来传输另一个文件&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[275,276]},&quot;v&quot;:&quot;控制连接： 带外（ “out of band”）传送&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[276,277]},&quot;v&quot;:&quot;FTP服务器维护用户的状态信息：当前路径、用户帐户与控制连接对应&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[277,278]},&quot;v&quot;:&quot;有状态&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[279,280]},&quot;v&quot;:&quot;FTP命令、响应&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[281,282]},&quot;v&quot;:&quot;命令commands样例：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[283,285]},&quot;v&quot;:&quot;<strong>在控制连接上以ASCII文本方式传送<br>\nsent as ASCII text over control channel</strong>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[285,286]},&quot;v&quot;:&quot;USER username&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[286,287]},&quot;v&quot;:&quot;PASS password&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[287,288]},&quot;v&quot;:&quot;LIST：请服务器返回远程主机当前目录的文件列表&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[288,289]},&quot;v&quot;:&quot;RETR filename：从远程主机的当前目录检索文件(gets)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[289,290]},&quot;v&quot;:&quot;STOR filename：向远程主机的当前目录存放文件(puts)&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[291,292]},&quot;v&quot;:&quot;返回码return codes样例：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[293,294]},&quot;v&quot;:&quot;<strong>状态码和状态信息（status code and phrase） (同HTTP)</strong>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[294,295]},&quot;v&quot;:&quot;331 Username OK, password required&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[295,296]},&quot;v&quot;:&quot;125 data connection already open; transfer starting&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[296,297]},&quot;v&quot;:&quot;425 Can’t open data connection&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[297,298]},&quot;v&quot;:&quot;452 Error writing file&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[299,300]},&quot;v&quot;:&quot;5.4 Electronic Mail&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[303,304]},&quot;v&quot;:&quot;Electronic Mail3个主要组成部分：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[305,306]},&quot;v&quot;:&quot;用户代理user agents&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[307,308]},&quot;v&quot;:&quot;又名 “邮件阅读器mail reader”&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[308,309]},&quot;v&quot;:&quot;撰写、编辑和阅读邮件（composing, editing, reading mail messages）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[309,310]},&quot;v&quot;:&quot;如., Eudora, Outlook, elm, Netscape Messenger、Foxmail&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[310,311]},&quot;v&quot;:&quot;输出和输入（outgoing, incoming）邮件保存在服务器上&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[312,313]},&quot;v&quot;:&quot;邮件服务器mail servers&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[314,315]},&quot;v&quot;:&quot;邮箱(mailbox)中管理和维护发送给用户的邮件&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[315,316]},&quot;v&quot;:&quot;输出(outgoing)报文队列(message queue)保持待发送邮件报文&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[316,317]},&quot;v&quot;:&quot;邮件服务器之间的SMTP协议：发送email报文&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[318,319]},&quot;v&quot;:&quot;客户：发送方邮件服务器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[319,320]},&quot;v&quot;:&quot;服务器：接收端邮件服务器&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[321,322]},&quot;v&quot;:&quot;简单邮件传输协议：SMTP[RFC 2821]&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[323,324]},&quot;v&quot;:&quot;使用TCP在客户端和服务器之间可靠传送报文，端口号为25&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[325,326]},&quot;v&quot;:&quot;直接传输：从发送方服务器到接收方服务器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[327,328]},&quot;v&quot;:&quot;传输的3个阶段&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[329,330]},&quot;v&quot;:&quot;握手handshaking (greeting)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[330,331]},&quot;v&quot;:&quot;传输报文transfer of messages&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[331,332]},&quot;v&quot;:&quot;关闭closure&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[333,334]},&quot;v&quot;:&quot;命令/响应交互&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[335,336]},&quot;v&quot;:&quot;命令commands：ASCII文本&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[336,337]},&quot;v&quot;:&quot;响应response：状态码和状态信息&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[338,339]},&quot;v&quot;:&quot;报文必须为7位ASCII码&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[340,341]},&quot;v&quot;:&quot;一个栗子&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;ordered_list&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[342,348],&quot;start&quot;:1},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[342,343],&quot;index&quot;:1},&quot;v&quot;:&quot;1. Alice使用用户代理撰写邮件并发送给 bob@someschool.edu 2) Alice的用户代理将邮件发送到她的邮件服务器；邮件放在报文队列中&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[343,344],&quot;index&quot;:2},&quot;v&quot;:&quot;2. SMTP的客户端打开到Bob邮件服务器的TCP连接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[344,345],&quot;index&quot;:3},&quot;v&quot;:&quot;3. SMTP客户端通过TCP连接发送Alice的邮件&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[345,346],&quot;index&quot;:4},&quot;v&quot;:&quot;4. Bob的邮件服务器将邮件放到 Bob的邮箱&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[346,347],&quot;index&quot;:5},&quot;v&quot;:&quot;5. Bob调用他的用户代理阅读邮件&quot;}]},{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:8,&quot;p&quot;:{&quot;lines&quot;:[348,372]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[348,349]},&quot;v&quot;:&quot;简单的SMTP交互&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[365,366]},&quot;v&quot;:&quot;尝试SMTP交互&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[367,368]},&quot;v&quot;:&quot;telnet servername 25&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[368,369]},&quot;v&quot;:&quot;see 220 reply from server&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[369,370]},&quot;v&quot;:&quot;enter HELO, MAIL FROM, RCPT TO, DATA, QUIT commands&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[370,371]},&quot;v&quot;:&quot;上面允许您在不使用电子邮件客户端（阅读器）的情况下发送电子邮件&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[372,373]},&quot;v&quot;:&quot;总结：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[374,377]},&quot;v&quot;:&quot;SMTP使用持久连接<br>\nSMTP要求报文（首部和主体）为7位ASCII编码<br>\nSMTP服务器使用CRLF.CRLF决定报文的尾部&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[377,378]},&quot;v&quot;:&quot;HTTP比较：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[379,384]},&quot;v&quot;:&quot;HTTP：拉（pull）<br>\nSMTP：推（push）<br>\n二者都是ASCII形式的命令/响应交互、状态码<br>\nHTTP：每个对象封装在各自的响应报文中<br>\nSMTP：多个对象包含在一个报文中&quot;}]}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[385,386]},&quot;v&quot;:&quot;邮件报文格式Mail message format&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[387,388]},&quot;v&quot;:&quot;报文格式：多媒体扩展 multimedia extensions&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[389,390]},&quot;v&quot;:&quot;MIME：多媒体邮件扩展（multimedia mail extension）, RFC 2045, 2056&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[390,391]},&quot;v&quot;:&quot;在报文首部用额外的行申明MIME内容类型&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[392,393]},&quot;v&quot;:&quot;邮件访问协议Mail access protocols&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[394,395]},&quot;v&quot;:&quot;SMTP: 传送到接收方的邮件服务器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[395,396]},&quot;v&quot;:&quot;邮件访问协议：从服务器检索（retrieval）邮件&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[397,398]},&quot;v&quot;:&quot;POP：邮局访问协议（Post Office Protocol）[RFC 1939]&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[399,400]},&quot;v&quot;:&quot;授权authorization (代理&amp;lt;--&amp;gt;服务器) 并下载&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[401,402]},&quot;v&quot;:&quot;IMAP：Internet邮件访问协议（Internet Mail Access Protocol）[RFC 1730] （更多特性 (更复杂)）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[403,404]},&quot;v&quot;:&quot;<strong>在服务器上处理存储的报文（远程管理文件夹）</strong>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[404,405]},&quot;v&quot;:&quot;IMAP服务器将每个报文与一个文件夹联系起来&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[405,406]},&quot;v&quot;:&quot;允许用户用目录来组织报文&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[406,407]},&quot;v&quot;:&quot;允许用户读取报文组件&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[407,408]},&quot;v&quot;:&quot;IMAP在会话过程中保留用户状态：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[409,410]},&quot;v&quot;:&quot;目录名、报文ID与目录名之间映射&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[411,412]},&quot;v&quot;:&quot;HTTP：Hotmail , Yahoo! Mail等&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[413,414]},&quot;v&quot;:&quot;方便&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[415,416]},&quot;v&quot;:&quot;POP3协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[417,418]},&quot;v&quot;:&quot;<strong>（本地管理文件夹）</strong>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[418,420]},&quot;v&quot;:&quot;先前的例子使用 “下载并删除”模式。<br>\n（如果改变客户机，Bob不能阅读邮件）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[420,421]},&quot;v&quot;:&quot;“下载并保留”：不同客户机上为报文的拷贝&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[421,422]},&quot;v&quot;:&quot;POP3在会话中是无状态的&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[423,424]},&quot;v&quot;:&quot;5.5 DNS（Domain Name System）域名系统&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[425,426]},&quot;v&quot;:&quot;互联网主机、路由器：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[427,428]},&quot;v&quot;:&quot;IP 地址（32 位） - 用于寻址数据报&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[428,429]},&quot;v&quot;:&quot;“名称”，例如，ww.yahoo.com - 由人类使用&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[430,431]},&quot;v&quot;:&quot;DNS域名系统：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[432,433]},&quot;v&quot;:&quot;分布式数据库distributed database ：在多个名称服务器的层次结构中实现&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[433,434]},&quot;v&quot;:&quot;应用层协议application-layer protocol：主机、路由器、名称服务器，用于通信以解析（resolve）名称（地址/名称转换）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[435,436]},&quot;v&quot;:&quot;注：核心互联网功能，作为应用层协议实现&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[436,437]},&quot;v&quot;:&quot;网络“边缘”的复杂性&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[438,439]},&quot;v&quot;:&quot;DNS的服务&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[440,441]},&quot;v&quot;:&quot;主机名到 IP 地址的转换&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[441,442]},&quot;v&quot;:&quot;主机别名Host aliasing&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[443,444]},&quot;v&quot;:&quot;规范名称和别名Canonical and alias names&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[445,446]},&quot;v&quot;:&quot;邮件服务器别名（aliasing）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[446,447]},&quot;v&quot;:&quot;负载分布Load distribution&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[448,449]},&quot;v&quot;:&quot;复制的(Replicated)Web 服务器：一个规范名称的 IP 地址集&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[450,451]},&quot;v&quot;:&quot;为什么不集中化 DNS？&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[452,453]},&quot;v&quot;:&quot;单点故障single point of failure&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[453,454]},&quot;v&quot;:&quot;流量traffic volume&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[454,455]},&quot;v&quot;:&quot;远程集中式数据库distant centralized database&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[455,456]},&quot;v&quot;:&quot;维护maintenance&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[457,458]},&quot;v&quot;:&quot;分布式分层数据库&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[461,462]},&quot;v&quot;:&quot;DNS: Root name servers&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[463,464]},&quot;v&quot;:&quot;无法解析名称的本地名称服务器联系&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[464,465]},&quot;v&quot;:&quot;根名称服务器：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[466,467]},&quot;v&quot;:&quot;如果名称映射未知，则联系权威名称服务器(authoritative name serve)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[467,468]},&quot;v&quot;:&quot;获取映射mapping&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[468,469]},&quot;v&quot;:&quot;返回到本地名称服务器的映射&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[470,471]},&quot;v&quot;:&quot;TLD and Authoritative Servers(TLD服务器和权威服务器)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[472,473]},&quot;v&quot;:&quot;顶级域服务器（Top-level domain ，TLD servers）：负责顶级域名（如com,org, net,edu和gov）和所有国家级的顶级名（如cn, uk, fr, ca,jp ）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[474,475]},&quot;v&quot;:&quot;Network solutions 公司维护com TLD服务器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[475,476]},&quot;v&quot;:&quot;Educause公司维护edu TLD服务器&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[477,478]},&quot;v&quot;:&quot;Authoritative DNS servers组织的 DNS 服务器，为组织的服务器（例如 Web 和邮件）提供 IP 映射的权威主机名。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[479,480]},&quot;v&quot;:&quot;可由组织或服务提供商维护&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[481,482]},&quot;v&quot;:&quot;本地名字服务器（Local Name Server）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[483,484]},&quot;v&quot;:&quot;并不严格属于层次结构&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[484,485]},&quot;v&quot;:&quot;每个ISP (居民区的ISP、公司、大学）都有一个本地DNS服务器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[485,486]},&quot;v&quot;:&quot;也称为“默认名字服务器”&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[486,487]},&quot;v&quot;:&quot;当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[487,488]},&quot;v&quot;:&quot;起着代理的作用，将查询转发到层次结构中&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[489,490]},&quot;v&quot;:&quot;一个栗子：cis.poly.edu 的主机需要 gaia.cs.umass.edu 的 IP 地址&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[491,492]},&quot;v&quot;:&quot;递归查询recursive query（根服务器的负担太重）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[493,494]},&quot;v&quot;:&quot;名字解析负担都放在当前联络的名字服务器上&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[495,496]},&quot;v&quot;:&quot;迭代查询iterated query&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[497,498]},&quot;v&quot;:&quot;已联系的服务器回复要联系的服务器的名称&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[498,499]},&quot;v&quot;:&quot;“我不知道这个名字，但问这个服务器”&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[500,501]},&quot;v&quot;:&quot;5.6 P2P file sharing（P2P应用）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[502,503]},&quot;v&quot;:&quot;5.7 Socket programming with TCP（TCP套接字编程）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[504,505]},&quot;v&quot;:&quot;5.8 Socket programming with UDP（UDP套接字编程）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[506,507]},&quot;v&quot;:&quot;5.9 Building a Web server&quot;}]}">
</svg></div>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络大作业</title>
    <url>/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/</url>
    <content><![CDATA[<h4 id="【第一题】：通过比较ISO七层模型、模型、和课堂上介绍的五层模型比较计算机网络体系结构，请画出三种体系结构的示意图，并分别描述、比较各层的功能和支持的协议。"><a href="#【第一题】：通过比较ISO七层模型、模型、和课堂上介绍的五层模型比较计算机网络体系结构，请画出三种体系结构的示意图，并分别描述、比较各层的功能和支持的协议。" class="headerlink" title="【第一题】：通过比较ISO七层模型、模型、和课堂上介绍的五层模型比较计算机网络体系结构，请画出三种体系结构的示意图，并分别描述、比较各层的功能和支持的协议。"></a>【第一题】：通过比较ISO七层模型、模型、和课堂上介绍的五层模型比较计算机网络体系结构，请画出三种体系结构的示意图，并分别描述、比较各层的功能和支持的协议。</h4><p>答：三种体系结构的示意图及对应简要功能如下图所示：</p>
<p><img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image002.gif"></p>
<p>七层模型每层相对应的网络协议如下表所示：</p>
<table>
<thead>
<tr>
<th>ISO七层协议模型</th>
<th>对应的协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>HTTP，TFTP，FTP，NFS，WAIS，SMTP，IMAP</td>
</tr>
<tr>
<td>表示层</td>
<td>Telnet，Rlogin，SNMP，Gopher</td>
</tr>
<tr>
<td>会话层</td>
<td>SMTP，DNS</td>
</tr>
<tr>
<td>传输层</td>
<td>TCP，UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>IP，ICMP，ARP，IGMP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>PPP，MAC，TDMA，ARP，CSMA</td>
</tr>
<tr>
<td>物理层</td>
<td>大量IEEE协议</td>
</tr>
</tbody></table>
<p>ISO模型的<strong>应用层</strong>功能为：为计算机用户提供应用接口，也为用户直接提供各种网络服务，是最靠近用户的一层。</p>
<p>ISO模型的<strong>表示层</strong>功能为：提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别，此外还可以进行数据压缩和加密。</p>
<p>ISO模型的<strong>会话层</strong>功能为：负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p>
<p>以上提到的三层应用层、表示层和会话层，在四层和五层结构中被合并为应用层，也就是说在四五层的结构中应用层的功能和涉及的协议为这三层的功能和协议。以下是我的理解：首先，这三层都是处理的相同数据单位的数据，针对相同的数据来回的传输反而非常复杂；其次，如果没有将三层合并，那么应用层“做的事”就非常少，就只是对操作系统进行交互就可以了，层与层之间的封装传输也会浪费一些时间，所以不如将他们合并。</p>
<p><strong>传输层</strong>的功能为：建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的数据通路。</p>
<p><strong>网络层</strong>的功能为：通过IP寻址建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。</p>
<p><strong>数据链路层</strong>的功能为：将比特组合成字节,再将字节组合成帧,使用链路层地址来访问介质,并进行差错检测。ISO模型和五层的<strong>物理层</strong>的功能为：通过物理介质传输比特流。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。</p>
<p>在TCP/IP四层模型中将数据链路层和物理层合并为数据链路层，那么其功能也就是这两个层的合并，接下来是我自己的一些理解：之所以在TCP/IP四层模型中合并了这两个层，是因为对于TCP/IP协议或者说是传输层和网络层来说，物理层是完全透明的，只和应用层和数据链路层进行交互就足够了。</p>
<h4 id="【第二题】：如何理解HTTP协议是无状态的？以登录淘宝购物为例，举例说明有状态的场景、无状态的场景、以及为了解决无状态而引入Cookie之后的场景。"><a href="#【第二题】：如何理解HTTP协议是无状态的？以登录淘宝购物为例，举例说明有状态的场景、无状态的场景、以及为了解决无状态而引入Cookie之后的场景。" class="headerlink" title="【第二题】：如何理解HTTP协议是无状态的？以登录淘宝购物为例，举例说明有状态的场景、无状态的场景、以及为了解决无状态而引入Cookie之后的场景。"></a>【第二题】：如何理解HTTP协议是无状态的？以登录淘宝购物为例，举例说明有状态的场景、无状态的场景、以及为了解决无状态而引入Cookie之后的场景。</h4><p>HTTP协议是无状态的是指协议对于事务处理没有记忆功能。缺少状态意味着，假如后面的处理需要前面的信息，则前面的信息必须重传，这样可能导致每次连接传送的数据量增大。优点是当服务器不需要前面信息时，应答更快。</p>
<p>直观地说，就是每个请求都是<strong>独立的</strong>。在同一个连接中，两个执行成功的请求之间是<strong>没有关系的</strong>。客户端和服务器端都不会保存之前请求或应答的数据或状态，服务器每次处理请求成功后就关闭连接，处理下一个任意的请求，不用管是谁发来的请求。</p>
<p>无状态的场景：用户登录淘宝，<strong>输入用户名和密码</strong>，把登录信息传给服务器，服务器进行业务处理，从底层数据库中判断登录信息正确，传回给用户<strong>登录成功信息</strong>，服务器处理完本次<strong>连接结束</strong>。当用户想要<strong>请求查看历史订单</strong>时，相当于输入查看订单的网址，向服务器<strong>发送请求</strong>，服务器接收到以后并不知道是谁发送的请求，客户端也<strong>没有再次发送登录信息</strong>，服务器端也不知道该返回谁的订单，返回这不是没登录就能查看的，就<strong>返回了登录界面</strong>，用户<strong>再次输入用户名和密码</strong>，服务器<strong>再次处理登录信息</strong>，然后重定向<strong>返回历史订单消息</strong>。也就是说当需要用到登录信息时，服务器都会返回到登录界面才知道是谁请求的，返回谁的数据，这样也可以实现使用，但是需要大量的登录输入信息的操作，并不能让用户满意。</p>
<p>有状态的场景：我的理解为session的机制就类似于这个“状态”，在服务器开辟一段缓存用来存放历史的状态等信息。用户还是登录淘宝，<strong>输入用户名和密码</strong>，把登录信息传给服务器，服务器进行业务处理，从底层数据库中判断登录信息正确，传回给用户<strong>登录成功信息</strong>，服务器处理完本次<strong>连接结束</strong>，但是服务器<strong>记住了这个登录信息</strong>，知道这个客户端发来的请求是请求谁的，这时用户想要<strong>请求查看历史订单</strong>时，相当于输入查看订单的网址，向服务器<strong>发送请求</strong>，服务器就很自然的返回了这个人的订单。</p>
<p>引入cookie之后的场景：我的理解cookie类似于一个客户端的记事本，与session不同的是在客户端维护所谓“状态”。还是用户登录淘宝，<strong>输入用户名和密码</strong>，此时<strong>客户端记住了这个登录需要的用户名和密码</strong>，然后把登录信息传给服务器，服务器进行业务处理，从底层数据库中判断登录信息正确，传回给用户<strong>登录成功信息</strong>，服务器处理完本次<strong>连接结束</strong>，用户想要<strong>请求查看历史订单</strong>时，相当于输入查看订单的网址，<strong>cookie</strong>在头部加上了登录信息<strong>，向服务器</strong>发送请求，服务器解析请求，返回这个人的订单，是每次都重新传了这个信息。</p>
<h4 id="【第三题】：什么是DNS？请以访问淘宝网主页www-taobao-com为例说明DNS的解析过程，并借助图表比较迭代查询和递归查询的区别。"><a href="#【第三题】：什么是DNS？请以访问淘宝网主页www-taobao-com为例说明DNS的解析过程，并借助图表比较迭代查询和递归查询的区别。" class="headerlink" title="【第三题】：什么是DNS？请以访问淘宝网主页www.taobao.com为例说明DNS的解析过程，并借助图表比较迭代查询和递归查询的区别。"></a>【第三题】：什么是DNS？请以访问淘宝网主页<a href="http://www.taobao.com为例说明dns的解析过程,并借助图表比较迭代查询和递归查询的区别./">www.taobao.com为例说明DNS的解析过程，并借助图表比较迭代查询和递归查询的区别。</a></h4><p>DNS(Domain Name System)域名解析服务，最基本的作用就是将用户提供的域名转换成为服务器的地址。</p>
<p>DNS域名解析过程：</p>
<p>①在浏览器中输入<a href="http://www.taobao.com域名,回车请求./">www.taobao.com域名，回车请求。</a></p>
<p>②浏览器检查缓存中有没有域名对应的IP，如果有直接访问。</p>
<p>③在操作系统的hosts文件中有没有配置，如果有直接访问。</p>
<p>④向本地区的DNS域名服务器发起请求，如果能解析直接访问。</p>
<p>⑤到根域名服务器请求解析，根域名服务器返回顶级名称服务器-&gt; com顶级名称服务器请求，顶级名称服务器返回二级名称服务器-&gt; taobao.com二级名称服务器请求-&gt; <a href="http://www.taobao.com/">www.taobao.com</a>权威名称服务器请求，结束后解析的结果返回给用户，客户端缓存在本地系统缓存中</p>
<p>⑥域名解析结束。</p>
<p>以下为迭代查询和递归查询的图表及区别对比表：</p>
<table>
<thead>
<tr>
<th><strong>递归查询：</strong></th>
<th><strong>迭代查询：</strong></th>
</tr>
</thead>
<tbody><tr>
<td><img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image004.jpg"></td>
<td><img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image006.jpg"></td>
</tr>
<tr>
<td>主机向本地域名服务器一般递归查询。</td>
<td>本地域名服务器向根域名服务器使用迭代查询。</td>
</tr>
<tr>
<td>客户端只发一次请求，要求对方给出最终结果，如果对方不能给出就要找能解答这个查询的服务器</td>
<td>客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的服务器</td>
</tr>
<tr>
<td>递归查询时，返回的结果只有：查询成功或查询失败。</td>
<td>迭代查询，返回的是最佳的查询点或者主机地址.</td>
</tr>
</tbody></table>
<p>一个很形象的比喻：</p>
<p>递归查询就像一个“懒惰”的老板，老板想吃冰淇淋，仅需传达给秘书（对于老板而言，去哪里买不需要关心，秘书可以解决）；秘书接到任务，去告诉店员要一个冰淇淋（对秘书来说，仅需传达给店员，不需要知道怎么做；店员会把想要的给他)；店员接到需求，生产出冰淇淋，交给秘书（问题最小单元触发，终止问题分解；向上反馈）；秘书拿到了冰淇淋，跑到公司交给老板（秘书得到结果，经过包装后，向上反馈）；老板拿到了冰淇淋（老板坐在办公室一动没动，得到了想要的东西）。</p>
<p>迭代查询就像一个“亲力亲为”的老板，老板想吃冰淇淋，问秘书怎么可以吃到（对于老板而言，秘书应该可以回答问题）；秘书把老板指向店铺（对于老板，知道了去哪里能买到冰淇淋的线索；对秘书而言，完成了”重定向”，任务就结束了）；老板对店员说，给我冰淇淋（老板把同样的问题问了一遍店员；相同逻辑的重复调用）；店员把冰淇淋递给老板；老板得到了想要的冰淇淋。（店员的任务就是把结果给顾客；而老板也得到了自己想要的）</p>
<h4 id="【第四题】：请在浏览器中访问淘宝网首页，并通过浏览器开发者模式获取此访问的HTTP请求和应答报文，将你获取到的完整报文头部信息截图粘贴于此："><a href="#【第四题】：请在浏览器中访问淘宝网首页，并通过浏览器开发者模式获取此访问的HTTP请求和应答报文，将你获取到的完整报文头部信息截图粘贴于此：" class="headerlink" title="【第四题】：请在浏览器中访问淘宝网首页，并通过浏览器开发者模式获取此访问的HTTP请求和应答报文，将你获取到的完整报文头部信息截图粘贴于此："></a>【第四题】：请在浏览器中访问淘宝网首页，并通过浏览器开发者模式获取此访问的HTTP请求和应答报文，将你获取到的完整报文头部信息截图粘贴于此：</h4><table>
<thead>
<tr>
<th><strong>Response:</strong>  <img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image008.jpg"></th>
<th><strong>Request:</strong>  <img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image010.jpg"></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>请以访问淘宝网主页为例，用图文解释HTTP请求的过程与原理。HTTP的请求方法有哪些？举例说明各自有哪些使用场景？HTTP哪些常用的状态码？举例说明各自有哪些使用场景。</p>
<p>HTTP【请求的过程】如下：</p>
<ol>
<li><p>用户在浏览器输入要请求的url</p>
</li>
<li><p>浏览器向域名服务器申请解析用户输入的url（涉及DNS），具体解析见第三题</p>
</li>
<li><p>浏览器获取目标IP后与服务器进行三次握手建立TCP连接（三次挥手）</p>
</li>
<li><p>TCP连接成功后，浏览器发送请求命令，命令类型包括如下介绍的9种</p>
</li>
<li><p>浏览器发送完请求头信息后，服务器会相应一个状态码，然后开始回送应答HTTP</p>
</li>
<li><p>Web服务器向后端服务器请求业务操作，后端服务器返回实际数据</p>
</li>
<li><p>服务器发送所请求的实际数据</p>
</li>
<li><p>关闭TCP连接（4次挥手），请求结束。图片如下：</p>
</li>
</ol>
<p><img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image012.gif"></p>
<p>​    HTTP的【请求方法及各自的使用场景】：</p>
<p>GET：是最常用的HTTP请求方法，会显示请求指定的资源，并返回响应主体。GET请求可被缓存，会被保留在浏览器历史记录中，可被收藏为书签，不应在处理敏感数据时使用，有长度限制，只应当用于取回数据（不修改）。<strong>比如</strong>，淘宝进行的搜索、查询、页面资源获取都是使用的GET方法。</p>
<p>HEAD：与GET方法一样，都是向服务器发出指定资源的请求，只不过服务器将不传回资源的本文部分，只返回头部消息。使用场景：不需获取资源的时候，了解资源的一些信息；通过查看响应中的状态码，可以确定资源是否存在；通过查看首部，测试资源是否被修改。比如，淘宝中查看我的历史订单就会请求资源状态，请求的方式就是HEAD。</p>
<p>POST：特点几乎与get相对，请求不会被缓存，不会保留在浏览器历史记录中，不能被收藏为书签，对数据长度没有要求。用于向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件），数据被包含在请求本文中。<strong>比如</strong>，登录淘宝需要填写的账号密码，点击登录以后提交表单请求的就是POST方法。</p>
<p>PUT：用于将数据发送到服务器来创建/更新资源。PUT方法是幂等的：调用一次与连续调用多次是等价的（即没有副作用），而POST方法连续调用多次可能会有副作用，<strong>比如</strong>将一个订单重复提交多次。</p>
<p>DELETE：请求服务器删除指定URL所对应的资源。但是，客户端无法保证删除操作一定会被执行，因为HTTP规范允许服务器在不通知客户端的情况下撤销请求。</p>
<p>TRACE：实现沿通向目标资源的路径的消息“回环”测试。</p>
<p>PATCH：用于对资源进行部分修改。</p>
<p>OPTIONS：用于获取目的资源所支持的通信选项。</p>
<p>CONNECT 方法可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel）。</p>
<p>​    HTTP【常用的状态码及各自的使用场景】：状态码共有60余种，此处只写了15种</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述及场景</th>
<th>在淘宝中举例场景</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>请求成功。一般的GET与POST请求都用这个</td>
<td>请求资源都需要，大多数都用</td>
</tr>
<tr>
<td>204</td>
<td>无内容。服务器成功处理，但未返回内容</td>
<td></td>
</tr>
<tr>
<td>206</td>
<td>部分内容。服务器成功处理了部分GET请求</td>
<td>当下载到一半</td>
</tr>
<tr>
<td>301</td>
<td>资源（网页等）被永久转移到其它URL</td>
<td></td>
</tr>
<tr>
<td>302</td>
<td>临时移动。与301类似。但资源只是临时被移动</td>
<td>退出登录重定向时出现，但我没理解为啥会这样，截图在网盘</td>
</tr>
<tr>
<td>304</td>
<td>服务器执行成功，请求资源结果与本地缓存相同</td>
<td>比如刷新网页，部分资源显示</td>
</tr>
<tr>
<td>307</td>
<td>临时重定向。与302类似。使用GET请求重定向</td>
<td></td>
</tr>
<tr>
<td>400</td>
<td>客户端请求的语法错误，服务器无法理解</td>
<td>出错的情况，开发时常见</td>
</tr>
<tr>
<td>401</td>
<td>请求要求用户的身份认证</td>
<td></td>
</tr>
<tr>
<td>402</td>
<td>为将来预留的</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td>请求的资源（网页等）不存在</td>
<td></td>
</tr>
<tr>
<td>500</td>
<td>服务器内部错误，无法完成请求</td>
<td>出错的情况，开发时常见</td>
</tr>
<tr>
<td>501</td>
<td>服务器不支持请求的功能，无法完成请求</td>
<td>出错的情况，开发时常见</td>
</tr>
<tr>
<td>503</td>
<td>服务器暂时的无法处理客户端的请求</td>
<td>出错的情况，开发时常见</td>
</tr>
</tbody></table>
<h4 id="【第五题】：请详细介绍一下TCP的三次握手机制。并通过实例说明TCP握手为什么是三次，为什么不能是两次？不能是四次？"><a href="#【第五题】：请详细介绍一下TCP的三次握手机制。并通过实例说明TCP握手为什么是三次，为什么不能是两次？不能是四次？" class="headerlink" title="【第五题】：请详细介绍一下TCP的三次握手机制。并通过实例说明TCP握手为什么是三次，为什么不能是两次？不能是四次？"></a>【第五题】：请详细介绍一下TCP的三次握手机制。并通过实例说明TCP握手为什么是三次，为什么不能是两次？不能是四次？</h4><p>a)三次握手是指建立一个TCP连接需要客户端和服务器共发送3个包。过程描述如下：</p>
<p>第一次握手(SYN=1,seq=x)：客户端发送一个TCP的SYN标志位为1的包，指明客户端打算连接的服务器的端口，以及自己的初始序号X,保存在包头的序列号字段里。<br> 发送完毕后，客户端进入SYN_SEND状态。</p>
<p>第二次握手(SYN=1,ACK=1,seq=y,ACKnum=x+1)：服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1。服务器端选择自己ISN序列号，放到seq域里，同时将确认序号(AcknowledgementNumber)设置为客户的ISN加1，即X+1。<br> 发送完毕后，服务器端进入SYN_RCVD状态。</p>
<p>第三次握手(ACK=1，ACKnum=y+1)：客户端再次发送确认包(ACK)，SYN标志位为0，ACK标志位为1，并且把服务器发来ACK的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1<br> 发送完毕后，客户端进入ESTABLISHED状态，当服务器端接收到这个包时，也进入ESTABLISHED状态，TCP握手结束。</p>
<p>下图1为课件(ch4 p158)上的有关TCP三次握手的过程：</p>
<table>
<thead>
<tr>
<th><img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image014.gif">  图 1课件上TCP三次握手图示</th>
<th><img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image016.jpg">  图 2课件上2次握手失败场景</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>b)课件中的【两次握手失败场景】如图2所示：第一种情况是半连接的情况，只有服务器维护了连接；第二个场景是旧的数据被当成新的数据接收了，导致错误。可以看出两次握手只能确保单通道是可靠的，而TCP是双工的，需要互相确认都可以发包和收包，所以不能两次握手。</p>
<p>假设【四次握手场景1】：将以上描述的客户端令为A，服务端令为B</p>
<p>①客户端发送同步信号SYN+A的初始序列号</p>
<p>②B确认收到A的同步信号，并记录A的ISN到本地，命名B的ACK序列号</p>
<p>③B发送同步信号SYN+B的初始序列号</p>
<p>④A确认收到B的同步信号，并记录B的ISN到本地，命名A的ACK序列号</p>
<p>显然二三步是可以合并发送一个包的，提高连接的速度和效率，TCP协议需考虑到可靠性和传输效率，所以四次握手是效率更低的。</p>
<p>假设【四次握手场景2】：将三次握手后再多一次服务器发送确认包，其实这样可以一直发送下去，但是三次就已经可以保证两端都是保持连接的了，这样不仅没有必要，而且对于什么时候“握手结束”界定也不够清晰。</p>
<p>综上所述只有三次握手才能满足TCP的要求，实现可靠和高效。</p>
<p>举例：当用户申请访问taobao.com时，先向淘宝的服务器发送一个请求包进入SYN_SEND状态，服务器收到后返回一个确认包应答进入SYN_RCVD状态，客户端收到后再次发送应答包，然后客户端进入ESTAB状态，客户端收到后也进入ESTAB状态。</p>
<h4 id="【第六题】：请详细介绍TCP四次挥手过程，并通过实例说明TCP挥手为什么需要四次呢？另外，TCP四次挥手过程中，为什么需要等待2MSL-才进入CLOSED关闭状态？"><a href="#【第六题】：请详细介绍TCP四次挥手过程，并通过实例说明TCP挥手为什么需要四次呢？另外，TCP四次挥手过程中，为什么需要等待2MSL-才进入CLOSED关闭状态？" class="headerlink" title="【第六题】：请详细介绍TCP四次挥手过程，并通过实例说明TCP挥手为什么需要四次呢？另外，TCP四次挥手过程中，为什么需要等待2MSL,才进入CLOSED关闭状态？"></a>【第六题】：请详细介绍TCP四次挥手过程，并通过实例说明TCP挥手为什么需要四次呢？另外，TCP四次挥手过程中，为什么需要等待2MSL,才进入CLOSED关闭状态？</h4><p>a)TCP四次挥手过程描述如下：</p>
<p>l 第一次挥手(FIN=1，seq=x)：假设客户端想要关闭连接，客户端发送一个FIN标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。<br> 发送完毕后，客户端进入FIN_WAIT_1状态。</p>
<p>l 第二次挥手(ACK=1，ACKnum=x+1)：服务器端确认客户端的FIN包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。<br> 发送完毕后，服务器端进入CLOSE_WAIT状态，客户端接收到这个确认包之后，进入FIN_WAIT_2状态，等待服务器端关闭连接。</p>
<p>l 第三次挥手(FIN=1，seq=y)：服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN置为1。<br> 发送完毕后，服务器端进入LAST_ACK状态，等待来自客户端的最后一个ACK。</p>
<p>l 第四次挥手(ACK=1，ACKnum=y+1)：客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入TIME_WAIT状态，等待可能出现的要求重传的ACK包。<br> 服务器端接收到这个确认包之后，关闭连接，进入CLOSED状态。</p>
<p>l 客户端等待了2MSL之后，没有收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入CLOSED状态。</p>
<table>
<thead>
<tr>
<th>课件中关于四次挥手(ch4 p161)的图片如下：  <img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image018.jpg"></th>
<th>举例：比如客户端请求断开TCP连接，发出请求后进入FIN_WAIT_1状态（一次挥手）；服务端接到后发送确认包，但是自己还没准备好进入关闭状态，进入CLOSE_WAIT状态，客户端收到后进入FIN_WAIT_2状态（二次挥手）；服务端准备好关闭时，给客户端发送FIN包，自己进入LAST_ACK状态，客户端收到后TIME_WAIT状态（三次挥手）；客户端发送一个确认包，服务端收到后进入CLOSED状态，客户端发送确认包后再过两个最大段生命周期后进入CLOSED状态。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>四次挥手把同意对方请求跟自身请求分离开。是因为在客户端请求断开时，服务器可能还有数据未发完，所以需要分开操作：先同意对方关闭连接，对方无法传输数据（第二次挥手）；自己若还有数据未发送完，接着发送直至全部发送完毕，请求自身关闭连接（第三次挥手），所以最终是四次挥手。</p>
<p>【等待2MSL,才进入CLOSED关闭状态原因】：考虑的是上述中的服务器端没有收到客户端进入TIMED_WAIT状态时发送的确认包的情况。服务器端会在自己LAST_ACK状态发送FIN包开始计时，如果2MSL之后还没有收到客户端的确认包就会重新发送自己的FIN包（超时重传），就视为客户端没有收到，而真实情况是有可能客户端收到了但是发来的确认包丢失，而如果服务器端重新发送的FIN就会在在客户端进入TIMED_WAIT状态后的2MSL之内到达客户端，客户端这个时候就可以知道服务器端没有收到自己的确认包重新发送，直到服务器端不再继续向客户端发送FIN包。</p>
<h4 id="【第七题】：与UDP相比，TCP提供了可靠传输、流量控制和拥塞控制等服务。TCP协议是如何保证可靠传输的？谈谈你对停止等待协议、ARQ协议和滑动窗口协议的理解？"><a href="#【第七题】：与UDP相比，TCP提供了可靠传输、流量控制和拥塞控制等服务。TCP协议是如何保证可靠传输的？谈谈你对停止等待协议、ARQ协议和滑动窗口协议的理解？" class="headerlink" title="【第七题】：与UDP相比，TCP提供了可靠传输、流量控制和拥塞控制等服务。TCP协议是如何保证可靠传输的？谈谈你对停止等待协议、ARQ协议和滑动窗口协议的理解？"></a>【第七题】：与UDP相比，TCP提供了可靠传输、流量控制和拥塞控制等服务。TCP协议是如何保证可靠传输的？谈谈你对停止等待协议、ARQ协议和滑动窗口协议的理解？</h4><p>TCP保证可靠传输的手段：</p>
<p>l TCP连接的每一端都设有两个窗口——一个发送窗口和一个接收窗口。</p>
<p>l TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p>
<p>l TCP的可靠传输机制用字节的序号进行控制，所有的确认都是基于序号而不是报文段。</p>
<p>l TCP在IP不可靠服务的基础上建立了rdt，手段包括管道化的报文段（GBN/SR）、累计确认（GBN）、单个重传定时器（超时重传）</p>
<p>l TCP的接收端会丢弃重复的数据。</p>
<p>l 校验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果有差错，就丢弃这个报文段和不确认收到此报文段。</p>
<p>l 流量控制：TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。</p>
<p>l 拥塞控制：当网络拥塞时，减少数据的发送。</p>
<p>ARQ（自动重传）协议：有很多种类，是指无需接收方请求发送方重传某个出错分组就可以有重传行为的一类协议，包括停止等待ARQ，回退N步ARQ（滑动窗口协议）、选择重传ARQ协议，只是用不同的原理实现可靠。</p>
<p>停止等待协议：发送方设置超时计时器，每次发送完一个分组就开始计时，暂时保存副本，等待确认分组，确认分组收到后再传输下一个，超时计时器到时间就视为对方没有收到分组，就进行重传，如果收到了迟到的确认也什么都不做。此方式信道利用率很低等待时间长，优点是实现容易。是最简单的ARQ协议。</p>
<p>滑动窗口协议：发送方设置超时计时器，发送方需要维持窗口，接收方只需一个缓存单元，接收方采用累计确认——只发送顺序接受的最高序号的分组，当收到乱序的分组进行丢弃（接收方不进行缓存），很可能会产生重复的ACK；发送方每发送一个分组就开始计时，当计时器时间到了还没有收到这个分组或这个分组以后的ACK，就将窗口内这个分组之后的所有分组都进行重传。优点是简单，所需资源少（接收方只维持一个窗口）；缺点是一旦出错，回退N步（重传这个以后的所有分组）代价更大，适用于出错少没必要使用复杂的SR的情况。</p>
<h4 id="【第八题】：做到这道题目，你突然发现网络变慢，所以你想通过ICMP协议做一些简单的网络诊断。"><a href="#【第八题】：做到这道题目，你突然发现网络变慢，所以你想通过ICMP协议做一些简单的网络诊断。" class="headerlink" title="【第八题】：做到这道题目，你突然发现网络变慢，所以你想通过ICMP协议做一些简单的网络诊断。"></a>【第八题】：做到这道题目，你突然发现网络变慢，所以你想通过ICMP协议做一些简单的网络诊断。</h4><p>首先你要查看本机网络适配器的全部配置信息，请在console中完成此任务，并将结果截图（需包含完整console边框）粘贴于此：</p>
<p><img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image020.jpg"></p>
<p>接下来，在console内继续进行本机回路测试，请将结果截图（需包含完整console边框）粘贴于此：</p>
<p><img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image022.jpg"></p>
<p>在确定本机回路畅通后，你又使用相同的命令对淘宝网主页进行了连通性测试，请将结果截图（需包含完整console边框）粘贴于此：</p>
<p><img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image024.jpg"></p>
<p>比较本机回路测试和远程主机连通性测试的结果，你都有哪些发现？</p>
<p>【不同点】</p>
<p>l 显然可以看到本机回路测试的往返行程的估计时间都是0ms，本机回路没有经过路由器，淘宝的往返行程估计时间要更长。</p>
<p>l 本机回路测试的TTL=128，而淘宝的TTL=56，TTL是由发送主机设置的，以防止数据包不断在IP互联网络上永不终止地循环，可以由此推断出发送的主机操作系统（未被修改的），本机回路测试中TTL=128（Windows系统设置）-0（经过路由器个数），ping淘宝时的TTL=64（LINUX设置的）-11（经过路由器个数）</p>
<p>l 两次连接的目标主机不同，一个是本机127.0.0.1，一个是42.7.26.213。</p>
<p>【相同点】</p>
<p>l 两次无论是哪次的发送和接收数据都是32字节，说明本机回路和远程淘宝服务器都是可以连接的，且丢失率都为0%。</p>
<h4 id="【第九题】：确定链路连通正常后，你猜测网络卡顿可能是由于路由延迟产生的，那么接下来你将通过console命令对路由信息进行测试。"><a href="#【第九题】：确定链路连通正常后，你猜测网络卡顿可能是由于路由延迟产生的，那么接下来你将通过console命令对路由信息进行测试。" class="headerlink" title="【第九题】：确定链路连通正常后，你猜测网络卡顿可能是由于路由延迟产生的，那么接下来你将通过console命令对路由信息进行测试。"></a>【第九题】：确定链路连通正常后，你猜测网络卡顿可能是由于路由延迟产生的，那么接下来你将通过console命令对路由信息进行测试。</h4><p>首先，请显示本机路由表信息，将结果截图（需包含完整console边框）粘贴于此：</p>
<p><img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image026.jpg"></p>
<p>接下来，你要探测从本机到淘宝网服务器的路由信息，请将结果截图（需包含完整console边框）粘贴于此：</p>
<p><img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image028.jpg"></p>
<p>这时，你发现淘宝网上没有找到你想找的东西，想要再去ebay（<a href="http://www.ebay.com）逛一逛，请探测本机到ebay服务器的路由信息，并将结果截图（需包含完整console边框）粘贴于此：">www.ebay.com）逛一逛，请探测本机到ebay服务器的路由信息，并将结果截图（需包含完整console边框）粘贴于此：</a></p>
<p><img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image030.jpg"></p>
<p>请观察两次路由探测的结果，分析其中的异同点：</p>
<p>【相同点】</p>
<p>第一次和第二次的第一个路由和第二个路由的IP相同，时间也差不多，经过查询第一个路由是和本地在同一个局域网下的，第二个路由是联通代理商在这个地区的局域路由。</p>
<p>【不同点】</p>
<p>第二次从3-&gt; 4的时间变慢，经过查询是归属地出市了的原因，3是在本市的（辽宁锦州），4在省会（辽宁沈阳）。</p>
<p>第二次从8-&gt; 9后时间突然再次变慢，在IP地址查询工具查询得知8为中国 联通骨干网，9的归属地就在美国了，可以看出路由转发到了国外，且速度变慢，说明距离更远的服务器会更慢一点，是受物理因素制约的；而淘宝的路由跟踪的IP都是辽宁省（也是在辽宁请求访问的）内的，所以自然就更快一些。</p>
<p>而第一次的路由探测时间几乎没有特别慢的，因为目标IP就在省内。</p>
<p>淘宝的路由探测有一次是请求超时的。</p>
<h4 id="【第十题】：这时，细心的你可能会发现，访问淘宝网的URL协议并不是我们常见的HTTP，而是HTTPS。那么，什么是HTTPS？HTTPS与HTTP的区别何在？请用借助图表描述HTTPS的实现流程。"><a href="#【第十题】：这时，细心的你可能会发现，访问淘宝网的URL协议并不是我们常见的HTTP，而是HTTPS。那么，什么是HTTPS？HTTPS与HTTP的区别何在？请用借助图表描述HTTPS的实现流程。" class="headerlink" title="【第十题】：这时，细心的你可能会发现，访问淘宝网的URL协议并不是我们常见的HTTP，而是HTTPS。那么，什么是HTTPS？HTTPS与HTTP的区别何在？请用借助图表描述HTTPS的实现流程。"></a>【第十题】：这时，细心的你可能会发现，访问淘宝网的URL协议并不是我们常见的HTTP，而是HTTPS。那么，什么是HTTPS？HTTPS与HTTP的区别何在？请用借助图表描述HTTPS的实现流程。</h4><p>答：HTTPS在HTTP上构建SSL加密层，并对传输的数据进行加密。它是HTTP协议的安全版本。HTTPS的主要功能为：加密数据并建立信息安全通道，以确保传输过程中的数据安全；验证网站服务器的真实身份。区别共总结出六条，如下：</p>
<p>①HTTPS基于传输层，HTTP基于应用程序层;</p>
<p>②HTTP明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP）数据传输过程是加密的，安全性较好;</p>
<p>③HTTPS协议需要到CA申请证书;</p>
<p>④HTTP页面响应速度比HTTPS快;</p>
<p>⑤HTTP用的端口是 80，HTTPS是 443;</p>
<p>⑥HTTPS是建构在 SSL/TLS之上的HTTP协议，所以HTTPS更耗费服务器资源。</p>
<p>HTTPS的实现流程如下图所示：</p>
<p><img src="/2023/01/29/ji-suan-ji-wang-luo-da-zuo-ye/clip_image032.gif"></p>
<p>实现流程的描述如下：</p>
<p>1.客户端发起HTTPS请求：（用户在浏览器里输入一个https网址，申请连接）</p>
<p>2.有证书的服务端生成本次的私钥和公钥：私钥自己保存，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。</p>
<p>3.服务端对请求进行响应，向客户端发送数字证书（包括本次的公钥）</p>
<p>4.客户端解析证书，然后生成随机码KEY，并通过公钥进行加密。</p>
<p>5.传送加密后的随机码KEY：目的是让服务端得到这个随机值，之后客户端和服务端的通信就通过这个随机值来进行加密解密了。</p>
<p>6.服务端用私钥解密，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密传输，也就是使用同一个“加密暗号”。</p>
<p>7.服务端传输加密后的信息</p>
<p>8.客户端解密信息，并循环7、8两步，直到断开连接。</p>
]]></content>
      <categories>
        <category>作业</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>进程、线程复习篇</title>
    <url>/2023/02/04/jin-cheng-xian-cheng-fu-xi-pian/</url>
    <content><![CDATA[<h3 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h3><ul>
<li>进程是执行程序的一次<strong>执行过程</strong>，是一个动态的概念，是系统<strong>分配资源</strong>的基本单位</li>
<li>一个进程可以包含若干个线程，线程是<strong>CPU调度和执行的单位</strong></li>
</ul>
<p><strong>程序</strong>是指令、数据及其组织形式的描述，进程是<strong>程序</strong>的实体。</p>
<p>每个线程有自己<strong>独立</strong>的<strong>虚拟机栈、程序计数器</strong></p>
<p>多个线程<strong>共享</strong>同一个进程中的结构：<strong>方法区、堆</strong></p>
<p><img src="/2023/02/04/jin-cheng-xian-cheng-fu-xi-pian/v2-2cdedcdf752a00bafc1ee9d9901580c0_r.jpg" alt="JVM结构体系"></p>
<p>单核CPU和多核CPU的理解：</p>
<ul>
<li>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程 的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费 才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以 把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时 间单元特别短，因此感觉不出来。</li>
<li>多核才能更好的发挥多线程的效率。（现在的服务器都是多核的）</li>
</ul>
<p>Java应用程序至少3个线程：</p>
<ul>
<li>main()主线程</li>
<li>gc()垃圾回收线程（典型的守护线程，如果JVM中只有守护线程，那么将退出）</li>
<li>异常处理线程</li>
</ul>
<p>并行与并发：</p>
<p>并行：多个CPU同时执行多个任务。多个人做多件事。</p>
<p>并发：一个CPU(采用时间片)同时执行多个任务。一个人做多件事。</p>
<h3 id="2-创建线程的方式："><a href="#2-创建线程的方式：" class="headerlink" title="2.创建线程的方式："></a>2.创建线程的方式：</h3><h4 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h4><ol>
<li>定义子类继承Thread类</li>
<li>子类中<strong>重写Thread类中的run方法</strong></li>
<li>创建Thread子类对象，即创建了线程对象</li>
<li>调用线程对象start方法：启动线程，调用run方法。</li>
</ol>
<p>注意：</p>
<ul>
<li>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式</li>
<li>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU 调度决定</li>
<li>想要启动多线程，必须调用start方法</li>
<li>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常“IllegalThreadStateException”，如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start()方法</li>
</ul>
<h4 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口:"></a>方式二：实现Runnable接口:</h4><ol>
<li>创建一个实现了Runnable接口的类</li>
<li>实现类去<strong>实现Runnable中的抽象方法</strong>: run()</li>
<li>创建实现类的对象</li>
<li>将<strong>此对象作为参数传递</strong>到Thread类的构造器中，创建Thread类的对象</li>
<li>通过Thread类的对象调用start()</li>
</ol>
<p>比较创建线程的两种方式：</p>
<p>开发中：优先选择实现Runnable接口的方式。原因如下:</p>
<ol>
<li>实现的方式没有类的<strong>单继承性的局限</strong>性</li>
<li>实现的方式更适合来处理<strong>多个线程</strong>有<strong>共享数据</strong>的情况。</li>
</ol>
<p>联系：<code>public class Thread extends Object implements Runnable</code></p>
<p>相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中，这两种方式要想启动线程，都要调用Thead类中的start()方法</p>
<h4 id="方法三：实现Callable接口：–-gt-JDK5-0以后新增的"><a href="#方法三：实现Callable接口：–-gt-JDK5-0以后新增的" class="headerlink" title="方法三：实现Callable接口：–>JDK5.0以后新增的"></a>方法三：实现Callable接口：–&gt;JDK5.0以后新增的</h4><ol>
<li><p>借助FutureTask执行</p>
<p>FutureTask类同时实现了两个接口，Future和Runnable接口，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//定义实现Callable接口的的实现类重写call方法。</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallableTask</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
           <span class="token comment">//TODO 线程执行方法</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token comment">//创建Callable对象</span>
<span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> mycallabletask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//开始线程</span>
<span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> futuretask<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>mycallabletask<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futuretask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
通过futuretask可以得到<span class="token class-name">MyCallableTask</span>的<span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的运行结果：
futuretask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</li>
<li><p>借助线程池来运行</p>
<ul>
<li>线程池中执行Callable任务原型：</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>
    <span class="token comment">//提交一个Callable任务，返回值为一个Future类型</span>
    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
        <span class="token comment">//other methods...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>借助线程池来运行Callable任务的一般流程为</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> exec <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> exec<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCallableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>​		通过future可以得到MyCallableTask的call()的运行结果： future.get();</p>
</li>
</ol>
<h5 id="Runnable和Callable的区别："><a href="#Runnable和Callable的区别：" class="headerlink" title="Runnable和Callable的区别："></a>Runnable和Callable的区别：</h5><ul>
<li>1、Callable规定的方法是call(),Runnable规定的方法是run().</li>
<li>2、Callable的任务执行后可返回值（支持泛型的返回值），而Runnable的任务是不能返回值的</li>
<li>3、call方法可以抛出异常，run方法不可以</li>
<li>4、运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
</ul>
<h5 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h5><ul>
<li>Future是一个接口，代表了一个异步计算的结果。接口中的方法用来检查计算是否完成、等待完成和得到计算的结果。</li>
<li>当计算完成后，只能通过get()方法得到结果，get方法会阻塞直到结果准备好了。</li>
<li>如果想取消，那么调用cancel()方法。其他方法用于确定任务是正常完成还是取消了。</li>
<li>一旦计算完成了，那么这个计算就不能被取消。</li>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是 否完成、获取结果等。</li>
</ul>
<h5 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h5><ul>
<li>FutureTask类实现了RunnableFuture接口，而RunnnableFuture接口继承了Runnable和Future接口，所以说FutureTask是一个提供异步计算的结果的任务。</li>
<li>FutureTask可以用来包装Callable或者Runnbale对象。因为FutureTask实现了Runnable接口，所以FutureTask也可以被提交给Executor（如上面例子那样）。</li>
<li>FutrueTask是Futrue接口的唯一的实现类</li>
</ul>
<h4 id="方法四：使用线程池"><a href="#方法四：使用线程池" class="headerlink" title="方法四：使用线程池"></a>方法四：使用线程池</h4><ul>
<li><p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程， 对性能影响很大。</p>
</li>
<li><p>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完 放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交 通工具。</p>
</li>
<li><p>好处：</p>
<ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建） </li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ul>
</li>
<li><p>线程池相关的API：ExecutorService 和 Executors</p>
</li>
<li><p>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor</p>
<ul>
<li>void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行 Runnable</li>
<li>Future submit(Callable task)：执行任务，有返回值，一般又来执行 Callable</li>
<li>void shutdown() ：关闭连接池</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池<ul>
<li>Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池</li>
<li>Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池</li>
<li>Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池</li>
<li>Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运 行命令或者定期地执行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Java的调度方法</p>
<ul>
<li>同优先级线程组成先进先出队列（先到先服务），使用<strong>时间片</strong>策略</li>
<li>对高优先级，使用优先调度的抢占式策略</li>
</ul>
<p>注：</p>
<ul>
<li><p>线程创建时继承父线程的优先级</p>
</li>
<li><p>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用</p>
</li>
</ul>
<h3 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3.线程的生命周期"></a>3.线程的生命周期</h3><p>jdk5.0之前：</p>
<p><img src="/2023/02/04/jin-cheng-xian-cheng-fu-xi-pian/image-20230204201241175.png" alt="线程的生命周期"></p>
<p>suspend()方法可能死锁，所以不使用，resume()与其搭配，所以也过时啦</p>
<p>stop():一旦执行，线程就结束了，导致run()有未执行结束的代码。stop()会导致释放同步监视器，导致线程安全问题。（不推荐使用）</p>
<p>suspend(): 与resume()搭配使用，导致死锁。（不推荐使用）</p>
<p>jdk5.0之后：</p>
<p><img src="/2023/02/04/jin-cheng-xian-cheng-fu-xi-pian/image-20230227151448989.png"></p>
<h3 id="4-线程的同步"><a href="#4-线程的同步" class="headerlink" title="4.线程的同步"></a>4.线程的同步</h3><p>Java对于多线程的安全问题提供了专业的解决方式：同步机制</p>
<p>如何解决线程同步问题</p>
<h4 id="方法一：同步代码块"><a href="#方法一：同步代码块" class="headerlink" title="方法一：同步代码块"></a>方法一：同步代码块</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>对象<span class="token operator">/</span>同步监视器<span class="token punctuation">)</span><span class="token punctuation">{</span> 
	<span class="token comment">// 需要被同步的代码</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>说明:</p>
<ol>
<li>操作共享数据的代码，即为需要被同步的代码。–&gt;不能包含代码多了，也不能包含代码少了。</li>
<li><strong>共享数据</strong>:多个线程共同操作的变量。比如: ticket就是共享数据。</li>
<li><strong>同步监视器</strong>,俗称:锁。任何一个类的对象，都可以充当锁。<br>要求:多个线程必须要共用同一把锁。</li>
</ol>
<p>补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。<br>在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。</p>
<h4 id="方法二：synchronized还可以放在方法声明中，表示整个方法为同步方法。-例如："><a href="#方法二：synchronized还可以放在方法声明中，表示整个方法为同步方法。-例如：" class="headerlink" title="方法二：synchronized还可以放在方法声明中，表示整个方法为同步方法。 例如："></a>方法二：synchronized还可以放在方法声明中，表示整个方法为同步方法。 例如：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> show <span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//非静态方法锁的是this（当前对象）</span>
    <span class="token comment">//静态方法锁的是class</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</p>
<p>关于同步方法的总结:</p>
<ul>
<li>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</li>
<li>非静态的同步方法,同步监视器是: this<br>静态的同步方法，同步监视器是:当前类本身</li>
</ul>
<h4 id="方法三：Lock锁——JDK5-0新增"><a href="#方法三：Lock锁——JDK5-0新增" class="headerlink" title="方法三：Lock锁——JDK5.0新增"></a>方法三：Lock锁——JDK5.0新增</h4><p>ReentrantLock，意思是“可重入锁”。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReenTrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
        	<span class="token comment">//保证线程安全的代码;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">finally</span><span class="token punctuation">{</span>
        	lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a>synchronized 与 Lock 的对比</h5><ol>
<li>Lock是显式锁（<strong>手动开启和关闭锁</strong>，别忘记关闭锁），synchronized是 <strong>隐式锁</strong>，出了作用域<strong>自动释放</strong></li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有 更好的扩展性（提供更多的子类）</li>
</ol>
<p>优先使用顺序： Lock＞ 同步代码块（已经进入了方法体，分配了相应资源） ＞ 同步方法 （在方法体之外）</p>
<h5 id="释放锁的操作"><a href="#释放锁的操作" class="headerlink" title="释放锁的操作"></a>释放锁的操作</h5><ul>
<li>当前线程的同步方法、同步代码块执行结束。</li>
<li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、 该方法的继续执行。</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线 程暂停，并释放锁。</li>
</ul>
<h5 id="不会释放锁的操作"><a href="#不会释放锁的操作" class="headerlink" title="不会释放锁的操作"></a>不会释放锁的操作</h5><ul>
<li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、 Thread.yield()方法暂停当前线程的执行</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。<ul>
<li>应尽量避免使用suspend()和resume()来控制线程</li>
</ul>
</li>
</ul>
<h3 id="5-线程的通信"><a href="#5-线程的通信" class="headerlink" title="5.线程的通信"></a>5.线程的通信</h3><h4 id="wait-与-notify-和-notifyAll"><a href="#wait-与-notify-和-notifyAll" class="headerlink" title="wait() 与 notify() 和 notifyAll()"></a>wait() 与 notify() 和 notifyAll()</h4><ul>
<li>wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当 前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有 权后才能继续执行。</li>
<li>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待</li>
<li>notifyAll ()：唤醒正在排队等待资源的所有线程结束等待</li>
</ul>
<p>这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报 java.lang.IllegalMonitorStateException异常。</p>
<p>因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁， 因此这三个方法只能在<strong>Object类</strong>中声明。</p>
<p>三个方法的调用者必须是同步代码块或同步方法中的同步监视器。</p>
<p>wait():线程一旦执行此方法，就进入等待状态。同时，会释放对同步监视器的调用</p>
<p>notify():一旦执行此方法，就会唤醒被wait()的线程中优先级最高的那一个线程。(如果被wait()的多个线程的优先级相同，则<br>随机唤醒一个）。被唤醒的线程从当初被wait的位置继续执行。</p>
<p>notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。</p>
<h4 id="sleep-和wait-方法的异同："><a href="#sleep-和wait-方法的异同：" class="headerlink" title="sleep()和wait()方法的异同："></a>sleep()和wait()方法的异同：</h4><ol>
<li>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</li>
<li>不同点：<ol>
<li>两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</li>
<li>调用的范围不同：sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码块或同步方法中</li>
<li>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁</li>
</ol>
</li>
</ol>
<h3 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6.死锁"></a>6.死锁</h3><ol>
<li>如何看待死锁?</li>
</ol>
<p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。我们编写程序时，要避免出现死锁。</p>
<ol start="2">
<li>诱发死锁的原因?</li>
</ol>
<p>互斥条件<br>占用且等待<br>不可抢夺（或不可抢占) 循环等待<br>以上4个条件，同时出现就会触发死锁。</p>
<ol start="3">
<li>如何避免死锁?</li>
</ol>
<p>针对条件1:互斥条件基本上无法被破坏。因为线程需要通过互斥解决安全间题。</p>
<p>针对条件2:可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。</p>
<p>针对条件3:占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。</p>
<p>针对条件4:可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。</p>
<p>本文绝大部分来源为尚硅谷课件</p>
]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章、网络层</title>
    <url>/2023/01/11/di-san-zhang-wang-luo-ceng/</url>
    <content><![CDATA[<h1 id="第三章、网络层"><a href="#第三章、网络层" class="headerlink" title="第三章、网络层"></a>第三章、网络层</h1><p>这章很重要！！要好好学尼</p>
<h2 id="3-1介绍"><a href="#3-1介绍" class="headerlink" title="3.1介绍"></a>3.1介绍</h2><h3 id="网络层在主机和路由器实现，交换机无"><a href="#网络层在主机和路由器实现，交换机无" class="headerlink" title="网络层在主机和路由器实现，交换机无"></a>网络层在主机和路由器实现，交换机无</h3><h3 id="网络层的关键功能"><a href="#网络层的关键功能" class="headerlink" title="网络层的关键功能"></a>网络层的关键功能</h3><ul>
<li>转发forwarding</li>
<li>路由routing（选路）</li>
</ul>
<h3 id="网络层分为"><a href="#网络层分为" class="headerlink" title="网络层分为"></a>网络层分为</h3><ul>
<li><p>数据平面data plane</p>
<ul>
<li>本地的，每个路由都提供的功能</li>
<li>决定如何将路由器输入端口的数据报转发到输出端口</li>
<li>转发功能（通过判断到达数据报的头部就可以决定）</li>
</ul>
</li>
<li><p>控制平面control plane</p>
<ul>
<li><p>network-wide logic网络范围的逻辑</p>
</li>
<li><p>决定数据报如何选择从哪个端口输出能到达目标主机</p>
</li>
<li><p>两个控制平面实现方法</p>
<ul>
<li>传统路由算法（每个路由器配置自己的算法）eg.Dijkstra算法</li>
<li>software-defined networking (SDN)全网实现，将硬件软件网络软件化（数据平面与控制平面分离</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="网络服务模式Network-service-model"><a href="#网络服务模式Network-service-model" class="headerlink" title="网络服务模式Network service model"></a>网络服务模式Network service model</h3><ul>
<li><p>单个数据报（individual datagrams）的服务</p>
<ul>
<li>保证安全</li>
<li>保证不太慢less than 40 msec delay</li>
</ul>
</li>
<li><p>数据报流（a flow of datagrams）的服务</p>
<ul>
<li>有序的数据报传输</li>
<li>保证最小流量带宽</li>
<li>对数据包间距更改的限制</li>
</ul>
</li>
</ul>
<h2 id="3-2虚拟电路（VC）和数据报电路网络"><a href="#3-2虚拟电路（VC）和数据报电路网络" class="headerlink" title="3.2虚拟电路（VC）和数据报电路网络"></a>3.2虚拟电路（VC）和数据报电路网络</h2><p>Virtual circuit and  datagram networks</p>
<h3 id="类似传输层服务，但服务面向host-to-host"><a href="#类似传输层服务，但服务面向host-to-host" class="headerlink" title="类似传输层服务，但服务面向host to host"></a>类似传输层服务，但服务面向host to host</h3><ul>
<li>网络只提供其中一种，所以没得选</li>
<li>实现在网络核心core（链路层为端口到端口）</li>
</ul>
<h3 id="虚拟电路网络（简写为VC）"><a href="#虚拟电路网络（简写为VC）" class="headerlink" title="虚拟电路网络（简写为VC）"></a>虚拟电路网络（简写为VC）</h3><ul>
<li><p>提供网络层连接的服务</p>
</li>
<li><p>提供类似电路的服务</p>
<ul>
<li>呼叫设置，在数据流动之前对每个呼叫进行拆解（teardown）</li>
<li>每个数据包都带有 VC 标识符（identifier）（不是目标主机地址）</li>
<li>source-dest路径上的每个路由器都为每个通过的连接维护（maintains）”状态”（建立连接后保持独享）</li>
<li>链路，路由器资源（带宽、缓冲区）可以分配（allocated）给 VC</li>
</ul>
</li>
<li><p>VC实现</p>
<ul>
<li><p>包含</p>
<ul>
<li>从源到目标的路径</li>
<li>VC 编号，沿路径的每个链路对应一个编号，属于VC的数据包都带有（新的编号来自转发表）</li>
<li>沿路径的路由器转发表（forwarding tables ）中的条目（Entries）</li>
</ul>
</li>
<li><p>信令（signaling）协议</p>
<ul>
<li>used to setup, maintain teardown VC</li>
<li>步骤：（包含端到端的状态，呼叫后预留）</li>
<li>用在ATM, frame-relay, X.25</li>
<li>现在不用了</li>
</ul>
</li>
</ul>
</li>
<li><p>ATM适合，对时序要求很高，需保证服务，终端很笨（“dumb” end systems哑终端）</p>
</li>
</ul>
<h3 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h3><ul>
<li>提供网络层无连接的服务</li>
<li>在网络层无建立连接</li>
<li>路由器：没有关于端到端连接的状态（无网络级连接概念）不维护端与端之间的通信，只管转</li>
<li>用目标主机地址转发的数据包（同一源-目标端的数据包可能有不同的路径）</li>
<li>Internet适合，终端处理能力强，对信道要求不高，“弹性elastic”服务</li>
</ul>
<h2 id="3-3路由器"><a href="#3-3路由器" class="headerlink" title="3.3路由器"></a>3.3路由器</h2><p>通用路由器体系结构</p>
<h3 id="Input-port-functions"><a href="#Input-port-functions" class="headerlink" title="Input port functions"></a>Input port functions</h3><ul>
<li><p>destination-based forwarding: forward based only on destination IP address (traditional)</p>
<ul>
<li><p>最长前缀匹配Longest prefix matching ppt25</p>
<ul>
<li>通常使用三元内容可寻址存储器（ternary content addressable memories TCAMs）执行（content addressable: present address to TCAM: retrieve address in one clock cycle, regardless of table size）</li>
<li>Cisco Catalyst: can up ~1M routing table entries in TCAM</li>
</ul>
</li>
</ul>
</li>
<li><p>generalized forwarding: forward based on any set of header field values</p>
</li>
</ul>
<h3 id="Input-port-queuing"><a href="#Input-port-queuing" class="headerlink" title="Input port queuing"></a>Input port queuing</h3><ul>
<li>线头阻塞Head-of-the-Line blocking (HOL) :队列前面的排队数据报阻止队列中的其他数据报向前移动</li>
</ul>
<h3 id="三种类型交换结构switching-fabrics"><a href="#三种类型交换结构switching-fabrics" class="headerlink" title="三种类型交换结构switching fabrics"></a>三种类型交换结构switching fabrics</h3><p>（将数据包从输入缓冲区传输到适当的输出缓冲区）</p>
<ul>
<li><p>交换速率：数据包从输入传输到输出的速率</p>
<ul>
<li>通常测量为输入/输出线速的倍数</li>
<li>N 个输入：开关速率 N 倍于线性速率</li>
</ul>
</li>
<li><p>Switching Via Memory</p>
<ul>
<li>在 CPU 直接控制下切换的传统计算机<br>数据包复制到系统内存<br>速度受内存带宽限制（每个数据报 2 个总线交叉点）</li>
</ul>
</li>
<li><p>Switching Via a Bus</p>
<ul>
<li>通过共享总线从输入端口存储器到输出端口存储器的数据报</li>
<li>总线争用❗bus contention：开关速度受总线带宽限制</li>
<li>所有端口共享总线，易冲突，并行效率低 但对普通接入足够</li>
</ul>
</li>
<li><p>Switching Via An Interconnection Network通过交叉线交换</p>
<ul>
<li>每两个都有唯一的对应，提高并行效率</li>
</ul>
</li>
</ul>
<h3 id="Output-Ports"><a href="#Output-Ports" class="headerlink" title="Output Ports"></a>Output Ports</h3><ul>
<li><p>buffering缓冲</p>
</li>
<li><p>Scheduling discipline 调度规则</p>
<ul>
<li>Priority scheduling（优先调度） – who gets best performance, network neutrality（网络中立性）</li>
</ul>
</li>
</ul>
<h3 id="Output-port-queueing"><a href="#Output-port-queueing" class="headerlink" title="Output port queueing"></a>Output port queueing</h3><ul>
<li><p>how much buffering? P34</p>
</li>
<li><p>Scheduling mechanisms调度机制</p>
<ul>
<li><p>FIFO (first in first out) scheduling先进先出</p>
<ul>
<li><p>discard policy丢弃策略</p>
<ul>
<li>tail drop丢掉后到的: drop arriving packet</li>
<li>priority优先级: drop/remove on priority basis</li>
<li>random随机: drop/remove randomly</li>
<li>Round Robin (RR) scheduling轮询</li>
<li>Weighted Fair Queuing (WFQ):加权轮询</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-4-IP-Internet-Protocol"><a href="#3-4-IP-Internet-Protocol" class="headerlink" title="3.4 IP: Internet Protocol"></a>3.4 IP: Internet Protocol</h2><h3 id="IP特点："><a href="#IP特点：" class="headerlink" title="IP特点："></a>IP特点：</h3><ul>
<li><p>IP 为遍历网络的数据报提供路由功能</p>
</li>
<li><p>每个数据报都有源地址和目标地址</p>
</li>
<li><p>IP 确定数据报是否已到达其目标，或者是否必须转发数据报</p>
<ul>
<li>如果必须转发，IP 将确定下一跃点（next hop）</li>
</ul>
</li>
<li><p>IP 不提供可靠性保证</p>
<ul>
<li>不保证数据包一定能到达其指定的目的地</li>
</ul>
</li>
<li><p>IP 负责数据报(datagram)的拆分（fragmentation）</p>
</li>
<li><p>数据报不能超过(exceed)其所传输网络的最大大小</p>
<ul>
<li>这在创建时未知</li>
</ul>
</li>
<li><p>太大的数据报必须分解为片段（fragments）</p>
</li>
<li><p>每个片段必须包含重新组合原始数据报所需的信息</p>
<ul>
<li>标有长度(length)和偏移量(offset)</li>
</ul>
</li>
<li><p>Workhorse 主力？</p>
</li>
</ul>
<h3 id="3-4-1-IPv4-datagram-format"><a href="#3-4-1-IPv4-datagram-format" class="headerlink" title="3.4.1.IPv4 datagram format"></a>3.4.1.IPv4 datagram format</h3><ul>
<li><p>按位数分：</p>
<ul>
<li><p>IPv4：32-bit* number</p>
<ul>
<li>Written in （点分十进制）Dotted Decimal Notation:205.150.58.7</li>
<li>4 billion different host addresses</li>
<li></li>
<li></li>
</ul>
</li>
<li><p>IPv6：128-bit* number</p>
<ul>
<li>Written in Hex Decimal Notation（十六进制）<br>2001:0503:0C27:0000:0000:0000:0000:0000</li>
<li>16 billion billion network addresses</li>
</ul>
</li>
</ul>
</li>
<li><p>IP Fragmentation拆分 &amp; Reassembly组装</p>
<ul>
<li><p>网络链路有❗MTU (max.transfer size) 最大传输大小-最大可能的链路级帧（不同链路有不同的MTUs）</p>
</li>
<li><p>“reassembled组装” only at final destination</p>
</li>
<li><p>IP header bits used to identify识别, order related fragments</p>
</li>
<li><p>拆分计算</p>
</li>
<li><p>检验是否有错</p>
</li>
<li><p>IP路由操作命令</p>
<ul>
<li><p>winipcfg/(ipconfig)</p>
<ul>
<li>显示用户所在主机内部的IP协议的配置信息P51</li>
</ul>
</li>
<li><p>. netstat</p>
<ul>
<li>主要功能：使用户了解到自己的主机是怎样与因特网相连的P53</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-2IPv4-addressing"><a href="#3-4-2IPv4-addressing" class="headerlink" title="3.4.2IPv4 addressing"></a>3.4.2IPv4 addressing</h3><ul>
<li><p>从不同的层次看数据流动P56</p>
</li>
<li><p>1、IP Address  Classes</p>
<ul>
<li><p>分配IP地址</p>
<ul>
<li><p>由于每个接口必须具有唯一的IP地址，因此必须有一个中央机构(central authority)来分配（assigning）号码</p>
<ul>
<li>这个中央机构为Internet Network Information Center, called the InterNIC.仅分配网络id，主机id的分配由系统管理员决定。</li>
<li>交换机无IP</li>
<li>主机典型有一个interface</li>
<li>路由器典型的有多个interfaces</li>
</ul>
</li>
<li><p>IP 地址的一些重要特点 </p>
<ul>
<li><p>分两个等级的好处是：</p>
<ul>
<li>IP地址管理机构在分配IP地址时只分配网络号，剩下的主机号由得到该网络号的单位自行分配，方便管理</li>
<li>路由器仅根据目的主机所连接的网络号转发分组，无需考虑目的主机号（链路层来做），使路由表中的项目数大幅减少，减小路由表所占空间</li>
</ul>
</li>
<li><p>IP地址标志一个主机（或路由器）和一条链路的接口（interface）</p>
<ul>
<li>多归属主机multihomed host（一个主机连接两个网络，有两个相应的IP地址（net-id））</li>
<li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此一个路由器至少应当有两个不同的 IP 地址。</li>
</ul>
</li>
<li><p>用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id。</p>
</li>
<li><p>所有分配到网络号 net-id 的网络，范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>IP层转发分组的流程</p>
<ul>
<li><p>特定主机路由（为特定的目的主机指明一个路由，方便网络管理人员控制和测试网络/考虑安全问题）</p>
</li>
<li><p>默认路由default route（网络只有很少的对外连接有用</p>
<ul>
<li>路由器采用默认路由以减少路由表所占用的空间和搜索路由表所用的时间</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的网络接口软件。</li>
<li>IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”</li>
<li>网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。</li>
</ul>
</li>
<li><p>(1)  从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。</p>
</li>
<li><p>(2)  若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。</p>
</li>
<li><p>(3)  若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。</p>
</li>
<li><p>(4)  若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。</p>
</li>
<li><p>(5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。</p>
</li>
<li><p>(6)  报告转发分组出错。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2、IP Subnet Addressing</p>
<ul>
<li><p><strong>本地IP地址组成</strong></p>
<ul>
<li><strong>network ID</strong></li>
<li><strong>subnet ID</strong></li>
<li><strong>host ID</strong></li>
</ul>
</li>
<li><p>（1）Subnets and Subnet Masks子网和子网掩码</p>
<ul>
<li><p>(IP Address) AND (Subnet mask) = Net Address</p>
<p>- </p>
<ul>
<li><strong>eg.不同的子网掩码得出❗相同的网络地址。<br>但不同的掩码的效果是不同的。 所以子网掩码是一个很重要的属性</strong></li>
</ul>
</li>
<li><p>子网掩码是一个重要属性</p>
<ul>
<li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器</li>
<li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码</li>
</ul>
</li>
</ul>
</li>
<li><p>（2）Subnetting子网划分</p>
<ul>
<li><p>a.借多少位（上图为判断类别参考）</p>
<ul>
<li><p>可以借的范围</p>
<ul>
<li><p><strong>网络地址类别</strong></p>
<ul>
<li><strong>C 类：8 个主机位</strong></li>
<li><strong>B 类：16 个主机位</strong></li>
<li><strong>A 类：24 个主机位</strong></li>
</ul>
</li>
<li><p>至少借两位：2^2-2=2个子网（全0和全1不用，所以减2）（子网和广播地址）</p>
</li>
</ul>
</li>
<li><p>知道需要多少个子网和主机</p>
<ul>
<li>Host Bits = Bits Borrowed + Bits Left</li>
<li>x为需要的子网数量</li>
<li>x为需要的主机数量</li>
</ul>
</li>
<li><p>计算出结果</p>
</li>
<li><p><strong>❗注：形如192.168.15.0/26（C类）类型的网址/后的数字表示借多少位C类为24+借的位数，示例为借了2位</strong></p>
<ul>
<li>C类为24~32</li>
<li>B类为16~32</li>
<li>A类为8~32</li>
</ul>
</li>
</ul>
</li>
<li><p>b.子网掩码subnet mask是什么</p>
<ul>
<li><p>对应的网络号也都赋值为1，借的位数（子网号）都赋值为1，对应（correspond）的主机号都赋值为0（预留出来的不用的主机），为子网掩码</p>
<ul>
<li>eg.一个C类网络IP：210.93.45.0，借3位（11111111.11111111.11111111.11100000）的<br>子网掩码为255.255.255.224</li>
</ul>
</li>
</ul>
</li>
<li><p>c.magic number or multiplier?</p>
<ul>
<li><strong>magic number=256-子网掩码点分后的最后一个非零数（Last Non-Zero Octet）</strong></li>
<li>magic number可视为划分后每个子网的主机数量（包含广播和主机的，也就是没-2的时候的）（自己理解的，非官方）</li>
<li>eg. Last Non-Zero Octet为224，例子中子网的migic number为256-224=32</li>
<li>Last Non-Zero Octet表格（可计算得到）</li>
</ul>
</li>
<li><p>d.子网地址是什么</p>
<ul>
<li>子网地址（主机号全为0的）：相较未被划分的IP地址（点分十进制）只改变借用位置部分的数（C类为最后一个，B类为倒数第二个，A类为倒数第三个）=第几个子网*magic number。<br>子网地址加上主机号就是子网地址（自己总结，非官方）</li>
</ul>
</li>
</ul>
</li>
<li><p>（3）Logical AND Operation逻辑与操作</p>
<ul>
<li>设备使用 AND 计算（computation）来确定每个 IP 地址的子网标识符（the subnet identifier ）。</li>
<li>如果本地 IP 地址的子网标识符与要与之通信的 IP 地址的子网标识符相同，则数据包将发送到本地子网上。</li>
<li>如果子网标识符不同，则数据包将发送到默认网关（default gateway ）或本地路由器，以路由到远程子网。</li>
</ul>
</li>
<li><p>划分子网后分组如何转发？ PPT 131-136</p>
<ul>
<li><p>(1) 从收到的分组的首部提取目的IP地址D。</p>
</li>
<li><p>(2) 先用各网络的子网掩码和D逐比特相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行(3)。 </p>
<ul>
<li>相较上面的分组转发算法多了和D逐比特相“与”</li>
</ul>
</li>
<li><p>(3) 若路由表中有目的地址为D的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行(4)。</p>
</li>
<li><p>(4) 对路由表中的每一行的子网掩码和D逐比特相“与”，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行(5)</p>
<ul>
<li>相较上面的分组转发算法多了和D逐比特相“与”</li>
</ul>
</li>
<li><p>(5) 若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行(6)。</p>
</li>
<li><p>(6) 报告转发分组出错。</p>
</li>
</ul>
</li>
<li><p>得到一个IP地址的方式</p>
<ul>
<li><p>hard-coded硬编码 by system admin系统管理员 in a file</p>
<ul>
<li>好处：固定</li>
<li>缺点：可能发生冲突</li>
</ul>
</li>
<li><p>DHCP: Dynamic Host Configuration Protocol: dynamically get address from as server<br>动态从服务器获取（即插即用plug-and-play）</p>
<ul>
<li><p>目标：允许主机在加入网络时从网络服务器动态获取其 IP 地址</p>
<ul>
<li>可以在使用中的地址上续订其租约（renew its lease ）</li>
<li>允许重复使用地址（仅在连接/“打开”时保留地址）</li>
<li>支持想要加入网络的移动用户</li>
</ul>
</li>
<li><p>获取步骤</p>
<ul>
<li>主机广播”DHCP discover（DHCP发现报文）”消息 [可选]</li>
<li>DHCP 服务器响应”DHCP offer（DHCP应答报文）”消息 [可选]</li>
<li>主机请求 IP 地址：DHCP request（DHCP请求报文）”消息</li>
<li>DHCP 服务器发送地址：”DHCP ack（DHCP确认报文）” 消息</li>
</ul>
</li>
<li><p>不仅可以返回子网上分配(allocated)的IP地址</p>
<ul>
<li>客户端的第一跃点路由器的地址</li>
<li>DNS 服务器的名称和 IP 地址</li>
<li>网络掩码（指示地址的网络与主机部分）</li>
</ul>
</li>
<li><p>ISP从ICANN（ Internet Corporation for Assigned Names and Numbers）获取地址块</p>
<ul>
<li>分配地址</li>
<li>管理 DNS</li>
<li>分配域名，解决争议(resolves disputes)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-3-Slowing-IP-Address-Depletion"><a href="#3-4-3-Slowing-IP-Address-Depletion" class="headerlink" title="3.4.3.Slowing IP Address Depletion"></a>3.4.3.Slowing IP Address Depletion</h3><p>IP地址耗尽速度变慢</p>
<ul>
<li><p>可变长度子网掩码Variable Length Subnet masks可变长度子网掩码VLSM</p>
<ul>
<li>将子网再次划分</li>
<li>组成：network/subset/ VLSM subset /Host</li>
</ul>
</li>
<li><p>无类域间路由Classless Interdomain Routing</p>
<ul>
<li><p>Classless InterDomain Routing（CIDR）</p>
<ul>
<li>任意长度的地址的子网部分</li>
<li>地址格式：a.b.c.d/x，其中 x 是地址子网部分的 # 位，例子中的子网的所有地址的23位前缀都是一样的</li>
</ul>
</li>
<li><p>路由聚合(route aggregation) </p>
<ul>
<li><p>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。</p>
</li>
<li><p>路由聚合也称为构成超网(supernetting)。</p>
<ul>
<li>前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C 类地址。</li>
<li>这些 C 类地址合起来就构成了超网。</li>
<li>CIDR 地址块中的地址数一定是 2 的整数次幂。</li>
<li>网络前缀越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长。</li>
</ul>
</li>
<li><p>CIDR 虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。</p>
</li>
<li><p>对于 /20  地址块，它的掩码是 20 个连续的 1。 斜线记法中的数字就是掩码中1的个数。</p>
</li>
</ul>
</li>
<li><p>CIDR记法的其它形式</p>
<ul>
<li><p>10.0.0.0/10 可简写为 10/10，也就是把点分十进制中低位连续的 0 省略。</p>
<p>- </p>
</li>
<li><p>网络前缀的后面加一个星号 * 的表示方法，此方法可实现路由聚合</p>
<ul>
<li><pre><code>如 00001010 00*，在星号 * 之前是网络前缀，而星号 * 表示 IP 地址中的主机号，可以是任意值。
</code></pre>
</li>
<li><pre><code>eg.

- 层次编址允许高效的路由信息通告:
- 使用单个网络前缀通告多个网络的能力称为地址聚合或路由聚合或路由摘要
- 其他路由器路由转发分组时,使用最长前缀匹配法则,找到正确路由。
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>匹配/寻找方式</p>
<ul>
<li>选择两个匹配的地址中更具体的一个，即选择最长前缀的地址。</li>
</ul>
</li>
</ul>
</li>
<li><p>网络地址转换NAT：Network Address Translation</p>
<ul>
<li><p>动机：就外部世界而言，本地网络仅使用一个IP地址</p>
<ul>
<li>ISP 不需要的地址范围：所有设备只需一个 IP 地址</li>
<li>可以在不通知外界的情况下更改本地网络中设备的地址</li>
<li>可以更改ISP，而无需更改本地网络中设备的地址</li>
<li>本地网络内的设备无法明确寻址，外部世界可见（安全加分项）。</li>
</ul>
</li>
<li><p>实现：NAT 路由器必须</p>
<ul>
<li>传出数据报(outgoing datagrams)：将每个传出数据报的（源 IP 地址、端口号(port #)）替换为（NAT IP 地址、新端口 #）远程客户端/服务器将使用（NAT IP 地址、新端口 #）作为目标地址进行响应。</li>
<li>记住（在 NAT 转换表中）每个（源 IP 地址、端口号）到（NAT IP 地址、新端口号）转换对</li>
<li>传入数据报：将每个传入数据报的 dest 字段中的（NAT IP 地址、新端口号）替换为存储在 NAT 表中的相应（源 IP 地址、端口号）</li>
</ul>
</li>
<li><p>16 位端口号字段：</p>
<ul>
<li>60，000 个同时(simultaneous)连接，单个 LAN 端地址！</li>
</ul>
</li>
<li><p>NAT是有争议的：</p>
<ul>
<li><p>路由器最多只能处理第 3 层</p>
</li>
<li><p>违反端到端参数</p>
<ul>
<li>应用程序设计人员必须考虑NAT的可能性，例如，P2P应用程序</li>
</ul>
</li>
<li><p>地址短缺应该由IPv6解决</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-4-IPv6"><a href="#3-4-4-IPv6" class="headerlink" title="3.4.4.IPv6"></a>3.4.4.IPv6</h3><ul>
<li><p>初始动机：可以完全分配 32 位地址空间。</p>
</li>
<li><p>其他动机：</p>
<ul>
<li>标头（header）格式有助于加快处理（processing）/转发（forwarding）速度</li>
<li>标头更改以方便（facilitate） QoS</li>
</ul>
</li>
<li><p>IPv6 数据报格式：固定长度 40 字节标头</p>
<ul>
<li>不允许拆分（fragmentation）</li>
</ul>
</li>
<li><p>数据报格式</p>
<ul>
<li>version:4bits（值为6“0110”）表示IPV6的报文</li>
<li>有效载荷长度（Payload Length）：16 bit，以字节为单位的 IPv6 载荷长度，也就是 IPv6 报文基本头以后部分的长度（包括所有扩展头部分）。</li>
<li>Priority:  8bits,identify priority among datagrams in flow确定流中数据报的优先级</li>
<li>Flow Label:20bits, identify datagrams in same “flow.” 标识同一”流”中的数据报(concept of“flow” not well defined).</li>
<li>Next header: 8bits下一个头部字段用来标识当前报头（或者扩展报头）的下一个头部类型，占8位。每种扩展报头都有其对应的值。</li>
<li>Hop Limit：8bits,ttl(time to live)</li>
</ul>
</li>
<li><p>过渡Transition From IPv4 To IPv6</p>
<ul>
<li><p>不能同时升级，有成本考虑</p>
</li>
<li><p>采用隧道形式，将IPV6的报文伪装成IPV4的报文</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-5路由算法"><a href="#3-5路由算法" class="headerlink" title="3.5路由算法"></a>3.5路由算法</h2><p>Routing algorithms</p>
<h3 id="路由、转发之间的相互作用（Interplay）"><a href="#路由、转发之间的相互作用（Interplay）" class="headerlink" title="路由、转发之间的相互作用（Interplay）"></a>路由、转发之间的相互作用（Interplay）</h3><h3 id="路由协议目标"><a href="#路由协议目标" class="headerlink" title="路由协议目标"></a>路由协议目标</h3><ul>
<li><p>通过路由器网络确定从发送主机到接收主机的”良好”路径（等效于路由）</p>
<ul>
<li>路径：路由器数据包序列将从给定的初始源主机遍历到给定的最终目标主机</li>
<li>“好”：最小”成本”，”最快”，”最不拥挤”</li>
</ul>
</li>
</ul>
<h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><ul>
<li><p>抽象图</p>
<ul>
<li>Graph: G = (N,E)图是由节点和边构成的</li>
<li>N = set of routers = { u, v, w, x, y, z }节点的集合</li>
<li>E = set of links ={ (u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z) }边的集合</li>
</ul>
</li>
<li><p>路由算法：查找成本最低的路径的算法</p>
</li>
<li><p>分类</p>
<ul>
<li><p>全局式Global</p>
<ul>
<li>所有路由器都有完整的拓扑结构，链路成本信息</li>
<li>“链接状态（link-state）”算法</li>
</ul>
</li>
<li><p>分布式decentralized</p>
<ul>
<li>路由器知道物理连接的邻居，与邻居的链路成本</li>
<li>迭代（iterative）计算过程，与邻居交换信息（info）</li>
<li>“距离矢量(distance vector)”算法</li>
</ul>
</li>
<li><p>静态Static</p>
<ul>
<li>路由随时间缓慢变化</li>
</ul>
</li>
<li><p>动态dynamic</p>
<ul>
<li><p>路线变化更快</p>
<ul>
<li>定期(periodic)更新</li>
<li>响应链路成本变化</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="link-state链路状态路由算法Dijkstra’s-algorithm"><a href="#link-state链路状态路由算法Dijkstra’s-algorithm" class="headerlink" title="link state链路状态路由算法Dijkstra’s algorithm"></a>link state链路状态路由算法Dijkstra’s algorithm</h3><ul>
<li><p>网络拓扑topology，链路花销为所有节点都知道</p>
<ul>
<li>通过”链路状态广播(link state broadcast)”完成accomplished </li>
<li>所有节点都具有相同的信息</li>
</ul>
</li>
<li><p>计算从一个节点（”源sorce”）到所有其他节点的最低成本路径</p>
<ul>
<li>为该节点提供转发表</li>
</ul>
</li>
<li><p>迭代：在 k 次迭代之后，知道到 k 个 dest 的最小成本路径。</p>
</li>
<li><ul>
<li>c(x,y): link cost from node x to y;  = ∞ if not direct neighbors</li>
<li>D(v): current value of cost of path from source to dest. v</li>
<li>p(v): predecessor node along path from source to v</li>
<li>N’: set of nodes whose least cost path definitively known</li>
</ul>
</li>
<li><p>算法复杂度：n 个节点</p>
<ul>
<li><p>每次迭代：需要检查所有节点，w，不在N</p>
</li>
<li><p>n(n+1)/2  comparisons: O(n2)</p>
</li>
<li><p>可实现更高效的实现：O（nlogn）</p>
</li>
<li><p>可能的振荡：</p>
<ul>
<li>例如，刚算出走这个节点，下次迭代就是另一个结点更近</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="distance-vector距离向量算法（分布式decentralized）"><a href="#distance-vector距离向量算法（分布式decentralized）" class="headerlink" title="distance vector距离向量算法（分布式decentralized）"></a>distance vector距离向量算法（分布式decentralized）</h3><ul>
<li><p>Bellman-Ford equation方程 (dynamic programming动态规划)</p>
</li>
<li><p>Dx(y) = estimate of least cost from x to y<br>Distance vector: Dx = [Dx(y): y є N ]<br>Node x knows cost to each neighbor v: c(x,v)<br>Node x maintains Dx = [Dx(y): y є N ]<br>Node x also maintains its neighbors’ distance vectors<br>For each neighbor v, x maintains Dv = [Dv(y): y є N ]</p>
</li>
<li><p>基本思想：</p>
<ul>
<li>每个节点定期向邻居发送自己的距离矢量估计值</li>
<li>当节点 x 从邻居处收到新的 DV 估计值时，它将使用 B-F 等式更新自己的 DV：</li>
<li>在次要的自然条件下，估计值 Dx（y） 收敛到实际最小成本 dx（y）</li>
<li></li>
</ul>
</li>
<li><p>迭代iterative：</p>
<ul>
<li>本地链路成本更改</li>
<li>来自邻居的 DV 更新消息</li>
</ul>
</li>
<li><p>分散式distributed：</p>
<ul>
<li><p>每个节点仅在其 DV 更改时通知邻居</p>
<ul>
<li>然后，如有必要，邻居会通知邻居</li>
</ul>
</li>
</ul>
</li>
<li><p>链接成本变化：</p>
<ul>
<li>节点检测到本地链路开销变化</li>
<li>更新路线信息，重新计算距离矢量</li>
<li>如果 DV 发生变化，通知邻居</li>
<li>好消息传播的快，坏消息传播缓慢 - “数到无穷大”的问题！</li>
</ul>
</li>
</ul>
<h3 id="Comparison-of-LS-and-DV-algorithms"><a href="#Comparison-of-LS-and-DV-algorithms" class="headerlink" title="Comparison of LS and DV algorithms"></a>Comparison of LS and DV algorithms</h3><ul>
<li><p>Message complexity消息复杂性</p>
<ul>
<li><p>LS: with n nodes, E links, O(nE) msgs sent  </p>
</li>
<li><p>DV: exchange between neighbors only</p>
<ul>
<li>convergence time varies收敛时间不定</li>
</ul>
</li>
</ul>
</li>
<li><p>Speed of Convergence收敛速度</p>
<ul>
<li><p>LS: O(n2) algorithm requires O(nE) msgs</p>
<ul>
<li>may have oscillations 可能有振荡，但是不易产生路由环路</li>
</ul>
</li>
<li><p>DV: convergence time varies</p>
<ul>
<li>may be routing loops可能是路由环路</li>
<li>count-to-infinity problem数到无穷大问题</li>
</ul>
</li>
</ul>
</li>
<li><p>Robustness: what happens if router malfunctions?鲁棒性（强壮与健壮，系统在异常情况下的生存能力）</p>
<ul>
<li><p>LS: </p>
<ul>
<li>节点可以公布（advertise ）不正确的链接（link）开销</li>
<li>每个节点仅计算（computes ）自己的表</li>
</ul>
</li>
<li><p>DV:</p>
<ul>
<li><p>节点可以公布（advertise ）不正确的路径（path ）开销</p>
</li>
<li><p>每个节点的表都被其他表使用</p>
<ul>
<li>error propagate thru network错误通过网络传播</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-6-Routing-in-the-Internet"><a href="#3-6-Routing-in-the-Internet" class="headerlink" title="3.6 Routing in the Internet"></a>3.6 Routing in the Internet</h2><h3 id="Hierarchical-routing层次路由"><a href="#Hierarchical-routing层次路由" class="headerlink" title="Hierarchical routing层次路由"></a>Hierarchical routing层次路由</h3><ul>
<li><p>由于规模大不能存储所有目标<br>行政自主权（administrative autonomy）<br>两个问题产生层次路由</p>
</li>
<li><p>将路由器聚合到称为“autonomous systems”（AS）的区域（也称为”domains”）中</p>
<ul>
<li><p>自治系统 (Autonomous System) </p>
<p>自治系统 AS 的定义：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。<br>现在对自治系统 AS 的定义是强调下面的事实：尽管一个 AS 使用了多种内部路由选择协议和度量，但重要的是一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略。</p>
</li>
<li><p>intra-AS routing<br>AS 内路由</p>
<ul>
<li><p>也称为内部网关协议 （interior gateway protocols ，IGP）</p>
<ul>
<li><p>最常见的 AS 内路由协议：</p>
<ul>
<li>RIP：Routing Information Protocol路由信息协议</li>
<li>OSPF：开放最短路径优先Open Shortest Path First（IS-IS协议（本质为OSPF）与OSPF基本相同）</li>
<li>IGRP：内部网关路由协议:Interior Gateway Routing Protocol （思科专有数十年，直到2016年）</li>
</ul>
</li>
</ul>
</li>
<li><p>在同一AS（”网络”）中，主机、路由器之间路由</p>
</li>
<li><p>AS 中的所有路由器必须运行相同的域内（intra-domain）协议</p>
</li>
<li><p>不同 AS 中的路由器可以运行不同的域内路由协议</p>
</li>
<li><p>网关路由器（gateway router）：在其自身 AS 的”边缘”，具有到其他 AS 中的路由器的链接</p>
</li>
</ul>
</li>
<li><p>inter-AS routing<br>AS 间路由</p>
<ul>
<li>在 AS 之间路由</li>
<li>网关（gateways）执行域间路由（以及域内路由）</li>
</ul>
</li>
<li><p>总结：为什么Intra-, Inter-AS routing 不同</p>
<ul>
<li><p>policy: </p>
<ul>
<li>inter-AS（AS间路由）: 管理员希望控制其流量如何路由，谁通过其网络路由。</li>
<li>intra-AS（AS内路由）: 单个管理员，因此不需要策略决策</li>
</ul>
</li>
<li><p>scale:</p>
<ul>
<li>分层路由可以节省表的大小，减少更新流量（traffic）</li>
</ul>
</li>
<li><p>performance: </p>
<ul>
<li>intra-AS: 专注于性能</li>
<li>inter-AS: 政策可能支配性能</li>
</ul>
</li>
</ul>
</li>
<li><p>Interconnected ASes互连的 AS</p>
<ul>
<li><p>转发表由 AS 内intra-AS和 AS 间inter-AS 路由算法配置</p>
</li>
<li><p>AS 内部路由设置内部目标（internal dests）的转发表的条目entries</p>
</li>
<li><p>AS 间和 AS 内设置外部目标的转发表的条目entries</p>
<ul>
<li>Inter-AS tasks(AS间任务)：<br>1.了解哪些目标主机可通过邻接的AS访问<br>2.并将这些可访问信息传播到此AS中的所有路由器(AS内协议执行)。以便知道有任务时传给哪个<br>eg.P208</li>
</ul>
</li>
</ul>
</li>
<li><p>Hot potato routing：将数据包发送到两个路由器中最近的一个</p>
</li>
</ul>
</li>
<li><p>有关路由选择协议的几个基本概念</p>
<ul>
<li><ol>
<li>理想的路由算法</li>
</ol>
<p>算法必须是正确的和完整的。<br>算法在计算上应简单。<br>算法应能适应通信量和网络拓扑的变化，这就是说，要有自适应性。<br>算法应具有稳定性。<br>算法应是公平的。<br>算法应是最佳的。 </p>
</li>
<li><p>2.关于“最佳路由” </p>
<p>不存在一种绝对的最佳路由算法。<br>所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。<br>实际的路由选择算法，应尽可能接近于理想的算法。<br>路由选择是个非常复杂的问题<br>它是网络中的所有结点共同协调工作的结果。<br>路由选择的环境往往是不断变化的，而这种变化有时无法事先知道。  </p>
</li>
<li><p>3.从路由算法的自适应性考虑</p>
<ul>
<li>静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。 </li>
<li>动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。</li>
</ul>
</li>
<li><p>4.分层次的路由选择协议</p>
<p>因特网采用分层次的路由选择协议。<br>因特网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使因特网的通信链路饱和。<br>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到因特网上。   </p>
</li>
<li><p>5.因特网有两大类路由选择协议 </p>
<ul>
<li>内部网关协议 IGP (Interior Gateway Protocol)    即在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</li>
<li>外部网关协议EGP (External Gateway Protocol)    若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。在外部网关协议中目前使用最多的是 BGP-4。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="RIP路由选择信息协议"><a href="#RIP路由选择信息协议" class="headerlink" title="RIP路由选择信息协议"></a>RIP路由选择信息协议</h3><ul>
<li><ol>
<li>工作原理</li>
</ol>
<ul>
<li><p>路由信息协议 RIP 是内部网关协议 IGP中最先得到广泛使用的协议。</p>
</li>
<li><p>RIP 是一种分布式的基于距离向量的路由选择协议。</p>
</li>
<li><p>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。 </p>
</li>
<li><p>“距离”的定义 </p>
<p>从一路由器到直接连接的网络的距离定义为 1。<br>从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。<br>RIP 协议中的“距离”也称为“跳数”(hop count)，因为每经过一个路由器，跳数就加 1。<br>这里的“距离”实际上指的是“最短距离”，<br>RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。<br>RIP 允许一条路径最多只能包含 15 个路由器。<br>“距离”的最大值为16 时即相当于不可达。可见 RIP 只适用于小型互联网。<br>RIP 不能在两个网络之间同时使用多条路由。RIP 选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。   </p>
</li>
<li><p><strong>三个要点：</strong></p>
<ul>
<li>仅和相邻路由器交换信息。 </li>
<li>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 </li>
<li>按固定的时间间隔交换路由信息，例如，每隔 30 秒。</li>
</ul>
</li>
<li><p>路由表的建立</p>
<ul>
<li>路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为1）。</li>
<li>以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。</li>
<li>经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。</li>
<li>RIP 协议的收敛(convergence)过程较快，即在自治系统中所有的结点都得到正确的路由选择信息的过程。</li>
</ul>
</li>
</ul>
</li>
<li><ol start="2">
<li>距离向量算法</li>
</ol>
<p>- </p>
<ul>
<li><p>路由器之间交换信息 </p>
<ul>
<li>RIP协议让互联网中的所有路由器都和自己的相邻路由器不断交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最少）。</li>
<li>虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</li>
</ul>
</li>
</ul>
</li>
<li><p>RIP 协议的优缺点 </p>
<ul>
<li>RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。（好消息传播得快，而坏消息传播得慢）</li>
<li>RIP 协议最大的优点就是实现简单，开销较小。</li>
<li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li>
<li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li>
</ul>
</li>
</ul>
<h3 id="OSPF-（Open-Shortest-Path-First）首先打开最短路径"><a href="#OSPF-（Open-Shortest-Path-First）首先打开最短路径" class="headerlink" title="OSPF （Open Shortest Path First）首先打开最短路径"></a>OSPF （Open Shortest Path First）首先打开最短路径</h3><ul>
<li><p>介绍</p>
<ul>
<li><p>“开放”：公开可用</p>
</li>
<li><p>使用link-state算法</p>
<ul>
<li>链路状态数据包分发（dissemination）</li>
<li>每个节点的拓扑图</li>
<li>使用Dijkstra算法的路由计算</li>
</ul>
</li>
<li><p>路由器将 OSPF 链路状态通告扩散（floods）到整个 AS 中的所有其他路由器</p>
<ul>
<li><p>直接通过 IP（而不是 TCP 或 UDP）在 OSPF 消息中传输</p>
<p>OSPF 不用 UDP 而是直接用 IP 数据报传送。<br>OSPF 构成的数据报很短。这样做可减少路由信息的通信量。<br>数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。 </p>
</li>
<li><p>链接状态：对于每个附加（attached）的链接</p>
</li>
</ul>
</li>
<li><p>IS-IS 路由协议：几乎与 OSPF 相同</p>
</li>
</ul>
</li>
<li><p>高级功能”advanced” features</p>
<ul>
<li><p>安全性security：所有 OSPF 消息都经过身份验证（authenticated）（以防止恶意入侵（malicious intrusion））</p>
</li>
<li><p>允许多个相同成本的路径（RIP 中只有一个路径）</p>
</li>
<li><p>对于每个链路，针对不同 TOS 的多个成本指标（例如，卫星链路成本设置为“low”以实现”尽力而为ToS”，”high”用于实时 ToS）</p>
</li>
<li><p>集成的integrated，支持单播和多播uni- and multi-cast：</p>
<ul>
<li>Multicast  OSPF （MOSPF） 使用与 OSPF 相同的拓扑数据库</li>
</ul>
</li>
<li><p>大型域中的hierarchical OSPF。</p>
<p>- </p>
<ul>
<li><p>两级层次结构two-level hierarchy：局部区域local area、骨干网backbone。</p>
<ul>
<li>链接状态广告仅在区域内</li>
<li>每个节点都有详细的区域拓扑;只知道方向(最短路径)到网的其他区域。</li>
</ul>
</li>
<li><p>区域边界路由器area border routers：</p>
<ul>
<li>“汇总”到自己区域内网络的距离，通告给其他区域边界路由器。</li>
</ul>
</li>
<li><p>骨干路由器backbone routers：运行仅限于骨干网的 OSPF 路由。</p>
</li>
<li><p>边界路由器boundary routers：连接到其他 AS（自治系统）。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>三个要点 </p>
<ul>
<li><p>向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。</p>
</li>
<li><p>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。</p>
<ul>
<li>“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。</li>
</ul>
</li>
<li><p>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</p>
</li>
</ul>
</li>
<li><p>其他特点</p>
<ul>
<li>OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。 </li>
<li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。 </li>
<li>OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms。</li>
</ul>
</li>
<li><p>指定的路由器(designated router) ？？？</p>
<ul>
<li>多点接入的局域网采用了指定的路由器的方法，使广播的信息量大大减少。</li>
<li>指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。</li>
</ul>
</li>
</ul>
<h3 id="Internet-inter-AS-：BGP-routing（Border-Gateway-Protocol）实际的域间路由协议"><a href="#Internet-inter-AS-：BGP-routing（Border-Gateway-Protocol）实际的域间路由协议" class="headerlink" title="Internet inter-AS ：BGP routing（Border Gateway Protocol）实际的域间路由协议"></a>Internet inter-AS ：BGP routing（Border Gateway Protocol）实际的域间路由协议</h3><ul>
<li><p>BGP为每个AS提供了一种方法:</p>
<ul>
<li>eBGP:向邻居as获取子网可达性信息</li>
<li>iBGP:向所有as内部路由器传播可达性信息。</li>
<li>根据可达性信息和策略确定到其他网络的“良好”路由</li>
</ul>
</li>
<li><p>允许子网将它的存在通告给Internet的其他部分:“我在这里“</p>
</li>
<li><p>BGP session：两个 BGP 路由器（”peer”）通过半永久性(semi-permanent) TCP 连接交换 BGP 消息：</p>
<ul>
<li>发布到不同目的网络前缀的路径（BGP 是”path vector”协议）</li>
</ul>
</li>
<li><p>路径属性和 BGP 路由</p>
<ul>
<li><p>播发的前缀(advertised prefix)包括 BGP 属性</p>
<ul>
<li>前缀 + 属性 = “路由”（prefix + attributes = “route”）</li>
</ul>
</li>
<li><p>两个重要属性：</p>
<ul>
<li>AS-PATH：前缀advertisement经过的AS列表</li>
<li>NEXT-HOP：指定到达下一跳AS的域内AS路由器</li>
</ul>
</li>
<li><p>基于策略的路由Policy-based routing：</p>
<ul>
<li>网关接收路由通告使用导入策略来接受/拒绝路径</li>
<li>AS 策略还确定是否将路径通告到其他相邻的 AS</li>
</ul>
</li>
</ul>
</li>
<li><p>BGP路径通告</p>
<ul>
<li><p>网关路由器可以了解到目的地的多个路径</p>
<ul>
<li>AS1 网关路由器 1c 从 2a 学习路径 AS2、AS3、X</li>
<li>AS1 网关路由器 1c 从 3a 学习路径 AS3，X</li>
<li>AS1 网关路由器 1c 根据策略选择路径 AS3、X，并通过 iBGP 在 AS1 中通告路径</li>
</ul>
</li>
</ul>
</li>
<li><p>BGP 报文（message）</p>
<ul>
<li><p>通过 TCP 连接在对等方之间交换的 BGP 报文</p>
</li>
<li><p>报文类型：</p>
<ul>
<li>OPEN：打开与远程 BGP 对等体的 TCP 连接，并对要发送的 BGP 对等体进行身份验证authenticates</li>
<li>UPDATE：公布新路径（或撤回旧路径）</li>
<li>KEEPALIVE：在没有UPDATE的情况下保持连接活跃;还 ACK 打开请求</li>
<li>NOTIFICATION：报告以前的消息中的错误;也用于关闭连接</li>
</ul>
</li>
</ul>
</li>
<li><p>路由器可以了解到目标 AS 的多个路由，根据以下条件选择路由：</p>
<ul>
<li>本地首选项值属性(local preference value attribute)：策略决策(policy decision)</li>
<li>最短的 AS 路径shortest AS-PATH </li>
<li>最近的下一跳路由器(closest NEXT-HOP router)：热土豆路由hot potato routing</li>
<li>其他标准additional criteria</li>
</ul>
</li>
<li><p>BGP协议的特点</p>
<ul>
<li>BGP 协议交换路由信息的结点数量级是自治系统数的量级，这要比这些自治系统中的网络数少很多。</li>
<li>每一个自治系统中 BGP 发言人（或边界路由器）的数目是很少的。这样就使得自治系统之间的路由选择不致过分复杂。  </li>
<li>BGP 支持 CIDR，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。</li>
<li>在BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销方面都有好处。</li>
</ul>
</li>
</ul>
<h2 id="3-7-广播路由和多播路由"><a href="#3-7-广播路由和多播路由" class="headerlink" title="3.7 广播路由和多播路由"></a>3.7 广播路由和多播路由</h2><p>Broadcast and multicast routing</p>
<h3 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h3><ul>
<li><p>多播可明显地减少网络中资源的消耗</p>
</li>
<li><p>IP多播特点（只在局域网内使用）：</p>
<ul>
<li>(1) 多播使用组地址—— IP 使用 D 类地址支持多播。多播地址只能用于目的地址，而不能用于源地址。  </li>
<li>(2) 永久组地址——由因特网号码指派管理局 IANA 负责指派。</li>
<li>(3) 动态的组成员 </li>
<li>(4) 使用硬件进行多播</li>
</ul>
</li>
<li><p>IP多播需要两种协议</p>
<ul>
<li><p>为了使路由器知道多播组成员的信息，需要利用网际组管理协议 IGMP (Internet Group Management Protocol)。</p>
<ul>
<li><p>IGMP 的本地使用范围 </p>
<ul>
<li>IGMP 并非在因特网范围内对所有多播组成员进行管理的协议。</li>
<li>IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上。</li>
<li>IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机（严格讲，是主机上的某个进程）参加或退出了某个多播组。</li>
</ul>
</li>
</ul>
</li>
<li><p>连接在局域网上的多播路由器还必须和因特网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用多播路由选择协议。</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-8-ICMP-Internet-Control-Message-Protocol网络控制消息协议"><a href="#3-8-ICMP-Internet-Control-Message-Protocol网络控制消息协议" class="headerlink" title="3.8 ICMP: Internet Control Message Protocol网络控制消息协议"></a>3.8 ICMP: Internet Control Message Protocol网络控制消息协议</h2><h3 id="用于主机和路由器之间的网络级信息通信"><a href="#用于主机和路由器之间的网络级信息通信" class="headerlink" title="用于主机和路由器之间的网络级信息通信"></a>用于主机和路由器之间的网络级信息通信</h3><ul>
<li>错误报告error reporting:不可达的主机，网络，端口，协议</li>
<li>Echo请求/应答(由ping使用)</li>
</ul>
<h3 id="网络层”高于“IP"><a href="#网络层”高于“IP" class="headerlink" title="网络层”高于“IP:"></a>网络层”高于“IP:</h3><ul>
<li>IP数据报中携带的ICMP消息</li>
</ul>
<h3 id="ICMP报文-类型、代码加导致错误的IP数据报的前8个字节"><a href="#ICMP报文-类型、代码加导致错误的IP数据报的前8个字节" class="headerlink" title="ICMP报文:类型、代码加导致错误的IP数据报的前8个字节"></a>ICMP报文:类型、代码加导致错误的IP数据报的前8个字节</h3><p>- </p>
<h3 id="Traceroute-and-ICMP"><a href="#Traceroute-and-ICMP" class="headerlink" title="Traceroute and ICMP"></a>Traceroute and ICMP</h3><ul>
<li><p>Source发送一系列 UDP 段</p>
<ul>
<li>首先具有 TTL =1</li>
<li>第二个有 TTL=2，依此类推。</li>
<li>不太可能的端口号</li>
</ul>
</li>
<li><p>当第 n 个数据报到达第 n 个路由器时：</p>
<ul>
<li>路由器丢弃数据报并发送到源 ICMP 消息（类型 11，代码 0）</li>
<li>消息包括路由器和IP地址的名称</li>
</ul>
</li>
<li><p>当 ICMP 消息到达时，Source计算 RTT</p>
</li>
<li><p>Traceroute 会执行此操作 3 次</p>
</li>
<li><p>停止标准（criterion）</p>
<ul>
<li>UDP 段最终到达目标主机</li>
<li>目标返回 ICMP”主机无法访问”数据包（类型 3，代码 3）</li>
<li>当源获得此 ICMP 时，将停止。</li>
</ul>
</li>
</ul>
<h3 id="ICMP的实用程序"><a href="#ICMP的实用程序" class="headerlink" title="ICMP的实用程序"></a>ICMP的实用程序</h3><ul>
<li><p>（1）.Ping </p>
<ul>
<li><p>主要功能： PING用来测试两个主机之间的连通性。PING使用了ICMP回送请求与回送回答报文。PING是应用层直接使用网络层ICMP的例子，它没有通过运输层的 TCP或UDP。 </p>
</li>
<li><p>使用格式：ping [-t] [-a] [-n count] [-l size] </p>
</li>
<li><p>参数介绍： </p>
<p>-t 让用户所在的主机不断向目标主机发送数据<br>-a 以IP地址格式来显示目标主机的网络地址<br>-n count 指定要ping多少次，具体次数由后面的count来指定<br>-l size 指定发送到目标主机的数据包的大小 </p>
</li>
<li><p>ping命令的其他技巧：</p>
<pre><code>在一般情况下还可以通过ping对方让对方返回给你的TTL值大小，粗略的判断目标主机的系统类型是Windows系列还是UNIX/Linux系列，一般情况下Windows系列的系统返回的TTL值在100-130之间，而UNIX/Linux系列的系统返回的TTL值在240-255之间，当然TTL的值在对方的主机里是可以修改的，Windows系列的系统可以通过修改注册表以下键值实现： [HKEY_LOCAL_MACHINE＼SYSTEM＼CurrentControlSet＼Services＼Tcpip＼Parameters] "DefaultTTL"=dword:000000ff 255---FF ，128---80，64----40，32----20
</code></pre>
</li>
</ul>
</li>
<li><p>（2）.tracert</p>
<ul>
<li><p>使用格式：tracert [-d] [-h maximum_hops] [-j host_list] [-w timeout] </p>
</li>
<li><p>参数介绍： </p>
<ul>
<li>-d 不解析目标主机的名字 </li>
<li>-h maximum_hops 指定搜索到目标地址的最大跳跃数 </li>
<li>-j host_list 按照主机列表中的地址释放源路由 </li>
<li>-w timeout 指定超时时间间隔，程序默认的时间单位是毫秒</li>
</ul>
</li>
<li><p>主要功能：判定数据包到达目的主机所经过的路径、显示数据包经过的中继节点清单和到达时间。</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-9-Network-management-and-SNMP"><a href="#3-9-Network-management-and-SNMP" class="headerlink" title="3.9 Network management and SNMP"></a>3.9 Network management and SNMP</h2><h3 id="network-management：什么是网络管理？"><a href="#network-management：什么是网络管理？" class="headerlink" title="network management：什么是网络管理？"></a>network management：什么是网络管理？</h3><p>“Network management includes the deployment, integration and coordination of the hardware, software, and human elements to monitor, test, poll, configure, analyze, evaluate, and control the network and element resources to meet the real-time, operational performance, and Quality of Service requirements at a reasonable cost.”<br>“网络管理包括（包含）硬件、软件和（对象）人员元素的部署、集成和协调，以（目的）监控、测试、轮询、配置、分析、评估和控制网络和元素资源，以（达到目标）合理的成本满足实时、运营性能和服务质量要求</p>
<h3 id="Infrastructure-for-network-management网络管理基础架构"><a href="#Infrastructure-for-network-management网络管理基础架构" class="headerlink" title="Infrastructure for network management网络管理基础架构"></a>Infrastructure for network management网络管理基础架构</h3><ul>
<li>受管设备包含受管对象，其数据被收集到管理信息库 Management Information Base （MIB） 中</li>
</ul>
<h3 id="SNMP-protocol"><a href="#SNMP-protocol" class="headerlink" title="SNMP protocol"></a>SNMP protocol</h3><ul>
<li><p>传达 MIB 信息的两种方式，命令：</p>
<p>- </p>
</li>
<li></li>
</ul>
<p>​	因为知识点很多，这部分的笔记最开始是用思维导图记的，但是图片都不能导出，xmind格式的到<a href="https://pan.baidu.com/s/19RHNOMrGv91Ivx5g_i_z-A?pwd=c3m6">百度网盘</a>自行下载或者联系我私发叭，笔记效果如下（也不是那么好看，建议还是看PPT或者自己整理效率较高，我的笔记整理效果稍稍欠缺）：</p>

<div class="markmap-container" style="height:800px">
  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;第三章、网络层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;3.1介绍&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;网络层在主机和路由器实现，交换机无&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;网络层的关键功能&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;转发forwarding&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;路由routing（选路）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;网络层分为&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;数据平面data plane&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;本地的，每个路由都提供的功能&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;决定如何将路由器输入端口的数据报转发到输出端口&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;转发功能（通过判断到达数据报的头部就可以决定）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;控制平面control plane&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;network-wide logic网络范围的逻辑&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;决定数据报如何选择从哪个端口输出能到达目标主机&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;两个控制平面实现方法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;传统路由算法（每个路由器配置自己的算法）eg.Dijkstra算法&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;software-defined networking (SDN)全网实现，将硬件软件网络软件化（数据平面与控制平面分离&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;网络服务模式Network service model&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;单个数据报（individual datagrams）的服务&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;保证安全&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;保证不太慢less than 40 msec delay&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;数据报流（a flow of datagrams）的服务&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;有序的数据报传输&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;保证最小流量带宽&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;对数据包间距更改的限制&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;3.2虚拟电路（VC）和数据报电路网络&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;类似传输层服务，但服务面向host to host&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;网络只提供其中一种，所以没得选&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;实现在网络核心core（链路层为端口到端口）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;虚拟电路网络（简写为VC）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;提供网络层连接的服务&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;提供类似电路的服务&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;呼叫设置，在数据流动之前对每个呼叫进行拆解（teardown）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;每个数据包都带有 VC 标识符（identifier）（不是目标主机地址）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;source-dest路径上的每个路由器都为每个通过的连接维护（maintains）&amp;quot;状态&amp;quot;（建立连接后保持独享）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;链路，路由器资源（带宽、缓冲区）可以分配（allocated）给 VC&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;VC实现&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;包含&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;从源到目标的路径&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;VC 编号，沿路径的每个链路对应一个编号，属于VC的数据包都带有（新的编号来自转发表）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;沿路径的路由器转发表（forwarding tables ）中的条目（Entries）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;信令（signaling）协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;used to setup, maintain teardown VC&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;步骤：（包含端到端的状态，呼叫后预留）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;用在ATM, frame-relay, X.25&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;现在不用了&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;ATM适合，对时序要求很高，需保证服务，终端很笨（“dumb” end systems哑终端）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;数据报网络&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;提供网络层无连接的服务&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;在网络层无建立连接&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;路由器：没有关于端到端连接的状态（无网络级连接概念）不维护端与端之间的通信，只管转&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;用目标主机地址转发的数据包（同一源-目标端的数据包可能有不同的路径）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;Internet适合，终端处理能力强，对信道要求不高，“弹性elastic”服务&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;3.3路由器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[92,93]},&quot;v&quot;:&quot;Input port functions&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[94,95]},&quot;v&quot;:&quot;destination-based forwarding: forward based only on destination IP address (traditional)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;最长前缀匹配Longest prefix matching ppt25&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[98,99]},&quot;v&quot;:&quot;通常使用三元内容可寻址存储器（ternary content addressable memories TCAMs）执行（content addressable: present address to TCAM: retrieve address in one clock cycle, regardless of table size）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[99,100]},&quot;v&quot;:&quot;Cisco Catalyst: can up ~1M routing table entries in TCAM&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[101,102]},&quot;v&quot;:&quot;generalized forwarding: forward based on any set of header field values&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[103,104]},&quot;v&quot;:&quot;Input port queuing&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[105,106]},&quot;v&quot;:&quot;线头阻塞Head-of-the-Line blocking (HOL) :队列前面的排队数据报阻止队列中的其他数据报向前移动&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[107,108]},&quot;v&quot;:&quot;三种类型交换结构switching fabrics&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[111,112]},&quot;v&quot;:&quot;交换速率：数据包从输入传输到输出的速率&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[113,114]},&quot;v&quot;:&quot;通常测量为输入/输出线速的倍数&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[114,115]},&quot;v&quot;:&quot;N 个输入：开关速率 N 倍于线性速率&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[116,117]},&quot;v&quot;:&quot;Switching Via Memory&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[118,121]},&quot;v&quot;:&quot;在 CPU 直接控制下切换的传统计算机<br>\n数据包复制到系统内存<br>\n速度受内存带宽限制（每个数据报 2 个总线交叉点）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[122,123]},&quot;v&quot;:&quot;Switching Via a Bus&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[124,125]},&quot;v&quot;:&quot;通过共享总线从输入端口存储器到输出端口存储器的数据报&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[125,126]},&quot;v&quot;:&quot;总线争用❗bus contention：开关速度受总线带宽限制&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[126,127]},&quot;v&quot;:&quot;所有端口共享总线，易冲突，并行效率低 但对普通接入足够&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[128,129]},&quot;v&quot;:&quot;Switching Via An Interconnection Network通过交叉线交换&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[130,131]},&quot;v&quot;:&quot;每两个都有唯一的对应，提高并行效率&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[132,133]},&quot;v&quot;:&quot;Output Ports&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[134,135]},&quot;v&quot;:&quot;buffering缓冲&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[135,136]},&quot;v&quot;:&quot;Scheduling discipline 调度规则&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[137,138]},&quot;v&quot;:&quot;Priority scheduling（优先调度） – who gets best performance, network neutrality（网络中立性）&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[139,140]},&quot;v&quot;:&quot;Output port queueing&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[141,142]},&quot;v&quot;:&quot;how much buffering? P34&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[142,143]},&quot;v&quot;:&quot;Scheduling mechanisms调度机制&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[144,145]},&quot;v&quot;:&quot;FIFO (first in first out) scheduling先进先出&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[146,147]},&quot;v&quot;:&quot;discard policy丢弃策略&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[148,149]},&quot;v&quot;:&quot;tail drop丢掉后到的: drop arriving packet&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[149,150]},&quot;v&quot;:&quot;priority优先级: drop/remove on priority basis&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[150,151]},&quot;v&quot;:&quot;random随机: drop/remove randomly&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[151,152]},&quot;v&quot;:&quot;Round Robin (RR) scheduling轮询&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[152,153]},&quot;v&quot;:&quot;Weighted Fair Queuing (WFQ):加权轮询&quot;}]}]}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[154,155]},&quot;v&quot;:&quot;3.4 IP: Internet Protocol&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[156,157]},&quot;v&quot;:&quot;IP特点：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[158,159]},&quot;v&quot;:&quot;IP 为遍历网络的数据报提供路由功能&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[159,160]},&quot;v&quot;:&quot;每个数据报都有源地址和目标地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[160,161]},&quot;v&quot;:&quot;IP 确定数据报是否已到达其目标，或者是否必须转发数据报&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[162,163]},&quot;v&quot;:&quot;如果必须转发，IP 将确定下一跃点（next hop）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[164,165]},&quot;v&quot;:&quot;IP 不提供可靠性保证&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[166,167]},&quot;v&quot;:&quot;不保证数据包一定能到达其指定的目的地&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[168,169]},&quot;v&quot;:&quot;IP 负责数据报(datagram)的拆分（fragmentation）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[169,170]},&quot;v&quot;:&quot;数据报不能超过(exceed)其所传输网络的最大大小&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[171,172]},&quot;v&quot;:&quot;这在创建时未知&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[173,174]},&quot;v&quot;:&quot;太大的数据报必须分解为片段（fragments）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[174,175]},&quot;v&quot;:&quot;每个片段必须包含重新组合原始数据报所需的信息&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[176,177]},&quot;v&quot;:&quot;标有长度(length)和偏移量(offset)&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[178,179]},&quot;v&quot;:&quot;Workhorse 主力？&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[180,181]},&quot;v&quot;:&quot;3.4.1.IPv4 datagram format&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[182,183]},&quot;v&quot;:&quot;按位数分：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[184,185]},&quot;v&quot;:&quot;IPv4：32-bit* number&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[186,187]},&quot;v&quot;:&quot;Written in （点分十进制）Dotted Decimal Notation:205.150.58.7&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[187,188]},&quot;v&quot;:&quot;4 billion different host addresses&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[188,189]},&quot;v&quot;:&quot;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[189,191]},&quot;v&quot;:&quot;&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[191,192]},&quot;v&quot;:&quot;IPv6：128-bit* number&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[193,195]},&quot;v&quot;:&quot;Written in Hex Decimal Notation（十六进制）<br>\n2001:0503:0C27:0000:0000:0000:0000:0000&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[195,196]},&quot;v&quot;:&quot;16 billion billion network addresses&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[197,198]},&quot;v&quot;:&quot;IP Fragmentation拆分 &amp;amp; Reassembly组装&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[199,200]},&quot;v&quot;:&quot;网络链路有❗MTU (max.transfer size) 最大传输大小-最大可能的链路级帧（不同链路有不同的MTUs）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[200,201]},&quot;v&quot;:&quot;“reassembled组装” only at final destination&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[201,202]},&quot;v&quot;:&quot;IP header bits used to identify识别, order related fragments&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[202,203]},&quot;v&quot;:&quot;拆分计算&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[203,204]},&quot;v&quot;:&quot;检验是否有错&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[204,205]},&quot;v&quot;:&quot;IP路由操作命令&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[206,207]},&quot;v&quot;:&quot;winipcfg/(ipconfig)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[208,209]},&quot;v&quot;:&quot;显示用户所在主机内部的IP协议的配置信息P51&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[210,211]},&quot;v&quot;:&quot;. netstat&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[212,213]},&quot;v&quot;:&quot;主要功能：使用户了解到自己的主机是怎样与因特网相连的P53&quot;}]}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[214,215]},&quot;v&quot;:&quot;3.4.2IPv4 addressing&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[216,217]},&quot;v&quot;:&quot;从不同的层次看数据流动P56&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[217,218]},&quot;v&quot;:&quot;1、IP Address  Classes&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[219,220]},&quot;v&quot;:&quot;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[220,221]},&quot;v&quot;:&quot;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[221,222]},&quot;v&quot;:&quot;分配IP地址&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[223,224]},&quot;v&quot;:&quot;由于每个接口必须具有唯一的IP地址，因此必须有一个中央机构(central authority)来分配（assigning）号码&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[225,226]},&quot;v&quot;:&quot;这个中央机构为Internet Network Information Center, called the InterNIC.仅分配网络id，主机id的分配由系统管理员决定。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[226,227]},&quot;v&quot;:&quot;交换机无IP&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[227,228]},&quot;v&quot;:&quot;主机典型有一个interface&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[228,229]},&quot;v&quot;:&quot;路由器典型的有多个interfaces&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[230,231]},&quot;v&quot;:&quot;IP 地址的一些重要特点&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[232,233]},&quot;v&quot;:&quot;分两个等级的好处是：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[234,235]},&quot;v&quot;:&quot;IP地址管理机构在分配IP地址时只分配网络号，剩下的主机号由得到该网络号的单位自行分配，方便管理&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[235,236]},&quot;v&quot;:&quot;路由器仅根据目的主机所连接的网络号转发分组，无需考虑目的主机号（链路层来做），使路由表中的项目数大幅减少，减小路由表所占空间&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[237,238]},&quot;v&quot;:&quot;IP地址标志一个主机（或路由器）和一条链路的接口（interface）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[239,240]},&quot;v&quot;:&quot;多归属主机multihomed host（一个主机连接两个网络，有两个相应的IP地址（net-id））&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[240,241]},&quot;v&quot;:&quot;由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此一个路由器至少应当有两个不同的 IP 地址。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[242,243]},&quot;v&quot;:&quot;用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[243,244]},&quot;v&quot;:&quot;所有分配到网络号 net-id 的网络，范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[245,246]},&quot;v&quot;:&quot;IP层转发分组的流程&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[247,248]},&quot;v&quot;:&quot;特定主机路由（为特定的目的主机指明一个路由，方便网络管理人员控制和测试网络/考虑安全问题）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[248,249]},&quot;v&quot;:&quot;默认路由default route（网络只有很少的对外连接有用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[250,251]},&quot;v&quot;:&quot;路由器采用默认路由以减少路由表所占用的空间和搜索路由表所用的时间&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[252,253]},&quot;v&quot;:&quot;注：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[254,255]},&quot;v&quot;:&quot;当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的网络接口软件。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[255,256]},&quot;v&quot;:&quot;IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[256,257]},&quot;v&quot;:&quot;网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[258,259]},&quot;v&quot;:&quot;(1)  从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[259,260]},&quot;v&quot;:&quot;(2)  若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[260,261]},&quot;v&quot;:&quot;(3)  若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[261,262]},&quot;v&quot;:&quot;(4)  若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[262,263]},&quot;v&quot;:&quot;(5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[263,264]},&quot;v&quot;:&quot;(6)  报告转发分组出错。&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[265,266]},&quot;v&quot;:&quot;2、IP Subnet Addressing&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[267,268]},&quot;v&quot;:&quot;<strong>本地IP地址组成</strong>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[269,270]},&quot;v&quot;:&quot;<strong>network ID</strong>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[270,271]},&quot;v&quot;:&quot;<strong>subnet ID</strong>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[271,272]},&quot;v&quot;:&quot;<strong>host ID</strong>&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[273,274]},&quot;v&quot;:&quot;（1）Subnets and Subnet Masks子网和子网掩码&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[275,276]},&quot;v&quot;:&quot;(IP Address) AND (Subnet mask) = Net Address&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[279,281]},&quot;v&quot;:&quot;<strong>eg.不同的子网掩码得出❗相同的网络地址。<br>\n但不同的掩码的效果是不同的。 所以子网掩码是一个很重要的属性</strong>&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[282,283]},&quot;v&quot;:&quot;子网掩码是一个重要属性&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[284,285]},&quot;v&quot;:&quot;路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[285,286]},&quot;v&quot;:&quot;路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[287,288]},&quot;v&quot;:&quot;（2）Subnetting子网划分&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[289,290]},&quot;v&quot;:&quot;a.借多少位（上图为判断类别参考）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[291,292]},&quot;v&quot;:&quot;可以借的范围&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[293,294]},&quot;v&quot;:&quot;<strong>网络地址类别</strong>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:15,&quot;p&quot;:{&quot;lines&quot;:[295,296]},&quot;v&quot;:&quot;<strong>C 类：8 个主机位</strong>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:15,&quot;p&quot;:{&quot;lines&quot;:[296,297]},&quot;v&quot;:&quot;<strong>B 类：16 个主机位</strong>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:15,&quot;p&quot;:{&quot;lines&quot;:[297,298]},&quot;v&quot;:&quot;<strong>A 类：24 个主机位</strong>&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[299,300]},&quot;v&quot;:&quot;至少借两位：2^2-2=2个子网（全0和全1不用，所以减2）（子网和广播地址）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[301,302]},&quot;v&quot;:&quot;知道需要多少个子网和主机&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[303,304]},&quot;v&quot;:&quot;Host Bits = Bits Borrowed + Bits Left&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[304,305]},&quot;v&quot;:&quot;x为需要的子网数量&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[305,306]},&quot;v&quot;:&quot;x为需要的主机数量&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[307,308]},&quot;v&quot;:&quot;计算出结果&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[308,309]},&quot;v&quot;:&quot;<strong>❗注：形如192.168.15.0/26（C类）类型的网址/后的数字表示借多少位C类为24+借的位数，示例为借了2位</strong>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[310,311]},&quot;v&quot;:&quot;C类为24~32&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[311,312]},&quot;v&quot;:&quot;B类为16~32&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[312,313]},&quot;v&quot;:&quot;A类为8~32&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[314,315]},&quot;v&quot;:&quot;b.子网掩码subnet mask是什么&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[316,317]},&quot;v&quot;:&quot;对应的网络号也都赋值为1，借的位数（子网号）都赋值为1，对应（correspond）的主机号都赋值为0（预留出来的不用的主机），为子网掩码&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[318,320]},&quot;v&quot;:&quot;eg.一个C类网络IP：210.93.45.0，借3位（11111111.11111111.11111111.11100000）的<br>\n子网掩码为255.255.255.224&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[321,322]},&quot;v&quot;:&quot;c.magic number or multiplier?&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[323,324]},&quot;v&quot;:&quot;<strong>magic number=256-子网掩码点分后的最后一个非零数（Last Non-Zero Octet）</strong>&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[324,325]},&quot;v&quot;:&quot;magic number可视为划分后每个子网的主机数量（包含广播和主机的，也就是没-2的时候的）（自己理解的，非官方）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[325,326]},&quot;v&quot;:&quot;eg. Last Non-Zero Octet为224，例子中子网的migic number为256-224=32&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[326,327]},&quot;v&quot;:&quot;Last Non-Zero Octet表格（可计算得到）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[328,329]},&quot;v&quot;:&quot;d.子网地址是什么&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[330,332]},&quot;v&quot;:&quot;子网地址（主机号全为0的）：相较未被划分的IP地址（点分十进制）只改变借用位置部分的数（C类为最后一个，B类为倒数第二个，A类为倒数第三个）=第几个子网*magic number。<br>\n子网地址加上主机号就是子网地址（自己总结，非官方）&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[333,334]},&quot;v&quot;:&quot;（3）Logical AND Operation逻辑与操作&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[335,336]},&quot;v&quot;:&quot;设备使用 AND 计算（computation）来确定每个 IP 地址的子网标识符（the subnet identifier ）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[336,337]},&quot;v&quot;:&quot;如果本地 IP 地址的子网标识符与要与之通信的 IP 地址的子网标识符相同，则数据包将发送到本地子网上。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[337,338]},&quot;v&quot;:&quot;如果子网标识符不同，则数据包将发送到默认网关（default gateway ）或本地路由器，以路由到远程子网。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[339,340]},&quot;v&quot;:&quot;划分子网后分组如何转发？ PPT 131-136&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[341,342]},&quot;v&quot;:&quot;(1) 从收到的分组的首部提取目的IP地址D。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[342,343]},&quot;v&quot;:&quot;(2) 先用各网络的子网掩码和D逐比特相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行(3)。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[344,345]},&quot;v&quot;:&quot;相较上面的分组转发算法多了和D逐比特相“与”&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[346,347]},&quot;v&quot;:&quot;(3) 若路由表中有目的地址为D的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行(4)。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[347,348]},&quot;v&quot;:&quot;(4) 对路由表中的每一行的子网掩码和D逐比特相“与”，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行(5)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[349,350]},&quot;v&quot;:&quot;相较上面的分组转发算法多了和D逐比特相“与”&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[351,352]},&quot;v&quot;:&quot;(5) 若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行(6)。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[352,353]},&quot;v&quot;:&quot;(6) 报告转发分组出错。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[354,355]},&quot;v&quot;:&quot;得到一个IP地址的方式&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[356,357]},&quot;v&quot;:&quot;hard-coded硬编码 by system admin系统管理员 in a file&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[358,359]},&quot;v&quot;:&quot;好处：固定&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[359,360]},&quot;v&quot;:&quot;缺点：可能发生冲突&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[361,363]},&quot;v&quot;:&quot;DHCP: Dynamic Host Configuration Protocol: dynamically get address from as server<br>\n动态从服务器获取（即插即用plug-and-play）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[364,365]},&quot;v&quot;:&quot;目标：允许主机在加入网络时从网络服务器动态获取其 IP 地址&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[366,367]},&quot;v&quot;:&quot;可以在使用中的地址上续订其租约（renew its lease ）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[367,368]},&quot;v&quot;:&quot;允许重复使用地址（仅在连接/&amp;quot;打开&amp;quot;时保留地址）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[368,369]},&quot;v&quot;:&quot;支持想要加入网络的移动用户&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[370,371]},&quot;v&quot;:&quot;获取步骤&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[372,373]},&quot;v&quot;:&quot;主机广播&amp;quot;DHCP discover（DHCP发现报文）&amp;quot;消息 [可选]&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[373,374]},&quot;v&quot;:&quot;DHCP 服务器响应&amp;quot;DHCP offer（DHCP应答报文）&amp;quot;消息 [可选]&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[374,375]},&quot;v&quot;:&quot;主机请求 IP 地址：DHCP request（DHCP请求报文）&amp;quot;消息&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[375,376]},&quot;v&quot;:&quot;DHCP 服务器发送地址：&amp;quot;DHCP ack（DHCP确认报文）&amp;quot; 消息&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[377,378]},&quot;v&quot;:&quot;不仅可以返回子网上分配(allocated)的IP地址&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[379,380]},&quot;v&quot;:&quot;客户端的第一跃点路由器的地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[380,381]},&quot;v&quot;:&quot;DNS 服务器的名称和 IP 地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[381,382]},&quot;v&quot;:&quot;网络掩码（指示地址的网络与主机部分）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[383,384]},&quot;v&quot;:&quot;ISP从ICANN（ Internet Corporation for Assigned Names and Numbers）获取地址块&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[385,386]},&quot;v&quot;:&quot;分配地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[386,387]},&quot;v&quot;:&quot;管理 DNS&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[387,388]},&quot;v&quot;:&quot;分配域名，解决争议(resolves disputes)&quot;}]}]}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[389,390]},&quot;v&quot;:&quot;3.4.3.Slowing IP Address Depletion&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[393,394]},&quot;v&quot;:&quot;可变长度子网掩码Variable Length Subnet masks可变长度子网掩码VLSM&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[395,396]},&quot;v&quot;:&quot;将子网再次划分&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[396,397]},&quot;v&quot;:&quot;组成：network/subset/ VLSM subset /Host&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[398,399]},&quot;v&quot;:&quot;无类域间路由Classless Interdomain Routing&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[400,401]},&quot;v&quot;:&quot;Classless InterDomain Routing（CIDR）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[402,403]},&quot;v&quot;:&quot;任意长度的地址的子网部分&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[403,404]},&quot;v&quot;:&quot;地址格式：a.b.c.d/x，其中 x 是地址子网部分的 # 位，例子中的子网的所有地址的23位前缀都是一样的&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[405,406]},&quot;v&quot;:&quot;路由聚合(route aggregation)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[407,408]},&quot;v&quot;:&quot;一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[408,409]},&quot;v&quot;:&quot;路由聚合也称为构成超网(supernetting)。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[410,411]},&quot;v&quot;:&quot;前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C 类地址。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[411,412]},&quot;v&quot;:&quot;这些 C 类地址合起来就构成了超网。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[412,413]},&quot;v&quot;:&quot;CIDR 地址块中的地址数一定是 2 的整数次幂。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[413,414]},&quot;v&quot;:&quot;网络前缀越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[415,416]},&quot;v&quot;:&quot;CIDR 虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[416,417]},&quot;v&quot;:&quot;对于 /20  地址块，它的掩码是 20 个连续的 1。 斜线记法中的数字就是掩码中1的个数。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[418,419]},&quot;v&quot;:&quot;CIDR记法的其它形式&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[420,421]},&quot;v&quot;:&quot;10.0.0.0/10 可简写为 10/10，也就是把点分十进制中低位连续的 0 省略。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[424,425]},&quot;v&quot;:&quot;网络前缀的后面加一个星号 * 的表示方法，此方法可实现路由聚合&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[426,427]},&quot;v&quot;:&quot;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[427,433]},&quot;v&quot;:&quot;&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[433,434]},&quot;v&quot;:&quot;匹配/寻找方式&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[435,436]},&quot;v&quot;:&quot;选择两个匹配的地址中更具体的一个，即选择最长前缀的地址。&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[437,438]},&quot;v&quot;:&quot;网络地址转换NAT：Network Address Translation&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[439,440]},&quot;v&quot;:&quot;动机：就外部世界而言，本地网络仅使用一个IP地址&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[441,442]},&quot;v&quot;:&quot;ISP 不需要的地址范围：所有设备只需一个 IP 地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[442,443]},&quot;v&quot;:&quot;可以在不通知外界的情况下更改本地网络中设备的地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[443,444]},&quot;v&quot;:&quot;可以更改ISP，而无需更改本地网络中设备的地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[444,445]},&quot;v&quot;:&quot;本地网络内的设备无法明确寻址，外部世界可见（安全加分项）。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[446,447]},&quot;v&quot;:&quot;实现：NAT 路由器必须&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[448,449]},&quot;v&quot;:&quot;传出数据报(outgoing datagrams)：将每个传出数据报的（源 IP 地址、端口号(port #)）替换为（NAT IP 地址、新端口 #）远程客户端/服务器将使用（NAT IP 地址、新端口 #）作为目标地址进行响应。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[449,450]},&quot;v&quot;:&quot;记住（在 NAT 转换表中）每个（源 IP 地址、端口号）到（NAT IP 地址、新端口号）转换对&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[450,451]},&quot;v&quot;:&quot;传入数据报：将每个传入数据报的 dest 字段中的（NAT IP 地址、新端口号）替换为存储在 NAT 表中的相应（源 IP 地址、端口号）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[452,453]},&quot;v&quot;:&quot;16 位端口号字段：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[454,455]},&quot;v&quot;:&quot;60，000 个同时(simultaneous)连接，单个 LAN 端地址！&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[456,457]},&quot;v&quot;:&quot;NAT是有争议的：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[458,459]},&quot;v&quot;:&quot;路由器最多只能处理第 3 层&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[459,460]},&quot;v&quot;:&quot;违反端到端参数&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[461,462]},&quot;v&quot;:&quot;应用程序设计人员必须考虑NAT的可能性，例如，P2P应用程序&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[463,464]},&quot;v&quot;:&quot;地址短缺应该由IPv6解决&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[465,466]},&quot;v&quot;:&quot;3.4.4.IPv6&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[467,468]},&quot;v&quot;:&quot;初始动机：可以完全分配 32 位地址空间。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[468,469]},&quot;v&quot;:&quot;其他动机：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[470,471]},&quot;v&quot;:&quot;标头（header）格式有助于加快处理（processing）/转发（forwarding）速度&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[471,472]},&quot;v&quot;:&quot;标头更改以方便（facilitate） QoS&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[473,474]},&quot;v&quot;:&quot;IPv6 数据报格式：固定长度 40 字节标头&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[475,476]},&quot;v&quot;:&quot;不允许拆分（fragmentation）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[477,478]},&quot;v&quot;:&quot;数据报格式&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[479,480]},&quot;v&quot;:&quot;version:4bits（值为6“0110”）表示IPV6的报文&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[480,481]},&quot;v&quot;:&quot;有效载荷长度（Payload Length）：16 bit，以字节为单位的 IPv6 载荷长度，也就是 IPv6 报文基本头以后部分的长度（包括所有扩展头部分）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[481,482]},&quot;v&quot;:&quot;Priority:  8bits,identify priority among datagrams in flow确定流中数据报的优先级&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[482,483]},&quot;v&quot;:&quot;Flow Label:20bits, identify datagrams in same “flow.” 标识同一&amp;quot;流&amp;quot;中的数据报(concept of“flow” not well defined).&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[483,484]},&quot;v&quot;:&quot;Next header: 8bits下一个头部字段用来标识当前报头（或者扩展报头）的下一个头部类型，占8位。每种扩展报头都有其对应的值。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[484,485]},&quot;v&quot;:&quot;Hop Limit：8bits,ttl(time to live)&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[486,487]},&quot;v&quot;:&quot;过渡Transition From IPv4 To IPv6&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[488,489]},&quot;v&quot;:&quot;不能同时升级，有成本考虑&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[489,490]},&quot;v&quot;:&quot;采用隧道形式，将IPV6的报文伪装成IPV4的报文&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[493,494]},&quot;v&quot;:&quot;3.5路由算法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[497,498]},&quot;v&quot;:&quot;路由、转发之间的相互作用（Interplay）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[499,500]},&quot;v&quot;:&quot;路由协议目标&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[501,502]},&quot;v&quot;:&quot;通过路由器网络确定从发送主机到接收主机的&amp;quot;良好&amp;quot;路径（等效于路由）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[503,504]},&quot;v&quot;:&quot;路径：路由器数据包序列将从给定的初始源主机遍历到给定的最终目标主机&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[504,505]},&quot;v&quot;:&quot;&amp;quot;好&amp;quot;：最小&amp;quot;成本&amp;quot;，&amp;quot;最快&amp;quot;，&amp;quot;最不拥挤&amp;quot;&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[506,507]},&quot;v&quot;:&quot;路由算法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[508,509]},&quot;v&quot;:&quot;抽象图&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[510,511]},&quot;v&quot;:&quot;Graph: G = (N,E)图是由节点和边构成的&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[511,512]},&quot;v&quot;:&quot;N = set of routers = { u, v, w, x, y, z }节点的集合&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[512,513]},&quot;v&quot;:&quot;E = set of links ={ (u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z) }边的集合&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[514,515]},&quot;v&quot;:&quot;路由算法：查找成本最低的路径的算法&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[515,516]},&quot;v&quot;:&quot;分类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[517,518]},&quot;v&quot;:&quot;全局式Global&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[519,520]},&quot;v&quot;:&quot;所有路由器都有完整的拓扑结构，链路成本信息&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[520,521]},&quot;v&quot;:&quot;&amp;quot;链接状态（link-state）&amp;quot;算法&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[522,523]},&quot;v&quot;:&quot;分布式decentralized&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[524,525]},&quot;v&quot;:&quot;路由器知道物理连接的邻居，与邻居的链路成本&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[525,526]},&quot;v&quot;:&quot;迭代（iterative）计算过程，与邻居交换信息（info）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[526,527]},&quot;v&quot;:&quot;&amp;quot;距离矢量(distance vector)&amp;quot;算法&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[528,529]},&quot;v&quot;:&quot;静态Static&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[530,531]},&quot;v&quot;:&quot;路由随时间缓慢变化&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[532,533]},&quot;v&quot;:&quot;动态dynamic&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[534,535]},&quot;v&quot;:&quot;路线变化更快&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[536,537]},&quot;v&quot;:&quot;定期(periodic)更新&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[537,538]},&quot;v&quot;:&quot;响应链路成本变化&quot;}]}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[539,540]},&quot;v&quot;:&quot;link state链路状态路由算法Dijkstra’s algorithm&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[541,542]},&quot;v&quot;:&quot;网络拓扑topology，链路花销为所有节点都知道&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[543,544]},&quot;v&quot;:&quot;通过&amp;quot;链路状态广播(link state broadcast)&amp;quot;完成accomplished&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[544,545]},&quot;v&quot;:&quot;所有节点都具有相同的信息&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[546,547]},&quot;v&quot;:&quot;计算从一个节点（&amp;quot;源sorce&amp;quot;）到所有其他节点的最低成本路径&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[548,549]},&quot;v&quot;:&quot;为该节点提供转发表&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[550,551]},&quot;v&quot;:&quot;迭代：在 k 次迭代之后，知道到 k 个 dest 的最小成本路径。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[551,558]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[553,554]},&quot;v&quot;:&quot;c(x,y): link cost from node x to y;  = ∞ if not direct neighbors&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[554,555]},&quot;v&quot;:&quot;D(v): current value of cost of path from source to dest. v&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[555,556]},&quot;v&quot;:&quot;p(v): predecessor node along path from source to v&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[556,557]},&quot;v&quot;:&quot;N': set of nodes whose least cost path definitively known&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[558,559]},&quot;v&quot;:&quot;算法复杂度：n 个节点&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[560,561]},&quot;v&quot;:&quot;每次迭代：需要检查所有节点，w，不在N&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[561,562]},&quot;v&quot;:&quot;n(n+1)/2  comparisons: O(n2)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[562,563]},&quot;v&quot;:&quot;可实现更高效的实现：O（nlogn）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[563,564]},&quot;v&quot;:&quot;可能的振荡：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[565,566]},&quot;v&quot;:&quot;例如，刚算出走这个节点，下次迭代就是另一个结点更近&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[566,568]},&quot;v&quot;:&quot;&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[568,569]},&quot;v&quot;:&quot;distance vector距离向量算法（分布式decentralized）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[570,571]},&quot;v&quot;:&quot;Bellman-Ford equation方程 (dynamic programming动态规划)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[574,580]},&quot;v&quot;:&quot;Dx(y) = estimate of least cost from x to y<br>\nDistance vector: Dx = [Dx(y): y є N ]<br>\nNode x knows cost to each neighbor v: c(x,v)<br>\nNode x maintains Dx = [Dx(y): y є N ]<br>\nNode x also maintains its neighbors’ distance vectors<br>\nFor each neighbor v, x maintains Dv = [Dv(y): y є N ]&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[581,582]},&quot;v&quot;:&quot;基本思想：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[583,584]},&quot;v&quot;:&quot;每个节点定期向邻居发送自己的距离矢量估计值&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[584,585]},&quot;v&quot;:&quot;当节点 x 从邻居处收到新的 DV 估计值时，它将使用 B-F 等式更新自己的 DV：&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[585,586]},&quot;v&quot;:&quot;在次要的自然条件下，估计值 Dx（y） 收敛到实际最小成本 dx（y）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[586,588]},&quot;v&quot;:&quot;&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[588,589]},&quot;v&quot;:&quot;迭代iterative：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[590,591]},&quot;v&quot;:&quot;本地链路成本更改&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[591,592]},&quot;v&quot;:&quot;来自邻居的 DV 更新消息&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[593,594]},&quot;v&quot;:&quot;分散式distributed：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[595,596]},&quot;v&quot;:&quot;每个节点仅在其 DV 更改时通知邻居&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[597,598]},&quot;v&quot;:&quot;然后，如有必要，邻居会通知邻居&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[599,600]},&quot;v&quot;:&quot;链接成本变化：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[601,602]},&quot;v&quot;:&quot;节点检测到本地链路开销变化&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[602,603]},&quot;v&quot;:&quot;更新路线信息，重新计算距离矢量&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[603,604]},&quot;v&quot;:&quot;如果 DV 发生变化，通知邻居&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[604,605]},&quot;v&quot;:&quot;好消息传播的快，坏消息传播缓慢 - &amp;quot;数到无穷大&amp;quot;的问题！&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[606,607]},&quot;v&quot;:&quot;Comparison of LS and DV algorithms&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[608,609]},&quot;v&quot;:&quot;Message complexity消息复杂性&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[610,611]},&quot;v&quot;:&quot;LS: with n nodes, E links, O(nE) msgs sent&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[611,612]},&quot;v&quot;:&quot;DV: exchange between neighbors only&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[613,614]},&quot;v&quot;:&quot;convergence time varies收敛时间不定&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[615,616]},&quot;v&quot;:&quot;Speed of Convergence收敛速度&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[617,618]},&quot;v&quot;:&quot;LS: O(n2) algorithm requires O(nE) msgs&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[619,620]},&quot;v&quot;:&quot;may have oscillations 可能有振荡，但是不易产生路由环路&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[621,622]},&quot;v&quot;:&quot;DV: convergence time varies&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[623,624]},&quot;v&quot;:&quot;may be routing loops可能是路由环路&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[624,625]},&quot;v&quot;:&quot;count-to-infinity problem数到无穷大问题&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[626,627]},&quot;v&quot;:&quot;Robustness: what happens if router malfunctions?鲁棒性（强壮与健壮，系统在异常情况下的生存能力）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[628,629]},&quot;v&quot;:&quot;LS:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[630,631]},&quot;v&quot;:&quot;节点可以公布（advertise ）不正确的链接（link）开销&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[631,632]},&quot;v&quot;:&quot;每个节点仅计算（computes ）自己的表&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[633,634]},&quot;v&quot;:&quot;DV:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[635,636]},&quot;v&quot;:&quot;节点可以公布（advertise ）不正确的路径（path ）开销&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[636,637]},&quot;v&quot;:&quot;每个节点的表都被其他表使用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[638,639]},&quot;v&quot;:&quot;error propagate thru network错误通过网络传播&quot;}]}]}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[640,641]},&quot;v&quot;:&quot;3.6 Routing in the Internet&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[642,643]},&quot;v&quot;:&quot;Hierarchical routing层次路由&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[644,647]},&quot;v&quot;:&quot;由于规模大不能存储所有目标<br>\n行政自主权（administrative autonomy）<br>\n两个问题产生层次路由&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[648,649]},&quot;v&quot;:&quot;将路由器聚合到称为“autonomous systems”（AS）的区域（也称为&amp;quot;domains&amp;quot;）中&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[650,651]},&quot;v&quot;:&quot;自治系统 (Autonomous System)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[655,657]},&quot;v&quot;:&quot;intra-AS routing<br>\nAS 内路由&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[658,659]},&quot;v&quot;:&quot;也称为内部网关协议 （interior gateway protocols ，IGP）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[660,661]},&quot;v&quot;:&quot;最常见的 AS 内路由协议：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[662,663]},&quot;v&quot;:&quot;RIP：Routing Information Protocol路由信息协议&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[663,664]},&quot;v&quot;:&quot;OSPF：开放最短路径优先Open Shortest Path First（IS-IS协议（本质为OSPF）与OSPF基本相同）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:13,&quot;p&quot;:{&quot;lines&quot;:[664,665]},&quot;v&quot;:&quot;IGRP：内部网关路由协议:Interior Gateway Routing Protocol （思科专有数十年，直到2016年）&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[666,667]},&quot;v&quot;:&quot;在同一AS（&amp;quot;网络&amp;quot;）中，主机、路由器之间路由&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[667,668]},&quot;v&quot;:&quot;AS 中的所有路由器必须运行相同的域内（intra-domain）协议&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[668,669]},&quot;v&quot;:&quot;不同 AS 中的路由器可以运行不同的域内路由协议&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[669,670]},&quot;v&quot;:&quot;网关路由器（gateway router）：在其自身 AS 的&amp;quot;边缘&amp;quot;，具有到其他 AS 中的路由器的链接&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[671,673]},&quot;v&quot;:&quot;inter-AS routing<br>\nAS 间路由&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[674,675]},&quot;v&quot;:&quot;在 AS 之间路由&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[675,676]},&quot;v&quot;:&quot;网关（gateways）执行域间路由（以及域内路由）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[677,678]},&quot;v&quot;:&quot;总结：为什么Intra-, Inter-AS routing 不同&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[679,680]},&quot;v&quot;:&quot;policy:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[681,682]},&quot;v&quot;:&quot;inter-AS（AS间路由）: 管理员希望控制其流量如何路由，谁通过其网络路由。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[682,683]},&quot;v&quot;:&quot;intra-AS（AS内路由）: 单个管理员，因此不需要策略决策&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[684,685]},&quot;v&quot;:&quot;scale:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[686,687]},&quot;v&quot;:&quot;分层路由可以节省表的大小，减少更新流量（traffic）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[688,689]},&quot;v&quot;:&quot;performance:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[690,691]},&quot;v&quot;:&quot;intra-AS: 专注于性能&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[691,692]},&quot;v&quot;:&quot;inter-AS: 政策可能支配性能&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[693,694]},&quot;v&quot;:&quot;Interconnected ASes互连的 AS&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[695,696]},&quot;v&quot;:&quot;转发表由 AS 内intra-AS和 AS 间inter-AS 路由算法配置&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[696,697]},&quot;v&quot;:&quot;AS 内部路由设置内部目标（internal dests）的转发表的条目entries&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[697,698]},&quot;v&quot;:&quot;AS 间和 AS 内设置外部目标的转发表的条目entries&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[699,703]},&quot;v&quot;:&quot;Inter-AS tasks(AS间任务)：<br>\n1.了解哪些目标主机可通过邻接的AS访问<br>\n2.并将这些可访问信息传播到此AS中的所有路由器(AS内协议执行)。以便知道有任务时传给哪个<br>\neg.P208&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[704,705]},&quot;v&quot;:&quot;Hot potato routing：将数据包发送到两个路由器中最近的一个&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[706,707]},&quot;v&quot;:&quot;有关路由选择协议的几个基本概念&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[710,716]},&quot;v&quot;:&quot;算法必须是正确的和完整的。<br>\n算法在计算上应简单。<br>\n算法应能适应通信量和网络拓扑的变化，这就是说，要有自适应性。<br>\n算法应具有稳定性。<br>\n算法应是公平的。<br>\n算法应是最佳的。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[708,709],&quot;index&quot;:1},&quot;v&quot;:&quot;1. 理想的路由算法&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[717,718]},&quot;v&quot;:&quot;2.关于“最佳路由”&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[726,727]},&quot;v&quot;:&quot;3.从路由算法的自适应性考虑&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[728,729]},&quot;v&quot;:&quot;静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[729,730]},&quot;v&quot;:&quot;动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[731,732]},&quot;v&quot;:&quot;4.分层次的路由选择协议&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[737,738]},&quot;v&quot;:&quot;5.因特网有两大类路由选择协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[739,740]},&quot;v&quot;:&quot;内部网关协议 IGP (Interior Gateway Protocol)    即在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[740,741]},&quot;v&quot;:&quot;外部网关协议EGP (External Gateway Protocol)    若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。在外部网关协议中目前使用最多的是 BGP-4。&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[742,743]},&quot;v&quot;:&quot;RIP路由选择信息协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[744,776]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;ordered_list&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[744,746],&quot;start&quot;:1},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[744,745],&quot;index&quot;:1},&quot;v&quot;:&quot;1. 工作原理&quot;}]},{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[746,776]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[746,747]},&quot;v&quot;:&quot;路由信息协议 RIP 是内部网关协议 IGP中最先得到广泛使用的协议。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[748,749]},&quot;v&quot;:&quot;RIP 是一种分布式的基于距离向量的路由选择协议。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[750,751]},&quot;v&quot;:&quot;RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[752,753]},&quot;v&quot;:&quot;“距离”的定义&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[763,764]},&quot;v&quot;:&quot;<strong>三个要点：</strong>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[765,766]},&quot;v&quot;:&quot;仅和相邻路由器交换信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[766,767]},&quot;v&quot;:&quot;交换的信息是当前本路由器所知道的全部信息，即自己的路由表。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[767,768]},&quot;v&quot;:&quot;按固定的时间间隔交换路由信息，例如，每隔 30 秒。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[769,770]},&quot;v&quot;:&quot;路由表的建立&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[771,772]},&quot;v&quot;:&quot;路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为1）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[772,773]},&quot;v&quot;:&quot;以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[773,774]},&quot;v&quot;:&quot;经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[774,775]},&quot;v&quot;:&quot;RIP 协议的收敛(convergence)过程较快，即在自治系统中所有的结点都得到正确的路由选择信息的过程。&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[776,784]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;ordered_list&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[776,778],&quot;start&quot;:2},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[776,777],&quot;index&quot;:2},&quot;v&quot;:&quot;2. 距离向量算法&quot;}]},{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[778,784]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[778,779]},&quot;v&quot;:&quot;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[779,780]},&quot;v&quot;:&quot;路由器之间交换信息&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[781,782]},&quot;v&quot;:&quot;RIP协议让互联网中的所有路由器都和自己的相邻路由器不断交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最少）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[782,783]},&quot;v&quot;:&quot;虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[784,785]},&quot;v&quot;:&quot;RIP 协议的优缺点&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[786,787]},&quot;v&quot;:&quot;RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。（好消息传播得快，而坏消息传播得慢）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[787,788]},&quot;v&quot;:&quot;RIP 协议最大的优点就是实现简单，开销较小。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[788,789]},&quot;v&quot;:&quot;RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[789,790]},&quot;v&quot;:&quot;路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[791,792]},&quot;v&quot;:&quot;OSPF （Open Shortest Path First）首先打开最短路径&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[793,794]},&quot;v&quot;:&quot;介绍&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[795,796]},&quot;v&quot;:&quot;&amp;quot;开放&amp;quot;：公开可用&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[797,798]},&quot;v&quot;:&quot;使用link-state算法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[799,800]},&quot;v&quot;:&quot;链路状态数据包分发（dissemination）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[800,801]},&quot;v&quot;:&quot;每个节点的拓扑图&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[801,802]},&quot;v&quot;:&quot;使用Dijkstra算法的路由计算&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[803,804]},&quot;v&quot;:&quot;路由器将 OSPF 链路状态通告扩散（floods）到整个 AS 中的所有其他路由器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[805,806]},&quot;v&quot;:&quot;直接通过 IP（而不是 TCP 或 UDP）在 OSPF 消息中传输&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[811,812]},&quot;v&quot;:&quot;链接状态：对于每个附加（attached）的链接&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[813,814]},&quot;v&quot;:&quot;IS-IS 路由协议：几乎与 OSPF 相同&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[815,816]},&quot;v&quot;:&quot;高级功能&amp;quot;advanced” features&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[817,818]},&quot;v&quot;:&quot;安全性security：所有 OSPF 消息都经过身份验证（authenticated）（以防止恶意入侵（malicious intrusion））&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[818,819]},&quot;v&quot;:&quot;允许多个相同成本的路径（RIP 中只有一个路径）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[819,820]},&quot;v&quot;:&quot;对于每个链路，针对不同 TOS 的多个成本指标（例如，卫星链路成本设置为“low”以实现&amp;quot;尽力而为ToS&amp;quot;，&amp;quot;high&amp;quot;用于实时 ToS）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[820,821]},&quot;v&quot;:&quot;集成的integrated，支持单播和多播uni- and multi-cast：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[822,823]},&quot;v&quot;:&quot;Multicast  OSPF （MOSPF） 使用与 OSPF 相同的拓扑数据库&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[824,825]},&quot;v&quot;:&quot;大型域中的hierarchical OSPF。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[826,827]},&quot;v&quot;:&quot;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[827,828]},&quot;v&quot;:&quot;两级层次结构two-level hierarchy：局部区域local area、骨干网backbone。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[829,830]},&quot;v&quot;:&quot;链接状态广告仅在区域内&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[830,831]},&quot;v&quot;:&quot;每个节点都有详细的区域拓扑;只知道方向(最短路径)到网的其他区域。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[832,833]},&quot;v&quot;:&quot;区域边界路由器area border routers：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[834,835]},&quot;v&quot;:&quot;&amp;quot;汇总&amp;quot;到自己区域内网络的距离，通告给其他区域边界路由器。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[836,837]},&quot;v&quot;:&quot;骨干路由器backbone routers：运行仅限于骨干网的 OSPF 路由。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[837,838]},&quot;v&quot;:&quot;边界路由器boundary routers：连接到其他 AS（自治系统）。&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[839,840]},&quot;v&quot;:&quot;三个要点&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[841,842]},&quot;v&quot;:&quot;向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[842,843]},&quot;v&quot;:&quot;发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[844,845]},&quot;v&quot;:&quot;“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[846,847]},&quot;v&quot;:&quot;只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[848,849]},&quot;v&quot;:&quot;其他特点&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[850,851]},&quot;v&quot;:&quot;OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[851,852]},&quot;v&quot;:&quot;由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[852,853]},&quot;v&quot;:&quot;OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[854,855]},&quot;v&quot;:&quot;指定的路由器(designated router) ？？？&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[856,857]},&quot;v&quot;:&quot;多点接入的局域网采用了指定的路由器的方法，使广播的信息量大大减少。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[857,858]},&quot;v&quot;:&quot;指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[859,860]},&quot;v&quot;:&quot;Internet inter-AS ：BGP routing（Border Gateway Protocol）实际的域间路由协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[861,862]},&quot;v&quot;:&quot;BGP为每个AS提供了一种方法:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[863,864]},&quot;v&quot;:&quot;eBGP:向邻居as获取子网可达性信息&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[864,865]},&quot;v&quot;:&quot;iBGP:向所有as内部路由器传播可达性信息。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[865,866]},&quot;v&quot;:&quot;根据可达性信息和策略确定到其他网络的“良好”路由&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[867,868]},&quot;v&quot;:&quot;允许子网将它的存在通告给Internet的其他部分:“我在这里“&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[868,869]},&quot;v&quot;:&quot;BGP session：两个 BGP 路由器（&amp;quot;peer&amp;quot;）通过半永久性(semi-permanent) TCP 连接交换 BGP 消息：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[870,871]},&quot;v&quot;:&quot;发布到不同目的网络前缀的路径（BGP 是&amp;quot;path vector&amp;quot;协议）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[872,873]},&quot;v&quot;:&quot;路径属性和 BGP 路由&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[874,875]},&quot;v&quot;:&quot;播发的前缀(advertised prefix)包括 BGP 属性&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[876,877]},&quot;v&quot;:&quot;前缀 + 属性 = &amp;quot;路由&amp;quot;（prefix + attributes = “route”）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[878,879]},&quot;v&quot;:&quot;两个重要属性：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[880,881]},&quot;v&quot;:&quot;AS-PATH：前缀advertisement经过的AS列表&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[881,882]},&quot;v&quot;:&quot;NEXT-HOP：指定到达下一跳AS的域内AS路由器&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[883,884]},&quot;v&quot;:&quot;基于策略的路由Policy-based routing：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[885,886]},&quot;v&quot;:&quot;网关接收路由通告使用导入策略来接受/拒绝路径&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[886,887]},&quot;v&quot;:&quot;AS 策略还确定是否将路径通告到其他相邻的 AS&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[888,889]},&quot;v&quot;:&quot;BGP路径通告&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[890,891]},&quot;v&quot;:&quot;网关路由器可以了解到目的地的多个路径&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[892,893]},&quot;v&quot;:&quot;AS1 网关路由器 1c 从 2a 学习路径 AS2、AS3、X&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[893,894]},&quot;v&quot;:&quot;AS1 网关路由器 1c 从 3a 学习路径 AS3，X&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[894,895]},&quot;v&quot;:&quot;AS1 网关路由器 1c 根据策略选择路径 AS3、X，并通过 iBGP 在 AS1 中通告路径&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[896,897]},&quot;v&quot;:&quot;BGP 报文（message）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[898,899]},&quot;v&quot;:&quot;通过 TCP 连接在对等方之间交换的 BGP 报文&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[899,900]},&quot;v&quot;:&quot;报文类型：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[901,902]},&quot;v&quot;:&quot;OPEN：打开与远程 BGP 对等体的 TCP 连接，并对要发送的 BGP 对等体进行身份验证authenticates&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[902,903]},&quot;v&quot;:&quot;UPDATE：公布新路径（或撤回旧路径）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[903,904]},&quot;v&quot;:&quot;KEEPALIVE：在没有UPDATE的情况下保持连接活跃;还 ACK 打开请求&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[904,905]},&quot;v&quot;:&quot;NOTIFICATION：报告以前的消息中的错误;也用于关闭连接&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[906,907]},&quot;v&quot;:&quot;路由器可以了解到目标 AS 的多个路由，根据以下条件选择路由：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[908,909]},&quot;v&quot;:&quot;本地首选项值属性(local preference value attribute)：策略决策(policy decision)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[909,910]},&quot;v&quot;:&quot;最短的 AS 路径shortest AS-PATH&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[910,911]},&quot;v&quot;:&quot;最近的下一跳路由器(closest NEXT-HOP router)：热土豆路由hot potato routing&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[911,912]},&quot;v&quot;:&quot;其他标准additional criteria&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[913,914]},&quot;v&quot;:&quot;BGP协议的特点&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[915,916]},&quot;v&quot;:&quot;BGP 协议交换路由信息的结点数量级是自治系统数的量级，这要比这些自治系统中的网络数少很多。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[916,917]},&quot;v&quot;:&quot;每一个自治系统中 BGP 发言人（或边界路由器）的数目是很少的。这样就使得自治系统之间的路由选择不致过分复杂。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[917,918]},&quot;v&quot;:&quot;BGP 支持 CIDR，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[918,919]},&quot;v&quot;:&quot;在BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销方面都有好处。&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[920,921]},&quot;v&quot;:&quot;3.7 广播路由和多播路由&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[924,925]},&quot;v&quot;:&quot;IP多播&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[926,927]},&quot;v&quot;:&quot;多播可明显地减少网络中资源的消耗&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[927,928]},&quot;v&quot;:&quot;IP多播特点（只在局域网内使用）：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[929,930]},&quot;v&quot;:&quot;(1) 多播使用组地址—— IP 使用 D 类地址支持多播。多播地址只能用于目的地址，而不能用于源地址。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[930,931]},&quot;v&quot;:&quot;(2) 永久组地址——由因特网号码指派管理局 IANA 负责指派。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[931,932]},&quot;v&quot;:&quot;(3) 动态的组成员&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[932,933]},&quot;v&quot;:&quot;(4) 使用硬件进行多播&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[934,935]},&quot;v&quot;:&quot;IP多播需要两种协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[936,937]},&quot;v&quot;:&quot;为了使路由器知道多播组成员的信息，需要利用网际组管理协议 IGMP (Internet Group Management Protocol)。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[938,939]},&quot;v&quot;:&quot;IGMP 的本地使用范围&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[940,941]},&quot;v&quot;:&quot;IGMP 并非在因特网范围内对所有多播组成员进行管理的协议。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[941,942]},&quot;v&quot;:&quot;IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[942,943]},&quot;v&quot;:&quot;IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机（严格讲，是主机上的某个进程）参加或退出了某个多播组。&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[944,945]},&quot;v&quot;:&quot;连接在局域网上的多播路由器还必须和因特网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用多播路由选择协议。&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[946,947]},&quot;v&quot;:&quot;3.8 ICMP: Internet Control Message Protocol网络控制消息协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[948,949]},&quot;v&quot;:&quot;用于主机和路由器之间的网络级信息通信&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[950,951]},&quot;v&quot;:&quot;错误报告error reporting:不可达的主机，网络，端口，协议&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[951,952]},&quot;v&quot;:&quot;Echo请求/应答(由ping使用)&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[953,954]},&quot;v&quot;:&quot;网络层”高于“IP:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[955,956]},&quot;v&quot;:&quot;IP数据报中携带的ICMP消息&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[957,958]},&quot;v&quot;:&quot;ICMP报文:类型、代码加导致错误的IP数据报的前8个字节&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[961,962]},&quot;v&quot;:&quot;Traceroute and ICMP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[963,964]},&quot;v&quot;:&quot;Source发送一系列 UDP 段&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[965,966]},&quot;v&quot;:&quot;首先具有 TTL =1&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[966,967]},&quot;v&quot;:&quot;第二个有 TTL=2，依此类推。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[967,968]},&quot;v&quot;:&quot;不太可能的端口号&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[969,970]},&quot;v&quot;:&quot;当第 n 个数据报到达第 n 个路由器时：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[971,972]},&quot;v&quot;:&quot;路由器丢弃数据报并发送到源 ICMP 消息（类型 11，代码 0）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[972,973]},&quot;v&quot;:&quot;消息包括路由器和IP地址的名称&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[974,975]},&quot;v&quot;:&quot;当 ICMP 消息到达时，Source计算 RTT&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[975,976]},&quot;v&quot;:&quot;Traceroute 会执行此操作 3 次&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[976,977]},&quot;v&quot;:&quot;停止标准（criterion）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[978,979]},&quot;v&quot;:&quot;UDP 段最终到达目标主机&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[979,980]},&quot;v&quot;:&quot;目标返回 ICMP&amp;quot;主机无法访问&amp;quot;数据包（类型 3，代码 3）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[980,981]},&quot;v&quot;:&quot;当源获得此 ICMP 时，将停止。&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[982,983]},&quot;v&quot;:&quot;ICMP的实用程序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[984,985]},&quot;v&quot;:&quot;（1）.Ping&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[986,987]},&quot;v&quot;:&quot;主要功能： PING用来测试两个主机之间的连通性。PING使用了ICMP回送请求与回送回答报文。PING是应用层直接使用网络层ICMP的例子，它没有通过运输层的 TCP或UDP。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[988,989]},&quot;v&quot;:&quot;使用格式：ping [-t] [-a] [-n count] [-l size]&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[990,991]},&quot;v&quot;:&quot;参数介绍：&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[997,998]},&quot;v&quot;:&quot;ping命令的其他技巧：&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1001,1002]},&quot;v&quot;:&quot;（2）.tracert&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1003,1004]},&quot;v&quot;:&quot;使用格式：tracert [-d] [-h maximum_hops] [-j host_list] [-w timeout]&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1004,1005]},&quot;v&quot;:&quot;参数介绍：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[1006,1007]},&quot;v&quot;:&quot;-d 不解析目标主机的名字&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[1007,1008]},&quot;v&quot;:&quot;-h maximum_hops 指定搜索到目标地址的最大跳跃数&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[1008,1009]},&quot;v&quot;:&quot;-j host_list 按照主机列表中的地址释放源路由&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[1009,1010]},&quot;v&quot;:&quot;-w timeout 指定超时时间间隔，程序默认的时间单位是毫秒&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1011,1012]},&quot;v&quot;:&quot;主要功能：判定数据包到达目的主机所经过的路径、显示数据包经过的中继节点清单和到达时间。&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1013,1014]},&quot;v&quot;:&quot;3.9 Network management and SNMP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1015,1016]},&quot;v&quot;:&quot;network management：什么是网络管理？&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1020,1021]},&quot;v&quot;:&quot;Infrastructure for network management网络管理基础架构&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1022,1023]},&quot;v&quot;:&quot;受管设备包含受管对象，其数据被收集到管理信息库 Management Information Base （MIB） 中&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1024,1025]},&quot;v&quot;:&quot;SNMP protocol&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1026,1027]},&quot;v&quot;:&quot;传达 MIB 信息的两种方式，命令：&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1030,1034]},&quot;v&quot;:&quot;&quot;}]}]}]}">
</svg></div>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章、传输层</title>
    <url>/2023/01/11/di-si-zhang-chuan-shu-ceng/</url>
    <content><![CDATA[<h1 id="第四章、传输层"><a href="#第四章、传输层" class="headerlink" title="第四章、传输层"></a>第四章、传输层</h1><h2 id="4-1-transport-layer-services"><a href="#4-1-transport-layer-services" class="headerlink" title="4.1 transport-layer services"></a>4.1 transport-layer services</h2><h3 id="在不同主机上运行的应用进程之间提供逻辑通信（logical-communication）"><a href="#在不同主机上运行的应用进程之间提供逻辑通信（logical-communication）" class="headerlink" title="在不同主机上运行的应用进程之间提供逻辑通信（logical communication）"></a>在不同主机上运行的应用进程之间提供逻辑通信（logical communication）</h3><h3 id="在终端系统中运行的传输协议"><a href="#在终端系统中运行的传输协议" class="headerlink" title="在终端系统中运行的传输协议"></a>在终端系统中运行的传输协议</h3><ul>
<li>发送端：将应用消息分成段（segments），传递到网络层</li>
<li>接收端rcv side：将段重新组合成消息，传递到应用层</li>
</ul>
<h3 id="多个传输协议可用于应用"><a href="#多个传输协议可用于应用" class="headerlink" title="多个传输协议可用于应用"></a>多个传输协议可用于应用</h3><ul>
<li>互联网：TCP和UDP</li>
</ul>
<h3 id="Transport-vs-network-layer"><a href="#Transport-vs-network-layer" class="headerlink" title="Transport vs. network layer"></a>Transport vs. network layer</h3><ul>
<li><p>网络层：主机之间的逻辑通信</p>
</li>
<li><p>传输层：进程之间的逻辑通信（processes）</p>
<p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。<br>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。<br>两个主机进行通信实际上就是两个主机中的应用进程互相通信。<br>应用进程之间的通信又称为端到端的通信。 </p>
<ul>
<li>运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。</li>
<li>“运输层提供应用进程间的逻辑通信”。“逻辑通信”的意思是：运输层之间的通信好像是沿水平方向传送数据。但事实上这两个运输层之间并没有一条水平方向的物理连接。</li>
</ul>
</li>
<li><p>传输层依赖(relies on)、增强(enhances)网络层服务</p>
<ul>
<li>依赖于网络层的服务 ：延时、带宽</li>
<li>并对网络层的服务进行增强： 数据丢失、顺序混乱、加密</li>
<li>有些服务是可以加强的：不可靠 -&gt; 可靠；安全</li>
<li>但有些服务是不可以被加强的：带宽，延迟</li>
</ul>
</li>
</ul>
<h3 id="传输层的主要功能"><a href="#传输层的主要功能" class="headerlink" title="传输层的主要功能"></a>传输层的主要功能</h3><ul>
<li>传输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）。</li>
<li>传输层还要对收到的报文进行差错检测。</li>
<li>传输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。</li>
</ul>
<h3 id="两种不同的运输协议"><a href="#两种不同的运输协议" class="headerlink" title="两种不同的运输协议"></a>两种不同的运输协议</h3><p>运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p>
<ul>
<li><p>当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。</p>
</li>
<li><p>当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。 </p>
</li>
<li><p>TCP/IP 的传输层有两个不同的协议：</p>
<ul>
<li>(1) 用户数据报协议 UDP	(User Datagram Protocol)</li>
<li>(2) 传输控制协议 TCP(Transmission Control Protocol)</li>
</ul>
</li>
</ul>
<h3 id="协议特点："><a href="#协议特点：" class="headerlink" title="协议特点："></a>协议特点：</h3><ul>
<li><p>可靠的有序交付 （TCP）</p>
<ul>
<li>拥塞控制congestion control </li>
<li>流控制flow control</li>
<li>连接建立connection setup</li>
</ul>
</li>
<li><p>不可靠、无序递交付（delivery）：UDP</p>
<ul>
<li>没有为尽力而为的IP服务添加更多的其它额外服务</li>
</ul>
</li>
<li><p>不可用的服务：</p>
<ul>
<li>延迟保证delay guarantees</li>
<li>带宽保证bandwidth guarantees</li>
</ul>
</li>
</ul>
<h3 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h3><p>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU (Transport Protocol Data Unit)。<br>TCP 传送的数据单位协议是 TCP 报文段(segment)<br>UDP 传送的数据单位协议是 UDP 报文或用户数据报。<br>UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。<br>TCP 则提供面向连接的服务。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。<br>运输层的 UDP 用户数据报与网际层的IP数据报有很大区别。IP 数据报要经过互连网中许多路由器的存储转发，但 UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的。<br>TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。 </p>
<h3 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h3><p>运行在计算机中的进程是用进程标识符来标志的。<br>运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在因特网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。<br>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。<br>解决这个问题的方法就是在运输层使用协议端口号(protocol port number)，或通常简称为端口(port)。<br>虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成。</p>
<ul>
<li><p>软件端口与硬件端口</p>
<ul>
<li>在协议栈层间的抽象的协议端口是软件端口。</li>
<li>路由器或交换机上的端口是硬件端口。</li>
<li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。</li>
</ul>
</li>
<li><p>TCP 的端口 </p>
<ul>
<li>端口用一个 16 位二进制端口号进行标志。0~65535</li>
<li>端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。</li>
</ul>
</li>
<li><p>三类端口 </p>
<ul>
<li>熟知端口，数值一般为 0~1023。</li>
<li>登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。</li>
<li>客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li>
</ul>
</li>
</ul>
<h3 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h3><ul>
<li>由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。</li>
<li>有时我们会改换接收报文的进程，但并不需要通知所有发送方。</li>
<li>我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。</li>
</ul>
<h3 id="TCP-的连接"><a href="#TCP-的连接" class="headerlink" title="TCP 的连接"></a>TCP 的连接</h3><ul>
<li><p>TCP 把连接作为最基本的抽象。</p>
</li>
<li><p>每一条 TCP 连接有两个端点。</p>
</li>
<li><p>TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字(socket)或插口。</p>
</li>
<li><p>端口号拼接到(contatenated with) IP 地址即构成了套接字。   </p>
<ul>
<li><p>套接字 (socket)</p>
<ul>
<li>每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：TCP 连接 ::= {socket1, socket2} = {(IP1: port1), (IP2: port2)}</li>
</ul>
</li>
<li><p>socket的不同含义</p>
<ul>
<li>应用编程接口 API 称为 socket API, 简称为 socket。</li>
<li>socket API 中使用的一个函数名也叫作 socket。</li>
<li>调用 socket 函数的端点称为 socket。</li>
<li>调用 socket 函数时其返回值称为 socket 描述符，可简称为 socket。</li>
<li>在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-2-multiplexing-and-demultiplexing复用和解复用"><a href="#4-2-multiplexing-and-demultiplexing复用和解复用" class="headerlink" title="4.2 multiplexing and demultiplexing复用和解复用"></a>4.2 multiplexing and demultiplexing复用和解复用</h2><h3 id="复习：各层次的协议数据单元"><a href="#复习：各层次的协议数据单元" class="headerlink" title="复习：各层次的协议数据单元"></a>复习：各层次的协议数据单元</h3><h3 id="解复用作用：TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确的socket，从而交给正确的进程"><a href="#解复用作用：TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确的socket，从而交给正确的进程" class="headerlink" title="解复用作用：TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确的socket，从而交给正确的进程"></a>解复用作用：TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确的socket，从而交给正确的进程</h3><h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><ul>
<li><p>数据报格式</p>
</li>
<li><p>主机接收 IP 数据报</p>
<ul>
<li>每个数据报都有源 IP 地址、目的 IP 地址</li>
<li>每个数据报携带 1 个传输层报文段（segment）</li>
<li>每个segment都有源端口号和目标端口号（port number）</li>
</ul>
</li>
<li><p>主机联合使用IP地址和端口号将报文段发送给合适的套接字</p>
</li>
</ul>
<h3 id="Connectionless-demultiplexing无连接解复用"><a href="#Connectionless-demultiplexing无连接解复用" class="headerlink" title="Connectionless demultiplexing无连接解复用"></a>Connectionless demultiplexing无连接解复用</h3><ul>
<li><p>eg.左右两边的Client 应用 进程P3和P4向中间的Server 应用进程P1发送UDP 数据报。P4和P3发过来的UDP报文段的目标端口（destination port）都是6428 。<br>即便P4和P3的源ip、源port不一样，但是都发给了中间服务器端口号为6428的、相同的应用进程。</p>
<ul>
<li>中间的Server 的进程P1给左右主机的进程P3、P4是如何发UDP数据报的</li>
</ul>
</li>
</ul>
<h3 id="Connection-oriented-demultiplexing面向连接的多路复用"><a href="#Connection-oriented-demultiplexing面向连接的多路复用" class="headerlink" title="Connection-oriented demultiplexing面向连接的多路复用"></a>Connection-oriented demultiplexing面向连接的多路复用</h3><ul>
<li><p>TCP套接字socket由四个元组标识</p>
<ul>
<li>源IP地址</li>
<li>源端口号</li>
<li>目的IP地址</li>
<li>目的端口号</li>
</ul>
</li>
<li><p>解复用：接收主机用这四个值来将数据报定位到合适的套接字</p>
</li>
<li><p>服务器能够在一个TCP端口上同时支持多个TCP套接字：</p>
<ul>
<li>每个套接字由其四元组标识（有不同的源IP和源PORT）</li>
</ul>
</li>
<li><p>Web服务器对每个连接客户端有不同的套接字</p>
<ul>
<li>非持久对每个请求有不同的套接字</li>
</ul>
</li>
<li><p>一个栗子：</p>
<ul>
<li>四元组就可以唯一确定一个TCP socket会话关系</li>
</ul>
</li>
</ul>
<h2 id="4-3-connectionless-transport-UDP-无连接传输UDP"><a href="#4-3-connectionless-transport-UDP-无连接传输UDP" class="headerlink" title="4.3 connectionless transport: UDP 无连接传输UDP"></a>4.3 connectionless transport: UDP 无连接传输UDP</h2><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><ul>
<li><p>“尽力而为”的服务，报文段可能</p>
<ul>
<li>丢失</li>
<li>送到应用进程的报文段乱序delivered out of order to app</li>
</ul>
</li>
<li><p>无连接：</p>
<ul>
<li>UDP发送端和接收端之间没有握手</li>
<li>每个UDP报文段都被独立地处理</li>
</ul>
</li>
<li><p>UDP 被用于:</p>
<ul>
<li>流媒体(streaming multimedia apps)（丢失不敏感-loss tolerant，速率敏感-rate sensitive，应用可控制传输速率）</li>
<li>DNS</li>
<li>SNMP</li>
</ul>
</li>
<li><p>在UDP上可行可靠传输:</p>
<ul>
<li>在应用层增加可靠性</li>
<li>应用特定的差错恢复（error recovery）</li>
</ul>
</li>
<li><p>UDP为什么要有</p>
<ul>
<li><p>不建立连接（会增加延时）</p>
</li>
<li><p>简单：在发送端和接收端无连接状态</p>
</li>
<li><p>报文段的头部很小（开销小）</p>
</li>
<li><p>无拥塞控制和流量控制</p>
<ul>
<li>应用-&gt;传输的速率=主机-&gt;网络的速率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="面向报文的UDP"><a href="#面向报文的UDP" class="headerlink" title="面向报文的UDP"></a>面向报文的UDP</h3><p>发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。<br>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。<br>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。<br>应用程序必须选择合适大小的报文。</p>
<ul>
<li>UDP 是面向报文的 </li>
<li>UDP 的首部格式 </li>
<li>UDP 基于端口的分用</li>
</ul>
<h3 id="UDP校验和checksum"><a href="#UDP校验和checksum" class="headerlink" title="UDP校验和checksum"></a>UDP校验和checksum</h3><ul>
<li><p>目标：检测传输段中的“错误”（例如，翻转位flipped bits）</p>
</li>
<li><p>EDC=error-detection and-correction 差错检测和纠错比特</p>
</li>
<li><p>发送端：</p>
<ul>
<li>将段内容视为 16 位整数的序列</li>
<li>校验和：段内容的加法（补码和）</li>
<li>发送方将校验和值放入 UDP 校验和字段中</li>
</ul>
</li>
<li><p>接收端：</p>
<ul>
<li><p>计算已接收段的校验和</p>
</li>
<li><p>检查计算的校验和是否等于校验和字段值：</p>
</li>
<li><p>否 - 检测到错误</p>
<ul>
<li>发现错误UDP直接丢弃drop</li>
</ul>
</li>
<li><p>是 - 未检测到错误。但也许还是有错误，（错上加错，阴差阳错）</p>
</li>
</ul>
</li>
<li><p>在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。</p>
</li>
<li><p>一个栗子：</p>
<ul>
<li>注意：将最高有效位循环加到最后一位上（必须将进位回卷到结果上）</li>
</ul>
</li>
</ul>
<h2 id="4-4-principles-of-reliable-data-transfer可靠数据传输原理-rdt"><a href="#4-4-principles-of-reliable-data-transfer可靠数据传输原理-rdt" class="headerlink" title="4.4 principles of reliable data transfer可靠数据传输原理(rdt)"></a>4.4 principles of reliable data transfer可靠数据传输原理(rdt)</h2><h3 id="TCP最主要的特点："><a href="#TCP最主要的特点：" class="headerlink" title="TCP最主要的特点："></a>TCP最主要的特点：</h3><ul>
<li><p>TCP 是面向连接的运输层协议。</p>
</li>
<li><p>每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 </p>
</li>
<li><p>TCP 提供可靠交付的服务。</p>
</li>
<li><p>TCP 提供全双工通信。</p>
</li>
<li><p>面向字节流。  </p>
<ul>
<li>TCP面向流的概念</li>
</ul>
</li>
<li><p>注意：</p>
<p>TCP 连接是一条虚连接而不是一条真正的物理连接。<br>TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。<br>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。<br>TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。 </p>
</li>
<li><p>TCP的连接</p>
<p>TCP 把连接作为最基本的抽象。<br>每一条 TCP 连接有两个端点。<br>TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字(socket)或插口。<br>端口号拼接到(contatenated with) IP 地址即构成了套接字。</p>
</li>
</ul>
<h3 id="rdt在应用层、传输层和数据链路层都很重要"><a href="#rdt在应用层、传输层和数据链路层都很重要" class="headerlink" title="rdt在应用层、传输层和数据链路层都很重要"></a>rdt在应用层、传输层和数据链路层都很重要</h3><ul>
<li>信道的不可靠特点决定了可靠数据传输协议（rdt）的复杂性</li>
</ul>
<h3 id="传输层和应用层关系"><a href="#传输层和应用层关系" class="headerlink" title="传输层和应用层关系"></a>传输层和应用层关系</h3><h3 id="可靠数据传输-问题描述："><a href="#可靠数据传输-问题描述：" class="headerlink" title="可靠数据传输 问题描述："></a>可靠数据传输 问题描述：</h3><ul>
<li>渐增式（incrementally）地开发可靠数据传输协议（ rdt ）的发送方和接收方</li>
<li>只考虑单向数据传输，但控制信息是双向流动的</li>
<li>双向的数据传输问题实际上是2个单向数据传输问题的综合</li>
<li>使用有限状态机 (finite state machines, FSM) 来描述发送方和接收方</li>
</ul>
<h3 id="Rdt1-0：-在可靠信道上的可靠数据传输"><a href="#Rdt1-0：-在可靠信道上的可靠数据传输" class="headerlink" title="Rdt1.0： 在可靠信道上的可靠数据传输"></a>Rdt1.0： 在可靠信道上的可靠数据传输</h3><ul>
<li><p>前提：下层信道是完全可靠的</p>
<ul>
<li>没有比特出错bit errors</li>
<li>没有分组丢失loss of packets</li>
</ul>
</li>
<li><p>发送方和接收方的FSM </p>
<ul>
<li>发送方将数据发送到下层信道 </li>
<li>接收方从下层信道接收数据</li>
</ul>
</li>
</ul>
<h3 id="Rdt2-0：具有比特差错的信道"><a href="#Rdt2-0：具有比特差错的信道" class="headerlink" title="Rdt2.0：具有比特差错的信道"></a>Rdt2.0：具有比特差错的信道</h3><ul>
<li><p>下层信道可能会出错：将分组中的比特翻转</p>
<ul>
<li>用校验和来检测比特差错</li>
</ul>
</li>
<li><p>问题：怎样从差错中恢复：</p>
<ul>
<li>acknowledgements确认(ACK)：接收方显式地告诉发送方分组已被正确接收</li>
<li>negative acknowledgements否定确认( NAK): 接收方显式地告诉发送方分组发生了差错</li>
<li>发送方收到NAK后，发送方重传分组</li>
</ul>
</li>
<li><p>rdt2.0中的新机制(mechanisms)（相较于rdt1.0）：采用差错控制编码进行差错检测</p>
<ul>
<li>发送方差错控制编码、缓存</li>
<li>接收方使用编码检错</li>
<li>接收方的反馈：控制报文（ACK，NAK）：接收方→发送方 </li>
<li>发送方收到反馈相应的动作</li>
</ul>
</li>
<li><p>FSM描述</p>
<ul>
<li>没有差错时的操作</li>
<li>有差错时error scenario</li>
</ul>
</li>
<li><p>rdt2.0的致命缺陷</p>
<ul>
<li><p>如果ACK/NAK出错(corrupted)？</p>
<ul>
<li><p>发送方不知道接收方发生了什么事情！</p>
</li>
<li><p>发送方如何做？</p>
<ul>
<li>重传？可能重复</li>
<li>不重传？可能死锁(或出错)</li>
</ul>
</li>
<li><p>需要引入新的机制</p>
<ul>
<li>序号sequence number</li>
</ul>
</li>
</ul>
</li>
<li><p>处理重复</p>
<ul>
<li>发送方在每个分组中加入序号(sequence number )</li>
<li>如果ACK/NAK出错，发送方重传当前分组</li>
<li>接收方丢弃（不发给上层）重复分组</li>
</ul>
</li>
<li><p>停等协议stop and wait</p>
<ul>
<li><p>发送方发送一个分组，然后等待接收方的应答，如果超过略大于“从发送方到接收方的平均往返时间”，就定为超时，然后重传。</p>
</li>
<li><p>停止等待协议</p>
<p>在发送完一个分组后，必须暂时保留已发送的分组的副本。<br>分组和确认分组都必须进行编号。<br>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 </p>
<ul>
<li>确认丢失和确认迟到</li>
<li>信道利用率很低，但是优点是简单</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Rdt2-1：处理出错-garbled-的ACK-x2F-NAK"><a href="#Rdt2-1：处理出错-garbled-的ACK-x2F-NAK" class="headerlink" title="Rdt2.1：处理出错(garbled)的ACK/NAK"></a>Rdt2.1：处理出错(garbled)的ACK/NAK</h3><ul>
<li><p>发送方处理出错的ACK/NAK</p>
</li>
<li><p>接收方处理出错的ACK/NAK</p>
</li>
<li><p>讨论</p>
<ul>
<li><p>发送方</p>
<ul>
<li><p>在分组中加入序列号（seq #）</p>
</li>
<li><p>两个序列号（0，1）就足够了</p>
<ul>
<li>一次只发送一个未经确认的分组</li>
</ul>
</li>
<li><p>必须检测ACK/NAK是否出错（需要EDC ）</p>
</li>
<li><p>FSM状态数变成了两倍</p>
<ul>
<li>必须记住当前分组的序列号为0还是1</li>
</ul>
</li>
</ul>
</li>
<li><p>接收方</p>
<ul>
<li><p>必须检测接收到的分组是否是重复的</p>
<ul>
<li>状态会指示希望接收到的分组的序号为0还是1</li>
</ul>
</li>
<li><p>注意：接收方并不知道发送方是否正确收到了其ACK/NAK</p>
<ul>
<li>没有安排确认的确认</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>rdt2.1的运行</p>
<p>发送方不对收到的ack/nak给确认<br>接收方发送ack，如果后面接收方收到的是：<br>老分组p0？则ack 错误<br>下一个分组？P1，ack正确</p>
</li>
</ul>
<h3 id="Rdt2-2-a-NAK-free-protocol无NAK的协议"><a href="#Rdt2-2-a-NAK-free-protocol无NAK的协议" class="headerlink" title="Rdt2.2: a NAK-free protocol无NAK的协议"></a>Rdt2.2: a NAK-free protocol无NAK的协议</h3><ul>
<li><p>功能同rdt2.1，但只使用ACK(ack 要编号）</p>
</li>
<li><p>接收方对最后正确接收的分组发ACK，以替代NAK</p>
<ul>
<li>接收方必须显式地(explicitly)包含被正确接收分组的序号</li>
</ul>
</li>
<li><p>当收到重复的ACK（如：再次收到ack0）时，发送方与收到NAK采取相同的动作：重传当前分组</p>
</li>
<li><p>为后面的一次发送多个数据单位做一个准备</p>
<ul>
<li>一次能够发送多个</li>
<li>每一个的应答都有：ACK，NACK；麻烦</li>
<li>使用对前一个数据单位的ACK，代替本数据单位的nak</li>
<li>确认信息减少一半，协议处理简单</li>
</ul>
</li>
<li><p>发送方和接收方片断</p>
</li>
<li><p>rdt2.2的运行</p>
</li>
</ul>
<h3 id="Rdt3-0-channels-with-errors-and-loss具有比特差错和分组丢失的信道"><a href="#Rdt3-0-channels-with-errors-and-loss具有比特差错和分组丢失的信道" class="headerlink" title="Rdt3.0: channels with errors and loss具有比特差错和分组丢失的信道"></a>Rdt3.0: channels with errors and loss具有比特差错和分组丢失的信道</h3><ul>
<li><p>新的假设</p>
<ul>
<li>下层信道可能会丢失分组（数据或ACK）</li>
</ul>
</li>
<li><p>解决的问题：</p>
<ul>
<li><p>会死锁</p>
</li>
<li><p>机制还不够处理这种状况</p>
<p>检验和（checksum）<br>序列号 （seq. #）<br>ACK<br>重传 （会有所帮助，但是还不够）</p>
</li>
</ul>
</li>
<li><p>方法：</p>
<ul>
<li><p>发送方等待ACK一段合理的时间</p>
<p>此处合理的时间：链路层的timeout时间是确定的。传输层timeout时间是适应式的。</p>
<ul>
<li><p>发送端超时重传：如果到时没有收到ACK-》重传</p>
</li>
<li><p>新的问题：如果分组（ACK）只是被延迟了？</p>
<ul>
<li>重传会导致数据重复，但利用序列号已经可以处理这个问题</li>
<li>接收方必须指明被正确接受的序号</li>
</ul>
</li>
</ul>
</li>
<li><p>解决新的问题：需要一个倒计数定时器(countdown timer)</p>
<ul>
<li>在给定的时间量过期后，可中断发送方</li>
</ul>
</li>
</ul>
</li>
<li><p>rdt3.0发送方</p>
<ul>
<li>每次发送一个分组（包括第一次分组和重传分组）时，便启动一个定时器。</li>
<li>响应定时器中断（采取适当的动作）</li>
<li>中止定时器</li>
</ul>
</li>
<li><p>rdt3.0的运行</p>
<ul>
<li>rdt3.0可以工作，但链路容量比较大的情况下，性能很差(performance stinks性能不好)</li>
</ul>
</li>
<li><p>rdt3.0的性能</p>
<ul>
<li>瓶颈在于：网络协议限制了物理资源的利用</li>
</ul>
</li>
</ul>
<p>$$<br>U_{sender}:利用率 ({\color{red} utilization})-忙于发送的时间比例(fraction of time sender busy sending)<br>$$</p>
<pre><code>- 
</code></pre>
<p>$$<br>T_{transmit}=\cfrac{L(分组长度packet length，比特)}{R(传输速度transmission rate，bps)}<br>$$</p>
<pre><code>- U为利用率
</code></pre>
<p>$$<br>U_{sender} = \cfrac{L/R}{RTT+L/R}<br>$$</p>
<ul>
<li><p>rdt3.0: stop-and-wait operation停-等操作</p>
</li>
<li><p>流水线协议Pipelined protocols：提高链路利用率</p>
<ul>
<li><p>允许发送方在未得到对方确认的情况下一次发送多个分组</p>
</li>
<li><p>必须增加序号的范围:用多个bit表示分组的序号</p>
</li>
<li><p>在发送方/接收方要有缓冲区</p>
<ul>
<li>发送方缓冲：未得到确认，可能需要重传；</li>
<li>接收方缓存：上层用户取用数据的速率≠接收到的数据速率；接收到的数据可能乱序，排序交付（可靠）</li>
</ul>
</li>
<li><p>两种通用的流水线协议：</p>
<ul>
<li>回退N步(go-Back-N，GBN)</li>
<li>选择重传(selective repeat，SR)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="流水线协议Pipelined-protocols："><a href="#流水线协议Pipelined-protocols：" class="headerlink" title="流水线协议Pipelined protocols："></a>流水线协议Pipelined protocols：</h3><p>发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。<br>由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率</p>
<ul>
<li><p>Go-back-N和Selective Repeat对比（回退N步和选择重传对比）</p>
<ul>
<li><p>发送端发送数量（此点相同）<br>一次都可以发送多个未经确认的分组</p>
<ul>
<li>发送端最多在流水线中有N个<br>未确认的分组（unacked packets）</li>
<li>发送端最多在流水线中<br>有N个未确认的分组</li>
</ul>
</li>
<li><p>ack对比</p>
<ul>
<li>接收方对每个到来的分组单独确认individual ack（非累计确认）</li>
<li>接收端只是发送累计型确认cumulative ack<br>（接收端如果发现gap，不确认新到来的分组）</li>
</ul>
</li>
<li><p>定时器对比</p>
<ul>
<li>发送方为每个未确认的分组保持一个定时器（当超时定时器到时，只是重发到时的未确认分组）</li>
<li>发送端拥有对最早发送的的未确认分组的定时器（只需设置一个定时器，当定时器到时时，重传所有未确认分组）</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>简单，所需资源少<br>（接收方一个缓存单元）</li>
<li>出错时，重传一个<br>代价小</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>一旦出错，回退N步代价大 </li>
<li>复杂，所需要资源多<br>（接收方多个缓存单元）</li>
</ul>
</li>
<li><p>适用范围</p>
<ul>
<li>出错率低：比较适合GBN，出错非常罕见，没有必要用复杂的SR，为罕见的事件做日常的准备和复杂处理</li>
<li>链路容量大（延迟大、带宽大）：比较适合SR而不是GBN，一点出错代价太大</li>
</ul>
</li>
<li><p>窗口的最大尺寸</p>
<ul>
<li>SR:2^(n-1)</li>
<li>GBN: 2^n-1</li>
</ul>
</li>
</ul>
</li>
<li><p>(Go-back-N,GBN)回退N步，也称为滑动窗口协议</p>
<ul>
<li><p>发送端</p>
<ul>
<li>分组标头中的k位序号</li>
<li>“window”最多 N （窗口长度）个，允许连续未确定的分组</li>
</ul>
</li>
<li><p>发送方扩展的FSM</p>
</li>
<li><p>接收方扩展的FSM</p>
<ul>
<li><p>只发送ACK：对顺序接收的最高序号的分组</p>
<ul>
<li>可能会产生重复的ACK </li>
<li>只需记住（expectedseqnum）；接收窗口=1(只一个变量就可表示接收窗口)</li>
</ul>
</li>
<li><p>对乱序的分组：</p>
<ul>
<li>丢弃（不缓存） →在接收方不被缓存❗</li>
<li>对顺序接收的最高序号的分组进行确认-累计确认</li>
</ul>
</li>
</ul>
</li>
<li><p>运行中的GBN</p>
</li>
</ul>
</li>
<li><p>(SR,Selective Repeat)选择重传</p>
<ul>
<li><p>接收方对每个正确接收的分组，分别发送<br>ACKn（非累积确认）</p>
<ul>
<li>接收窗口&gt;1（可以缓存乱序的分组，根据需要缓存分组）</li>
<li>最终将分组按顺序交付给上层</li>
</ul>
</li>
<li><p>发送方只对那些没有收到ACK的分组进行重发-选择性重发</p>
<ul>
<li>发送方为每个未确认的分组设定一个定时器</li>
</ul>
</li>
<li><p>发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数</p>
</li>
<li><p>发送方</p>
<ul>
<li><p>从上层接收数据</p>
<ul>
<li>如果下一个可用于该分组的序号可在发送窗口中，则发送</li>
</ul>
</li>
<li><p>timeout(n):</p>
<ul>
<li>重新发送分组n，重新设定定时器</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>$$<br>ACK_{in [sendbase,sendbase+N]}:<br>$$</p>
<pre><code>        - 将分组n标记为已接收
        - 如n为最小未确认的分组序号，将base移到下一个未确认序号

- 接收方

    - 
</code></pre>
<p>$$<br>分组n_{[rcvbase, rcvbase+N-1]}<br>$$</p>
<pre><code>        - 发送ACK(n)
        - 乱序：缓存
        - 有序：该分组及以前缓存的序号连续的分组交付给上层，然后将窗口移到下一个仍未被接收的分组

    - 
</code></pre>
<p>$$<br>分组n_{[rcvbase-N, rcvbase-1]}<br>$$</p>
<pre><code>        - ACK(n)

    - 其它：

        - 忽略该分组

- 接收方，发送方和接受windows示意图
- 选择重传SR的运行（in action）

    - 两难情况（dilemma）

        - 接收器在两种情况下没有区别！
        - （b） 中接受为新数据的重复数据
        - 问：seq # 大小和窗口大小之间有什么关系，以避免 （b） 中出现问题？
</code></pre>
<h3 id="可靠通信的实现"><a href="#可靠通信的实现" class="headerlink" title="可靠通信的实现"></a>可靠通信的实现</h3><p>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。<br>这种可靠传输协议常称为自动重传请求ARQ (Automatic Repeat reQuest)。<br>ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 。</p>
<ul>
<li><p>连续 ARQ 协议 </p>
<ul>
<li>Go-back-N协议表明当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。</li>
</ul>
</li>
<li><p>累计确认</p>
<p>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。<br>累积确认有的优点是：容易实现，即使确认丢失也不必重传。缺点是：不能向发送方反映出接收方已经正确收到的所有分组的信息。</p>
</li>
<li><p>TCP可靠通信的具体实现</p>
<p>TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。<br>TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。<br>TCP 两端的四个窗口经常处于动态变化之中。<br>TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。</p>
</li>
</ul>
<h2 id="4-5-connection-oriented-transport-TCP"><a href="#4-5-connection-oriented-transport-TCP" class="headerlink" title="4.5 connection-oriented transport: TCP"></a>4.5 connection-oriented transport: TCP</h2><p>点对点：  一个发送方，一个接收方<br>可靠的、按顺序的字节流：  没有报文边界（no “message boundaries”）<br>管道化（流水线pipelined）：TCP拥塞控制和流量控制设置，窗口大小<br>发送和接收缓存send &amp; receive buffers<br>全双工数据full duplex data：<br>在同一连接中数据流双向流动<br>MSS： maximum segment size最大报文段大小<br>面向连接：在数据交换之前，通过握手（交换控制报文） 初始化发送方、接收方的状态变量<br>有流量控制：发送方不会淹没（overwhelm）接收方 </p>
<h3 id="4-5-1报文段结构segment-structure"><a href="#4-5-1报文段结构segment-structure" class="headerlink" title="4.5.1报文段结构segment structure"></a>4.5.1报文段结构segment structure</h3><p>- </p>
<p>  源端口和目的端口字段——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。<br>  序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。<br>  确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。<br>  数据偏移（即首部长度）——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。<br>  保留字段——占 6 位，保留为今后使用，但目前应置为 0。<br>  紧急 URG —— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。<br>   确认 ACK —— 只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。<br>  推送 PSH (PuSH) —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。<br>  复位 RST (ReSeT) —— 当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。<br>  同步 SYN —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。<br>  终止 FIN (FINis) —— 用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。<br>  窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。<br>  检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。<br>  紧急指针字段 —— 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。<br>  选项字段 —— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”<br>  MSS (Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。<br>  窗口扩大选项 ——占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于TCP 首部中的窗口位数增大到(16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小。<br>  时间戳选项——占10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）。<br>  选择确认选项——在后面介绍。<br>  填充字段 —— 这是为了使整个首部长度是 4 字节的整数倍。 </p>
<ul>
<li><p>TCP seq. numbers, ACKs序号、确认号</p>
<ul>
<li><p>序号sequence numbers：</p>
<ul>
<li>报文段首字节的在字节流的编号</li>
</ul>
</li>
<li><p>确认号acknowledgements:</p>
<ul>
<li>期望从另一方收到的下一个字节的序号（seq # ）</li>
<li>累积（cumulative）确认</li>
</ul>
</li>
<li><p>TCP不考虑接收方对乱序的报文段的排序问题</p>
</li>
<li></li>
</ul>
</li>
<li><p>TCP round trip time(往返延时, RTT), timeout(超时)</p>
<ul>
<li><p>怎样设置TCP超时的值？</p>
<ul>
<li>比RTT要长， 但RTT是变化的</li>
<li>太短：太早(premature)超时→不必要的重传</li>
<li>太长：对报文段丢失反应太慢</li>
</ul>
</li>
<li><p>怎样估计(estimate)RTT？</p>
<ul>
<li>SampleRTT：测量从报文段发出到收到ack确认的时间（如果有重传，忽略此次测量）</li>
<li>SampleRTT会变化，因此估计的RTT应该比较平滑 → 对几个最近的测量值求平均，而不是仅用当前的SampleRTT</li>
</ul>
</li>
<li><p>EstimatedRTT：加权平均往返时间<br>指数加权(exponential weighted)移动平均<br>过去样本的影响呈指数衰减<br>推荐值：α = 0.125（0&lt;α&lt;1）</p>
</li>
</ul>
</li>
</ul>
<p>$$<br>EstimatedRTT = (1- \alpha)<em>EstimatedRTT + \alpha</em>SampleRTT<br>$$</p>
<pre><code>    - TCP 保留了 RTT 的一个加权平均往返时间 RTTS（这又称为平滑的往返时间）。
</code></pre>
<p>第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS：</p>
<p>$$<br>新的 RTT_S = (1 - \alpha) * (旧的 RTT_S)                        + (\alpha * 新的 RTT 样本)<br>$$</p>
<pre><code>        - 若 α  很接近于零，表示 RTT 值更新较慢。若选择 α  接近于 1，则表示 RTT 值更新较快。
        - RFC 2988 推荐的 α  值为 1/8，即 0.125。 

- 设置超时时间

    - timeout interval超时间隔：EstimtedRTT + 安全边界(safety margin)时间：EstimatedRTT变化大 (方差大)→较大的安全边界时间

        - 往返时延的方差很大：由于 TCP 的下层是一个互联网环境，IP 数据报所选择的路由变化很大。因而运输层的往返时间的方差也很大。

    - SampleRTT会偏离EstimatedRTT多远：(推荐值：β = 0.25)
</code></pre>
<p>$$<br>DevRTT = (1-\beta)<em>DevRTT + \beta</em>|SampleRTT-EstimatedRTT|<br>$$</p>
<pre><code>      超时重传时间 RTO (RetransmissionTime-Out) 
      RTO 应略大于上面得出的加权平均往返时间 RTTS。
      RFC 2988 建议使用下式计算 RTO：
       RTO = RTTS + 4 * RTTD                  
      RTTD 是 RTT 的偏差的加权平均值。
      RFC 2988 建议这样计算 RTTD。第一次测量时，RTTD 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的RTTD：
      新的RTTD = (1 - β) * (旧的RTTD)  + β*RTTS|新的RTT样本| 
      β是个小于 1 的系数，其推荐值是 1/4，即 0.25。
      
    - 
    - 超时重传时间的选择：TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。

- 往返时间的测量相当复杂 

  TCP 报文段 1 没有收到确认。重传（即报文段 2）后，收到了确认报文段 ACK。 
  如何判定此确认报文段是对原来的报文段 1 的确认，还是对重传的报文段 2 的确认？ 
  
    - Karn 算法

        - 在计算平均往返时间 RTT 时，只要报文段重传了，就不采用其往返时间样本。
        - 这样得出的加权平均平均往返时间 RTTS 和超时重传时间 RTO 就较准确。 

    - 修正的 Karn 算法 

      报文段每重传一次，就把 RTO 增大一些： 
      新的 RTO = γ *  (旧的 RTO) 
      系数 γ的典型值是 2 。 
      当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值。 
      实践证明，这种策略较为合理。 
</code></pre>
<p>​		  </p>
<pre><code>- 选择确认 SACK(Selective ACK) 

  接收方收到了和前面的字节流不连续的两个字节块。 
  如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。 
</code></pre>
<p>​	  </p>
<pre><code>    - RCF2018的规定

      如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。 
      如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。 
      由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明 4 个字节块的边界信息。 
</code></pre>
<p>​		  </p>
<pre><code>    - 
</code></pre>
<ul>
<li><p>TCP可靠传输的实现：以字节为单位的滑动窗口</p>
<p>- </p>
<p>  - </p>
<pre><code>- 
</code></pre>
<ul>
<li><p>发送缓存</p>
</li>
<li><p>接收缓存</p>
</li>
<li><p>注意：</p>
<ul>
<li>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。</li>
<li>TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</li>
<li>TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-5-2-TCP：reliable-data-transfer可靠数据传输"><a href="#4-5-2-TCP：reliable-data-transfer可靠数据传输" class="headerlink" title="4.5.2 TCP：reliable data transfer可靠数据传输"></a>4.5.2 TCP：reliable data transfer可靠数据传输</h3><ul>
<li><p>概述</p>
<ul>
<li><p>TCP在IP不可靠服务的基础上建立了rdt </p>
<ul>
<li>管道化的报文段(GBN or SR)</li>
<li>累积确认（像GBN）</li>
<li>单个重传定时器（像GBN）</li>
</ul>
</li>
<li><p>通过以下事件触发重传</p>
<ul>
<li>超时（只重发那个最早的未确认段：SR）</li>
<li>重复的确认</li>
</ul>
</li>
<li><p>首先考虑简化的TCP发送方：</p>
<ul>
<li>忽略重复的确认</li>
<li>忽略流量控制和拥塞控制</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP sender events发送方事件：</p>
<ul>
<li><p>从应用层接收数据：</p>
<ul>
<li><p>用nextseq创建报文段</p>
</li>
<li><p>序号nextseq为报文段首字节的字节流编号</p>
</li>
<li><p>如果还没有运行，启动定时器</p>
<ul>
<li>定时器与最早未确认的报文段关联</li>
<li>过期间隔(expiration interval)：TimeOutInterval</li>
</ul>
</li>
</ul>
</li>
<li><p>超时：</p>
<ul>
<li>重传导致超时的报文段</li>
<li>重新启动定时器</li>
</ul>
</li>
<li><p>收到确认：</p>
<ul>
<li><p>如果是对尚未确认的报文段确认</p>
<ul>
<li>更新已被确认的报文序号</li>
<li>如果当前还有未被确认的报文段，重新启动定时器</li>
</ul>
</li>
</ul>
</li>
<li><p>简化的状态图</p>
<ul>
<li>TCP重传场景</li>
</ul>
</li>
<li></li>
</ul>
</li>
<li><p>TCP fast retransmit快速重传</p>
<ul>
<li><p>超时周期往往太长：在重传丢失报文段之前的<br>延时太长</p>
</li>
<li><p>通过重复的ACK来检测报文段丢失</p>
<ul>
<li><p>发送方通常连续发送大量报文段</p>
</li>
<li><p>如果报文段丢失，通常会引起多个重复的ACK</p>
</li>
<li><p>原因：如果发送方收到同一数据的3个冗余ACK，重传最小序号的段： </p>
<ul>
<li>快速重传：在定时器过时之前重发报文段<br>它假设跟在被确认的数据后面的数据丢失了<br>第一个ACK是正常的；<br>收到第二个该段的ACK，表示接收方收到一个该段后的乱序段；<br>收到第3，4个该段的ack，表示接收方收到该段之后的2个，3个乱序段，可能性非常大，段丢失了，无需再等到时延后再重传</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-5-3-TCP-flow-control流量控制"><a href="#4-5-3-TCP-flow-control流量控制" class="headerlink" title="4.5.3 TCP flow control流量控制"></a>4.5.3 TCP flow control流量控制</h3><ul>
<li><p>接收方控制发送方，不让发送方发的太多太快以至于让接收方的缓冲区溢出</p>
<ul>
<li>缓冲区TCP往里面写，app从当中读取</li>
</ul>
</li>
<li><p>实现原理：接收方在其向发送方的TCP段头部的rwnd字段“通告”其空闲buffer大小<br>发送端将未确认的数据限制为RcvWindow<br>Rcvr（接收端）在大于RcvWindow的段找可用空间？？？</p>
<ul>
<li>虽然达到流量控制，但是应用进程从缓冲区读取时可能会很慢</li>
<li>速度匹配服务：将发送速率与接收应用的消耗速率相匹配</li>
<li>假设TCP接收端丢弃无序报文段时<br>缓存中可用的空间=RcvWindow<br>= RcvBuffer-[LastByteRcvd - LastByteRead]</li>
</ul>
</li>
<li><p>利用滑动窗口实现流量控制</p>
<p>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。<br>流量控制(flow control)就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。<br>利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 </p>
<ul>
<li>流量控制举例</li>
</ul>
</li>
<li><p>持续计时器(persistence timer)</p>
<p>TCP 为每一个连接设有一个持续计时器。<br>只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。<br>若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。<br>若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。<br>若窗口不是零，则死锁的僵局就可以打破了。 </p>
</li>
<li><p>必须考虑传输效率</p>
<p>可以用不同的机制来控制 TCP 报文段的发送时机:<br>第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。<br>第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送(push)操作。<br>第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</p>
</li>
</ul>
<h3 id="4-5-4-connection-management连接管理"><a href="#4-5-4-connection-management连接管理" class="headerlink" title="4.5.4 connection management连接管理"></a>4.5.4 connection management连接管理</h3><ul>
<li><p>Recall：TCP发送方、接收方在交换数据段前建立“连接”</p>
<ul>
<li><p>初始化TCP变量</p>
<ul>
<li>序号seq.#s</li>
<li>缓冲区、流量控制信息（eg.Rcvwindow）</li>
</ul>
</li>
<li><p>客户端：连接启动器（connection initiator）</p>
<ul>
<li>Socket clientSocket = new Socket(“hostname”,”port number”);</li>
</ul>
</li>
<li><p>服务器：由客户联系</p>
<ul>
<li>Socket connectionSocket = welcomeSocket.accept();</li>
</ul>
</li>
</ul>
</li>
<li><p>3次握手</p>
<ul>
<li><p>步骤 1：客户端主机将 TCP SYN 段发送到服务器</p>
<ul>
<li>指定初始序号seq#</li>
<li>无数据</li>
</ul>
</li>
<li><p>步骤2：服务器主机接收SYN，使用SYNACK段回复</p>
<ul>
<li>服务器分配缓冲区</li>
<li>指定服务器初始 seq.#</li>
</ul>
</li>
<li><p>步骤3：客户端接收SYNACK，使用ACK段回复，其中可能包含数据</p>
</li>
</ul>
</li>
<li><p>在正式交换数据之前，发送方和接收方握手建立通信关系:</p>
<ul>
<li>同意建立连接（每一方都知道对方愿意建立连接）</li>
<li>同意连接参数</li>
</ul>
</li>
<li><p>Agreeing to establish a connection同意建立连接</p>
<ul>
<li><p>两次握手不总是可以确保建立连接</p>
<ul>
<li>变化的延迟（连接请求的段没有丢，但可能超时）</li>
<li>由于丢失造成的重传 (e.g.req_conn(x))</li>
<li>报文乱序</li>
<li>相互看不到对方</li>
<li>一个栗子</li>
</ul>
</li>
<li><p>3次握手</p>
<ul>
<li>解决的问题：半连接和接收老数据问题</li>
<li>3次握手：FSM</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP: 关闭连接closing a connection</p>
<ul>
<li><p>客户端，服务器分别关闭它自己这一侧的连接</p>
<ul>
<li>发送FIN bit = 1的TCP段</li>
</ul>
</li>
<li><p>一旦接收到FIN，用ACK回应</p>
<ul>
<li>接到FIN段，ACK可以和它自己发出的FIN段一起发送</li>
</ul>
</li>
<li><p>可以处理同时(simultaneous)的FIN交换</p>
</li>
</ul>
</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><ol>
<li>运输连接的三个阶段</li>
</ol>
<p>运输连接就有三个阶段，即：连接建立、数据传送和连接释放。运输连接的管理就是使运输连接的建立和释放都能正常地进行。<br>连接建立过程中要解决以下三个问题：<br>要使每一方能够确知对方的存在。<br>要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）。<br>能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配。 </p>
</li>
<li><p>客户服务器方式</p>
<p>TCP 连接的建立都是采用客户服务器方式。<br>主动发起连接建立的应用进程叫做客户(client)。<br>被动等待连接建立的应用进程叫做服务器(server)。 </p>
</li>
<li><p>过程：握手、连接释放PPT p164-177</p>
<ul>
<li><p>A 必须等待 2MSL 的时间</p>
<p>第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。<br>第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-6-principles-of-congestion-control拥塞控制原理"><a href="#4-6-principles-of-congestion-control拥塞控制原理" class="headerlink" title="4.6 principles of congestion control拥塞控制原理"></a>4.6 principles of congestion control拥塞控制原理</h2><h3 id="拥塞"><a href="#拥塞" class="headerlink" title="拥塞:"></a>拥塞:</h3><ul>
<li><p>非正式的定义: “太多的数据需要网络传输，超过了网络的处理能力”</p>
</li>
<li><p>与流量控制不同</p>
</li>
<li><p>拥塞的表现manifestations:</p>
<ul>
<li>分组丢失 (路由器缓冲区溢出)</li>
<li>分组经历比较长的延迟(在路由器的队列中排队)</li>
</ul>
</li>
<li><p>拥塞的原因/代价: 场景(scenario)1</p>
</li>
<li><p>拥塞的原因/代价: 场景2</p>
<p>- </p>
<p>  - </p>
<p>- </p>
<ul>
<li>retrans（重传）</li>
</ul>
</li>
<li><p>拥塞的原因/代价: 场景3</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><ul>
<li><p>端到端拥塞控制:</p>
<ul>
<li>没有来自网络的显式反馈</li>
<li>端系统根据延迟和丢失事件推断是否有拥塞</li>
<li>TCP采用的方法</li>
</ul>
</li>
<li><p>网络辅助的拥塞控制:</p>
<ul>
<li>路由器提供给端系统以反馈信息</li>
<li>单个bit置位，显示有拥塞 (SNA, DECbit,TCP/IP ECN, ATM)</li>
<li>显式提供发送端可以采用的速率</li>
</ul>
</li>
</ul>
<h2 id="4-7-TCP-congestion-control（TCP拥塞控制）"><a href="#4-7-TCP-congestion-control（TCP拥塞控制）" class="headerlink" title="4.7 TCP congestion control（TCP拥塞控制）"></a>4.7 TCP congestion control（TCP拥塞控制）</h2><h3 id="TCP-拥塞控制：AIMD（additive-increase-multiplication-decrease）加性增，乘性减"><a href="#TCP-拥塞控制：AIMD（additive-increase-multiplication-decrease）加性增，乘性减" class="headerlink" title="TCP 拥塞控制：AIMD（additive increase multiplication decrease）加性增，乘性减"></a>TCP 拥塞控制：AIMD（additive increase multiplication decrease）加性增，乘性减</h3><ul>
<li><p>方法：发送方提高传输速率（窗口大小），探测可用带宽，直到发生丢失</p>
<p>如何控制发送端发送的速率<br>维持一个拥塞窗口的值：CongWin（cwnd）<br>发送端限制已发送但是未确认的数据量（的上限）: LastByteSent-LastByteAcked ≤ CongWin<br>从而粗略地控制发送方的往网络中注入的速率</p>
<ul>
<li>加法增加：<br>当CongWin&gt;阈值时，一个RTT如没有发生丢失事件 ,将CongWin加1MSS: 探测</li>
<li>乘法减少:<br>丢失事件后将CongWin降为1，将CongWin/2作为阈值，进入慢启动阶段（倍增直到CongWin/2）</li>
<li>cwnd是动态的，有感知网络拥塞的功能</li>
<li>TCP发送速率：<br>大致就是cwnd字节，等待RTT的ACKS，然后发送更多字节</li>
</ul>
</li>
</ul>
<h3 id="TCP慢启动"><a href="#TCP慢启动" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h3><ul>
<li><p>当连接开始时，指数性增加（每个RTT）发送速率直到发生丢失事件</p>
<ul>
<li>连接刚建立, CongWin = 1MSS</li>
<li>每一个RTT， CongWin加倍</li>
<li>每收到一个ACK时，CongWin加1（why）</li>
<li>慢启动阶段：只要不超时或3个重复ack，一个RTT， CongWin加倍</li>
</ul>
</li>
<li><p>总结: 初始速率很慢，但是加速却是指数性的</p>
<ul>
<li>指数增加，SS时间很短，长期来看可以忽略</li>
</ul>
</li>
</ul>
<h3 id="TCP：detecting-reacting-to-loss"><a href="#TCP：detecting-reacting-to-loss" class="headerlink" title="TCP：detecting, reacting to loss"></a>TCP：detecting, reacting to loss</h3><p>检测、对丢失的反应</p>
<ul>
<li><p>loss indicated by timeout<br>超时指示的损失：</p>
<ul>
<li>1.cwnd 设置为 1 MSS;</li>
<li>2.然后窗口呈指数级增长（exponentially）（如在慢启动时）到阈值（threshold），然后线性（linearly）增长</li>
</ul>
</li>
<li><p>由 3 个重复的 ACK 指示的丢失：TCP RENO</p>
<ul>
<li>dup ACK 表示网络能够提供某些网段</li>
<li>cwnd被切成两半的窗口，然后线性增长</li>
</ul>
</li>
<li><p>TCP Tahoe 始终将 cwnd 设置为 1（超时timeout或 3 个重复的 ack）</p>
</li>
</ul>
<h3 id="TCP：从慢启动切换到-CA（switching-from-slow-start-to-CA）"><a href="#TCP：从慢启动切换到-CA（switching-from-slow-start-to-CA）" class="headerlink" title="TCP：从慢启动切换到 CA（switching from slow start to CA）"></a>TCP：从慢启动切换到 CA（switching from slow start to CA）</h3><ul>
<li>问：指数增长何时应切换到线性？<br>答：当cwnd在超时之前达到其值的1/2时。</li>
<li>实现：通过可变的ssthresh<br>在loss事件时，ssthresh 设置为亏损事件发生前 cwnd 的 1/2</li>
</ul>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><h3 id="TCP吞吐量throughput"><a href="#TCP吞吐量throughput" class="headerlink" title="TCP吞吐量throughput"></a>TCP吞吐量throughput</h3><ul>
<li>TCP的平均吞吐量是多少，使用窗口window尺寸W和RTT来描述?<br>忽略慢启动阶段，假设发送端总有数据传输</li>
<li></li>
</ul>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="TCP公平性fairness"><a href="#TCP公平性fairness" class="headerlink" title="TCP公平性fairness"></a>TCP公平性fairness</h3><ul>
<li><p>公平性目标goal：</p>
<ul>
<li>如果 K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为 R/K</li>
</ul>
</li>
<li><p>TCP公平的原因</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="Explicit-Congestion-Notification-ECN"><a href="#Explicit-Congestion-Notification-ECN" class="headerlink" title="Explicit Congestion Notification (ECN)"></a>Explicit Congestion Notification (ECN)</h3><ul>
<li><p>网络辅助拥塞控制:</p>
<p>TOS字段中2个bit被网络路由器标记，用于指示是否发 生拥塞<br>拥塞指示被传送到接收主机<br>在接收方-到发送方的ACK中，接收方(在IP数据报中看到了拥塞指示）设置ECE bit，指示发送方发生了拥塞</p>
</li>
</ul>
<h2 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h2><h3 id="拥塞控制的一般原理"><a href="#拥塞控制的一般原理" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h3><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生拥塞(congestion)。<br>出现资源拥塞的条件： 对资源需求的总和 &gt; 可用资源<br>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。 </p>
<p>拥塞控制是很难设计的，因为它是一个动态的（而不是静态的）问题。<br>当前网络正朝着高速化的方向发展，这很容易出现缓存不够大而造成分组的丢失。但分组的丢失是网络发生拥塞的征兆而不是原因。<br>在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化甚至发生死锁的原因。这点应特别引起重视。 </p>
<h3 id="拥塞控制与流量控制的关系"><a href="#拥塞控制与流量控制的关系" class="headerlink" title="拥塞控制与流量控制的关系"></a>拥塞控制与流量控制的关系</h3><p>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。<br>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。<br>流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。<br>流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 </p>
<h3 id="开环控制和闭环控制"><a href="#开环控制和闭环控制" class="headerlink" title="开环控制和闭环控制"></a>开环控制和闭环控制</h3><p>开环控制方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。<br>闭环控制是基于反馈环路的概念。属于闭环控制的有以下几种措施：<br>监测网络系统以便检测到拥塞在何时、何处发生。<br>将拥塞发生的信息传送到可采取行动的地方。<br>调整网络系统的运行以解决出现的问题。 </p>
<h3 id="几种拥塞控制方法"><a href="#几种拥塞控制方法" class="headerlink" title="几种拥塞控制方法"></a>几种拥塞控制方法</h3><ul>
<li><ol>
<li>慢开始和拥塞避免</li>
</ol>
<p>发送方维持一个叫做拥塞窗口 cwnd (congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口。<br>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 </p>
<ul>
<li><p>慢开始算法原理</p>
<p>在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd = 1，即设置为一个最大报文段 MSS 的数值。<br>在每收到一个对新的报文段的确认后，将拥塞窗口加 1，即增加一个 MSS 的数值。<br>用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。 </p>
</li>
<li><p>传输轮次(transmission round)</p>
<p>使用慢开始算法后，每经过一个传输轮次，拥塞窗口 cwnd 就加倍。<br>一个传输轮次所经历的时间其实就是往返时间 RTT。<br>“传输轮次”更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。<br>例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。 </p>
</li>
<li><p>设置慢开始门限状态变量ssthresh</p>
<p>慢开始门限 ssthresh 的用法如下：<br>当 cwnd &lt; ssthresh 时，使用慢开始算法。<br>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。<br>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。<br>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。 </p>
</li>
<li><p>当网络出现拥塞时</p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。<br>然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。<br>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。 </p>
</li>
<li><p>慢开始和拥塞避免算法的实现举例 </p>
<p>当 TCP 连接进行初始化时，将拥塞窗口置为 1。图中的窗口单位不使用字节而使用报文段。<br>慢开始门限的初始值设置为 16 个报文段，<br>即 ssthresh = 16。<br>发送端的发送窗口不能超过拥塞窗口 cwnd 和接收端窗口 rwnd 中的最小值。我们假定接收端窗口足够大，因此现在发送窗口的数值等于拥塞窗口的数值。<br>在执行慢开始算法时，拥塞窗口 cwnd 的初始值为 1，发送第一个报文段 M0。<br>发送端每收到一个确认 ，就把 cwnd 加 1。于是发送端可以接着发送 M1 和 M2 两个报文段。<br>接收端共发回两个确认。发送端每收到一个对新报文段的确认，就把发送端的 cwnd 加 1。现在 cwnd 从 2 增大到 4，并可接着发送后面的 4 个报文段。<br>发送端每收到一个对新报文段的确认，就把发送端的拥塞窗口加 1，因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。<br>当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（即当 cwnd = 16 时），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。<br>假定拥塞窗口的数值增长到 24 时，网络出现超时，表明网络拥塞了。<br>更新后的 ssthresh 值变为 12（即发送窗口数值 24 的一半），拥塞窗口再重新设置为 1，并执行慢开始算法。<br>当 cwnd = 12 时改为执行拥塞避免算法，拥塞窗口按按线性规律增长，每经过一个往返时延就增加一个 MSS 的大小。 </p>
</li>
<li><p>乘法减小(multiplicative decrease) </p>
<p>“乘法减小“是指不论在慢开始阶段还是拥塞避免阶段，只要出现一次超时（即出现一次网络拥塞），就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值乘以 0.5。<br>当网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入到网络中的分组数。 </p>
</li>
<li><p>加法增大(additive increase) </p>
<p>“加法增大”是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口 cwnd增加一个 MSS 大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。 </p>
</li>
<li><p>“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。</p>
</li>
</ul>
</li>
</ul>
<p>“拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。 </p>
<ul>
<li><ol start="2">
<li>快重传和快恢复</li>
</ol>
<p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。<br>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。<br>不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。 </p>
<ul>
<li><p>快重传举例</p>
</li>
<li><p>快恢复算法</p>
<p>(1) 当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。<br>(2)由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。 </p>
</li>
<li><p>发送窗口的上限值</p>
<p>发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定： 发送窗口的上限值 = Min [rwnd, cwnd]<br>当 rwnd &lt; cwnd 时，是接收方的接收能力限制发送窗口的最大值。<br>当 cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口的最大值。</p>
</li>
</ul>
</li>
</ul>
<h3 id="随机早期检测-RED-Random-Early-Detection"><a href="#随机早期检测-RED-Random-Early-Detection" class="headerlink" title="随机早期检测 RED (Random Early Detection)"></a>随机早期检测 RED (Random Early Detection)</h3><p>使路由器的队列维持两个参数，即队列长度最小门限 THmin 和最大门限 THmax。<br>RED 对每一个到达的数据报都先计算平均队列长度 LAV。<br>若平均队列长度小于最小门限 THmin，则将新到达的数据报放入队列进行排队。<br>若平均队列长度超过最大门限 THmax，则将新到达的数据报丢弃。<br>若平均队列长度在最小门限 THmin 和最大门限THmax 之间，则按照某一概率 p 将新到达的数据报丢弃。 </p>
<p>- </p>
<p>  - </p>
<p>​	因为知识点很多，这部分的笔记最开始是用思维导图记的，但是图片都不能导出，xmind格式的到<a href="https://pan.baidu.com/s/1nelcbTiZayBHzq38YnH5Pg?pwd=hlr4">百度网盘</a>自行下载或者联系我私发叭，笔记效果如下（也不是那么好看，建议还是看PPT或者自己整理效率较高，我的笔记整理效果稍稍欠缺）：</p>

<div class="markmap-container" style="height:800px">
  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;第四章、传输层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;4.1 transport-layer services&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;在不同主机上运行的应用进程之间提供逻辑通信（logical communication）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;在终端系统中运行的传输协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;发送端：将应用消息分成段（segments），传递到网络层&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;接收端rcv side：将段重新组合成消息，传递到应用层&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;多个传输协议可用于应用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;互联网：TCP和UDP&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;Transport vs. network layer&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;网络层：主机之间的逻辑通信&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;传输层：进程之间的逻辑通信（processes）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;运输层的一个很重要的功能就是复用和分用。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;“运输层提供应用进程间的逻辑通信”。“逻辑通信”的意思是：运输层之间的通信好像是沿水平方向传送数据。但事实上这两个运输层之间并没有一条水平方向的物理连接。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;传输层依赖(relies on)、增强(enhances)网络层服务&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;依赖于网络层的服务 ：延时、带宽&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;并对网络层的服务进行增强： 数据丢失、顺序混乱、加密&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;有些服务是可以加强的：不可靠 -&amp;gt; 可靠；安全&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;但有些服务是不可以被加强的：带宽，延迟&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;传输层的主要功能&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;传输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;传输层还要对收到的报文进行差错检测。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;传输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;两种不同的运输协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;TCP/IP 的传输层有两个不同的协议：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;(1) 用户数据报协议 UDP (User Datagram Protocol)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;(2) 传输控制协议 TCP(Transmission Control Protocol)&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;协议特点：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;可靠的有序交付 （TCP）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;拥塞控制congestion control&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;流控制flow control&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;连接建立connection setup&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;不可靠、无序递交付（delivery）：UDP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;没有为尽力而为的IP服务添加更多的其它额外服务&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;不可用的服务：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;延迟保证delay guarantees&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;带宽保证bandwidth guarantees&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;TCP 与 UDP&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;运输层的端口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;软件端口与硬件端口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[91,92]},&quot;v&quot;:&quot;在协议栈层间的抽象的协议端口是软件端口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[92,93]},&quot;v&quot;:&quot;路由器或交换机上的端口是硬件端口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;TCP 的端口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[97,98]},&quot;v&quot;:&quot;端口用一个 16 位二进制端口号进行标志。0~65535&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[98,99]},&quot;v&quot;:&quot;端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[100,101]},&quot;v&quot;:&quot;三类端口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[102,103]},&quot;v&quot;:&quot;熟知端口，数值一般为 0~1023。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[103,104]},&quot;v&quot;:&quot;登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[104,105]},&quot;v&quot;:&quot;客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[106,107]},&quot;v&quot;:&quot;需要解决的问题&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[108,109]},&quot;v&quot;:&quot;由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[109,110]},&quot;v&quot;:&quot;有时我们会改换接收报文的进程，但并不需要通知所有发送方。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[110,111]},&quot;v&quot;:&quot;我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[112,113]},&quot;v&quot;:&quot;TCP 的连接&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[114,115]},&quot;v&quot;:&quot;TCP 把连接作为最基本的抽象。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[115,116]},&quot;v&quot;:&quot;每一条 TCP 连接有两个端点。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[116,117]},&quot;v&quot;:&quot;TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字(socket)或插口。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[117,118]},&quot;v&quot;:&quot;端口号拼接到(contatenated with) IP 地址即构成了套接字。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[119,120]},&quot;v&quot;:&quot;套接字 (socket)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[121,122]},&quot;v&quot;:&quot;每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：TCP 连接 ::= {socket1, socket2} = {(IP1: port1), (IP2: port2)}&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[123,124]},&quot;v&quot;:&quot;socket的不同含义&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[125,126]},&quot;v&quot;:&quot;应用编程接口 API 称为 socket API, 简称为 socket。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[126,127]},&quot;v&quot;:&quot;socket API 中使用的一个函数名也叫作 socket。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[127,128]},&quot;v&quot;:&quot;调用 socket 函数的端点称为 socket。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[128,129]},&quot;v&quot;:&quot;调用 socket 函数时其返回值称为 socket 描述符，可简称为 socket。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[129,130]},&quot;v&quot;:&quot;在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现。&quot;}]}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[131,132]},&quot;v&quot;:&quot;4.2 multiplexing and demultiplexing复用和解复用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[133,134]},&quot;v&quot;:&quot;复习：各层次的协议数据单元&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[135,136]},&quot;v&quot;:&quot;解复用作用：TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确的socket，从而交给正确的进程&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[137,138]},&quot;v&quot;:&quot;过程：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[139,140]},&quot;v&quot;:&quot;数据报格式&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[140,141]},&quot;v&quot;:&quot;主机接收 IP 数据报&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[142,143]},&quot;v&quot;:&quot;每个数据报都有源 IP 地址、目的 IP 地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[143,144]},&quot;v&quot;:&quot;每个数据报携带 1 个传输层报文段（segment）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[144,145]},&quot;v&quot;:&quot;每个segment都有源端口号和目标端口号（port number）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[146,147]},&quot;v&quot;:&quot;主机联合使用IP地址和端口号将报文段发送给合适的套接字&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[148,149]},&quot;v&quot;:&quot;Connectionless demultiplexing无连接解复用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[150,152]},&quot;v&quot;:&quot;eg.左右两边的Client 应用 进程P3和P4向中间的Server 应用进程P1发送UDP 数据报。P4和P3发过来的UDP报文段的目标端口（destination port）都是6428 。<br>\n即便P4和P3的源ip、源port不一样，但是都发给了中间服务器端口号为6428的、相同的应用进程。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[153,154]},&quot;v&quot;:&quot;中间的Server 的进程P1给左右主机的进程P3、P4是如何发UDP数据报的&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[155,156]},&quot;v&quot;:&quot;Connection-oriented demultiplexing面向连接的多路复用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[157,158]},&quot;v&quot;:&quot;TCP套接字socket由四个元组标识&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[159,160]},&quot;v&quot;:&quot;源IP地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[160,161]},&quot;v&quot;:&quot;源端口号&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[161,162]},&quot;v&quot;:&quot;目的IP地址&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[162,163]},&quot;v&quot;:&quot;目的端口号&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[164,165]},&quot;v&quot;:&quot;解复用：接收主机用这四个值来将数据报定位到合适的套接字&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[165,166]},&quot;v&quot;:&quot;服务器能够在一个TCP端口上同时支持多个TCP套接字：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[167,168]},&quot;v&quot;:&quot;每个套接字由其四元组标识（有不同的源IP和源PORT）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[169,170]},&quot;v&quot;:&quot;Web服务器对每个连接客户端有不同的套接字&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[171,172]},&quot;v&quot;:&quot;非持久对每个请求有不同的套接字&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[173,174]},&quot;v&quot;:&quot;一个栗子：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[175,176]},&quot;v&quot;:&quot;四元组就可以唯一确定一个TCP socket会话关系&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[177,178]},&quot;v&quot;:&quot;4.3 connectionless transport: UDP 无连接传输UDP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[179,180]},&quot;v&quot;:&quot;介绍：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[181,182]},&quot;v&quot;:&quot;“尽力而为”的服务，报文段可能&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[183,184]},&quot;v&quot;:&quot;丢失&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[184,185]},&quot;v&quot;:&quot;送到应用进程的报文段乱序delivered out of order to app&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[186,187]},&quot;v&quot;:&quot;无连接：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[188,189]},&quot;v&quot;:&quot;UDP发送端和接收端之间没有握手&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[189,190]},&quot;v&quot;:&quot;每个UDP报文段都被独立地处理&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[191,192]},&quot;v&quot;:&quot;UDP 被用于:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[193,194]},&quot;v&quot;:&quot;流媒体(streaming multimedia apps)（丢失不敏感-loss tolerant，速率敏感-rate sensitive，应用可控制传输速率）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[194,195]},&quot;v&quot;:&quot;DNS&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[195,196]},&quot;v&quot;:&quot;SNMP&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[197,198]},&quot;v&quot;:&quot;在UDP上可行可靠传输:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[199,200]},&quot;v&quot;:&quot;在应用层增加可靠性&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[200,201]},&quot;v&quot;:&quot;应用特定的差错恢复（error recovery）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[202,203]},&quot;v&quot;:&quot;UDP为什么要有&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[204,205]},&quot;v&quot;:&quot;不建立连接（会增加延时）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[205,206]},&quot;v&quot;:&quot;简单：在发送端和接收端无连接状态&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[206,207]},&quot;v&quot;:&quot;报文段的头部很小（开销小）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[207,208]},&quot;v&quot;:&quot;无拥塞控制和流量控制&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[209,210]},&quot;v&quot;:&quot;应用-&amp;gt;传输的速率=主机-&amp;gt;网络的速率&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[211,212]},&quot;v&quot;:&quot;面向报文的UDP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[218,219]},&quot;v&quot;:&quot;UDP 是面向报文的&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[219,220]},&quot;v&quot;:&quot;UDP 的首部格式&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[220,221]},&quot;v&quot;:&quot;UDP 基于端口的分用&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[222,223]},&quot;v&quot;:&quot;UDP校验和checksum&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[224,225]},&quot;v&quot;:&quot;目标：检测传输段中的“错误”（例如，翻转位flipped bits）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[225,226]},&quot;v&quot;:&quot;EDC=error-detection and-correction 差错检测和纠错比特&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[226,227]},&quot;v&quot;:&quot;发送端：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[228,229]},&quot;v&quot;:&quot;将段内容视为 16 位整数的序列&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[229,230]},&quot;v&quot;:&quot;校验和：段内容的加法（补码和）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[230,231]},&quot;v&quot;:&quot;发送方将校验和值放入 UDP 校验和字段中&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[232,233]},&quot;v&quot;:&quot;接收端：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[234,235]},&quot;v&quot;:&quot;计算已接收段的校验和&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[235,236]},&quot;v&quot;:&quot;检查计算的校验和是否等于校验和字段值：&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[236,237]},&quot;v&quot;:&quot;否 - 检测到错误&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[238,239]},&quot;v&quot;:&quot;发现错误UDP直接丢弃drop&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[240,241]},&quot;v&quot;:&quot;是 - 未检测到错误。但也许还是有错误，（错上加错，阴差阳错）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[242,243]},&quot;v&quot;:&quot;在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[243,244]},&quot;v&quot;:&quot;一个栗子：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[245,246]},&quot;v&quot;:&quot;注意：将最高有效位循环加到最后一位上（必须将进位回卷到结果上）&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[247,248]},&quot;v&quot;:&quot;4.4 principles of reliable data transfer可靠数据传输原理(rdt)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[249,250]},&quot;v&quot;:&quot;TCP最主要的特点：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[251,252]},&quot;v&quot;:&quot;TCP 是面向连接的运输层协议。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[253,254]},&quot;v&quot;:&quot;每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[255,256]},&quot;v&quot;:&quot;TCP 提供可靠交付的服务。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[257,258]},&quot;v&quot;:&quot;TCP 提供全双工通信。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[259,260]},&quot;v&quot;:&quot;面向字节流。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[261,262]},&quot;v&quot;:&quot;TCP面向流的概念&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[263,264]},&quot;v&quot;:&quot;注意：&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[270,271]},&quot;v&quot;:&quot;TCP的连接&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[277,278]},&quot;v&quot;:&quot;rdt在应用层、传输层和数据链路层都很重要&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[279,280]},&quot;v&quot;:&quot;信道的不可靠特点决定了可靠数据传输协议（rdt）的复杂性&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[281,282]},&quot;v&quot;:&quot;传输层和应用层关系&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[283,284]},&quot;v&quot;:&quot;可靠数据传输 问题描述：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[285,286]},&quot;v&quot;:&quot;渐增式（incrementally）地开发可靠数据传输协议（ rdt ）的发送方和接收方&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[286,287]},&quot;v&quot;:&quot;只考虑单向数据传输，但控制信息是双向流动的&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[287,288]},&quot;v&quot;:&quot;双向的数据传输问题实际上是2个单向数据传输问题的综合&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[288,289]},&quot;v&quot;:&quot;使用有限状态机 (finite state machines, FSM) 来描述发送方和接收方&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[290,291]},&quot;v&quot;:&quot;Rdt1.0： 在可靠信道上的可靠数据传输&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[292,293]},&quot;v&quot;:&quot;前提：下层信道是完全可靠的&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[294,295]},&quot;v&quot;:&quot;没有比特出错bit errors&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[295,296]},&quot;v&quot;:&quot;没有分组丢失loss of packets&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[297,298]},&quot;v&quot;:&quot;发送方和接收方的FSM&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[299,300]},&quot;v&quot;:&quot;发送方将数据发送到下层信道&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[300,301]},&quot;v&quot;:&quot;接收方从下层信道接收数据&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[302,303]},&quot;v&quot;:&quot;Rdt2.0：具有比特差错的信道&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[304,305]},&quot;v&quot;:&quot;下层信道可能会出错：将分组中的比特翻转&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[306,307]},&quot;v&quot;:&quot;用校验和来检测比特差错&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[308,309]},&quot;v&quot;:&quot;问题：怎样从差错中恢复：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[310,311]},&quot;v&quot;:&quot;acknowledgements确认(ACK)：接收方显式地告诉发送方分组已被正确接收&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[311,312]},&quot;v&quot;:&quot;negative acknowledgements否定确认( NAK): 接收方显式地告诉发送方分组发生了差错&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[312,313]},&quot;v&quot;:&quot;发送方收到NAK后，发送方重传分组&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[314,315]},&quot;v&quot;:&quot;rdt2.0中的新机制(mechanisms)（相较于rdt1.0）：采用差错控制编码进行差错检测&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[316,317]},&quot;v&quot;:&quot;发送方差错控制编码、缓存&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[317,318]},&quot;v&quot;:&quot;接收方使用编码检错&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[318,319]},&quot;v&quot;:&quot;接收方的反馈：控制报文（ACK，NAK）：接收方→发送方&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[319,320]},&quot;v&quot;:&quot;发送方收到反馈相应的动作&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[321,322]},&quot;v&quot;:&quot;FSM描述&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[323,324]},&quot;v&quot;:&quot;没有差错时的操作&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[324,325]},&quot;v&quot;:&quot;有差错时error scenario&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[326,327]},&quot;v&quot;:&quot;rdt2.0的致命缺陷&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[328,329]},&quot;v&quot;:&quot;如果ACK/NAK出错(corrupted)？&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[330,331]},&quot;v&quot;:&quot;发送方不知道接收方发生了什么事情！&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[331,332]},&quot;v&quot;:&quot;发送方如何做？&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[333,334]},&quot;v&quot;:&quot;重传？可能重复&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[334,335]},&quot;v&quot;:&quot;不重传？可能死锁(或出错)&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[336,337]},&quot;v&quot;:&quot;需要引入新的机制&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[338,339]},&quot;v&quot;:&quot;序号sequence number&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[340,341]},&quot;v&quot;:&quot;处理重复&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[342,343]},&quot;v&quot;:&quot;发送方在每个分组中加入序号(sequence number )&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[343,344]},&quot;v&quot;:&quot;如果ACK/NAK出错，发送方重传当前分组&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[344,345]},&quot;v&quot;:&quot;接收方丢弃（不发给上层）重复分组&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[346,347]},&quot;v&quot;:&quot;停等协议stop and wait&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[348,349]},&quot;v&quot;:&quot;发送方发送一个分组，然后等待接收方的应答，如果超过略大于“从发送方到接收方的平均往返时间”，就定为超时，然后重传。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[350,351]},&quot;v&quot;:&quot;停止等待协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[356,357]},&quot;v&quot;:&quot;确认丢失和确认迟到&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[357,358]},&quot;v&quot;:&quot;信道利用率很低，但是优点是简单&quot;}]}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[359,360]},&quot;v&quot;:&quot;Rdt2.1：处理出错(garbled)的ACK/NAK&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[361,362]},&quot;v&quot;:&quot;发送方处理出错的ACK/NAK&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[363,364]},&quot;v&quot;:&quot;接收方处理出错的ACK/NAK&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[365,366]},&quot;v&quot;:&quot;讨论&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[367,368]},&quot;v&quot;:&quot;发送方&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[369,370]},&quot;v&quot;:&quot;在分组中加入序列号（seq #）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[370,371]},&quot;v&quot;:&quot;两个序列号（0，1）就足够了&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[372,373]},&quot;v&quot;:&quot;一次只发送一个未经确认的分组&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[374,375]},&quot;v&quot;:&quot;必须检测ACK/NAK是否出错（需要EDC ）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[375,376]},&quot;v&quot;:&quot;FSM状态数变成了两倍&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[377,378]},&quot;v&quot;:&quot;必须记住当前分组的序列号为0还是1&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[379,380]},&quot;v&quot;:&quot;接收方&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[381,382]},&quot;v&quot;:&quot;必须检测接收到的分组是否是重复的&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[383,384]},&quot;v&quot;:&quot;状态会指示希望接收到的分组的序号为0还是1&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[385,386]},&quot;v&quot;:&quot;注意：接收方并不知道发送方是否正确收到了其ACK/NAK&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[387,388]},&quot;v&quot;:&quot;没有安排确认的确认&quot;}]}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[389,390]},&quot;v&quot;:&quot;rdt2.1的运行&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[396,397]},&quot;v&quot;:&quot;Rdt2.2: a NAK-free protocol无NAK的协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[398,399]},&quot;v&quot;:&quot;功能同rdt2.1，但只使用ACK(ack 要编号）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[399,400]},&quot;v&quot;:&quot;接收方对最后正确接收的分组发ACK，以替代NAK&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[401,402]},&quot;v&quot;:&quot;接收方必须显式地(explicitly)包含被正确接收分组的序号&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[403,404]},&quot;v&quot;:&quot;当收到重复的ACK（如：再次收到ack0）时，发送方与收到NAK采取相同的动作：重传当前分组&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[404,405]},&quot;v&quot;:&quot;为后面的一次发送多个数据单位做一个准备&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[406,407]},&quot;v&quot;:&quot;一次能够发送多个&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[407,408]},&quot;v&quot;:&quot;每一个的应答都有：ACK，NACK；麻烦&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[408,409]},&quot;v&quot;:&quot;使用对前一个数据单位的ACK，代替本数据单位的nak&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[409,410]},&quot;v&quot;:&quot;确认信息减少一半，协议处理简单&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[411,412]},&quot;v&quot;:&quot;发送方和接收方片断&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[412,413]},&quot;v&quot;:&quot;rdt2.2的运行&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[414,415]},&quot;v&quot;:&quot;Rdt3.0: channels with errors and loss具有比特差错和分组丢失的信道&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[416,461]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[416,417]},&quot;v&quot;:&quot;新的假设&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[418,419]},&quot;v&quot;:&quot;下层信道可能会丢失分组（数据或ACK）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[420,421]},&quot;v&quot;:&quot;解决的问题：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[422,423]},&quot;v&quot;:&quot;会死锁&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[424,425]},&quot;v&quot;:&quot;机制还不够处理这种状况&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[431,432]},&quot;v&quot;:&quot;方法：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[433,434]},&quot;v&quot;:&quot;发送方等待ACK一段合理的时间&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[437,438]},&quot;v&quot;:&quot;发送端超时重传：如果到时没有收到ACK-》重传&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[438,439]},&quot;v&quot;:&quot;新的问题：如果分组（ACK）只是被延迟了？&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[440,441]},&quot;v&quot;:&quot;重传会导致数据重复，但利用序列号已经可以处理这个问题&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[441,442]},&quot;v&quot;:&quot;接收方必须指明被正确接受的序号&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[443,444]},&quot;v&quot;:&quot;解决新的问题：需要一个倒计数定时器(countdown timer)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[445,446]},&quot;v&quot;:&quot;在给定的时间量过期后，可中断发送方&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[447,448]},&quot;v&quot;:&quot;rdt3.0发送方&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[449,450]},&quot;v&quot;:&quot;每次发送一个分组（包括第一次分组和重传分组）时，便启动一个定时器。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[450,451]},&quot;v&quot;:&quot;响应定时器中断（采取适当的动作）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[451,452]},&quot;v&quot;:&quot;中止定时器&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[453,454]},&quot;v&quot;:&quot;rdt3.0的运行&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[455,456]},&quot;v&quot;:&quot;rdt3.0可以工作，但链路容量比较大的情况下，性能很差(performance stinks性能不好)&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[457,458]},&quot;v&quot;:&quot;rdt3.0的性能&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[459,460]},&quot;v&quot;:&quot;瓶颈在于：网络协议限制了物理资源的利用&quot;}]}]},{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[477,492]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[477,478]},&quot;v&quot;:&quot;rdt3.0: stop-and-wait operation停-等操作&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[478,479]},&quot;v&quot;:&quot;流水线协议Pipelined protocols：提高链路利用率&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[480,481]},&quot;v&quot;:&quot;允许发送方在未得到对方确认的情况下一次发送多个分组&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[481,482]},&quot;v&quot;:&quot;必须增加序号的范围:用多个bit表示分组的序号&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[482,483]},&quot;v&quot;:&quot;在发送方/接收方要有缓冲区&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[484,485]},&quot;v&quot;:&quot;发送方缓冲：未得到确认，可能需要重传；&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[485,486]},&quot;v&quot;:&quot;接收方缓存：上层用户取用数据的速率≠接收到的数据速率；接收到的数据可能乱序，排序交付（可靠）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[487,488]},&quot;v&quot;:&quot;两种通用的流水线协议：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[489,490]},&quot;v&quot;:&quot;回退N步(go-Back-N，GBN)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[490,491]},&quot;v&quot;:&quot;选择重传(selective repeat，SR)&quot;}]}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[492,493]},&quot;v&quot;:&quot;流水线协议Pipelined protocols：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[497,498]},&quot;v&quot;:&quot;Go-back-N和Selective Repeat对比（回退N步和选择重传对比）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[499,501]},&quot;v&quot;:&quot;发送端发送数量（此点相同）<br>\n一次都可以发送多个未经确认的分组&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[502,504]},&quot;v&quot;:&quot;发送端最多在流水线中有N个<br>\n未确认的分组（unacked packets）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[504,506]},&quot;v&quot;:&quot;发送端最多在流水线中<br>\n有N个未确认的分组&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[507,508]},&quot;v&quot;:&quot;ack对比&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[509,510]},&quot;v&quot;:&quot;接收方对每个到来的分组单独确认individual ack（非累计确认）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[510,512]},&quot;v&quot;:&quot;接收端只是发送累计型确认cumulative ack<br>\n（接收端如果发现gap，不确认新到来的分组）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[513,514]},&quot;v&quot;:&quot;定时器对比&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[515,516]},&quot;v&quot;:&quot;发送方为每个未确认的分组保持一个定时器（当超时定时器到时，只是重发到时的未确认分组）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[516,517]},&quot;v&quot;:&quot;发送端拥有对最早发送的的未确认分组的定时器（只需设置一个定时器，当定时器到时时，重传所有未确认分组）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[518,519]},&quot;v&quot;:&quot;优点&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[520,522]},&quot;v&quot;:&quot;简单，所需资源少<br>\n（接收方一个缓存单元）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[522,524]},&quot;v&quot;:&quot;出错时，重传一个<br>\n代价小&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[525,526]},&quot;v&quot;:&quot;缺点&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[527,528]},&quot;v&quot;:&quot;一旦出错，回退N步代价大&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[528,530]},&quot;v&quot;:&quot;复杂，所需要资源多<br>\n（接收方多个缓存单元）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[531,532]},&quot;v&quot;:&quot;适用范围&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[533,534]},&quot;v&quot;:&quot;出错率低：比较适合GBN，出错非常罕见，没有必要用复杂的SR，为罕见的事件做日常的准备和复杂处理&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[534,535]},&quot;v&quot;:&quot;链路容量大（延迟大、带宽大）：比较适合SR而不是GBN，一点出错代价太大&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[536,537]},&quot;v&quot;:&quot;窗口的最大尺寸&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[538,539]},&quot;v&quot;:&quot;SR:2^(n-1)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[539,540]},&quot;v&quot;:&quot;GBN: 2^n-1&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[541,542]},&quot;v&quot;:&quot;(Go-back-N,GBN)回退N步，也称为滑动窗口协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[543,544]},&quot;v&quot;:&quot;发送端&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[545,546]},&quot;v&quot;:&quot;分组标头中的k位序号&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[546,547]},&quot;v&quot;:&quot;“window”最多 N （窗口长度）个，允许连续未确定的分组&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[548,549]},&quot;v&quot;:&quot;发送方扩展的FSM&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[549,550]},&quot;v&quot;:&quot;接收方扩展的FSM&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[551,552]},&quot;v&quot;:&quot;只发送ACK：对顺序接收的最高序号的分组&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[553,554]},&quot;v&quot;:&quot;可能会产生重复的ACK&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[554,555]},&quot;v&quot;:&quot;只需记住（expectedseqnum）；接收窗口=1(只一个变量就可表示接收窗口)&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[556,557]},&quot;v&quot;:&quot;对乱序的分组：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[558,559]},&quot;v&quot;:&quot;丢弃（不缓存） →在接收方不被缓存❗&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[559,560]},&quot;v&quot;:&quot;对顺序接收的最高序号的分组进行确认-累计确认&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[561,562]},&quot;v&quot;:&quot;运行中的GBN&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[563,564]},&quot;v&quot;:&quot;(SR,Selective Repeat)选择重传&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[565,567]},&quot;v&quot;:&quot;接收方对每个正确接收的分组，分别发送<br>\nACKn（非累积确认）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[568,569]},&quot;v&quot;:&quot;接收窗口&amp;gt;1（可以缓存乱序的分组，根据需要缓存分组）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[569,570]},&quot;v&quot;:&quot;最终将分组按顺序交付给上层&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[571,572]},&quot;v&quot;:&quot;发送方只对那些没有收到ACK的分组进行重发-选择性重发&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[573,574]},&quot;v&quot;:&quot;发送方为每个未确认的分组设定一个定时器&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[575,576]},&quot;v&quot;:&quot;发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[576,577]},&quot;v&quot;:&quot;发送方&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[578,579]},&quot;v&quot;:&quot;从上层接收数据&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[580,581]},&quot;v&quot;:&quot;如果下一个可用于该分组的序号可在发送窗口中，则发送&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[582,583]},&quot;v&quot;:&quot;timeout(n):&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[584,585]},&quot;v&quot;:&quot;重新发送分组n，重新设定定时器&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[586,588]},&quot;v&quot;:&quot;&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[628,629]},&quot;v&quot;:&quot;可靠通信的实现&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[634,635]},&quot;v&quot;:&quot;连续 ARQ 协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[636,637]},&quot;v&quot;:&quot;Go-back-N协议表明当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[638,639]},&quot;v&quot;:&quot;累计确认&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[643,644]},&quot;v&quot;:&quot;TCP可靠通信的具体实现&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[650,651]},&quot;v&quot;:&quot;4.5 connection-oriented transport: TCP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[662,663]},&quot;v&quot;:&quot;4.5.1报文段结构segment structure&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[664,719]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[666,686]},&quot;v&quot;:&quot;源端口和目的端口字段——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。<br>\n序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。<br>\n确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。<br>\n数据偏移（即首部长度）——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。<br>\n保留字段——占 6 位，保留为今后使用，但目前应置为 0。<br>\n紧急 URG —— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。<br>\n确认 ACK —— 只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。<br>\n推送 PSH (PuSH) —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。<br>\n复位 RST (ReSeT) —— 当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。<br>\n同步 SYN —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。<br>\n终止 FIN (FINis) —— 用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。<br>\n窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。<br>\n检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。<br>\n紧急指针字段 —— 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。<br>\n选项字段 —— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”<br>\nMSS (Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。<br>\n窗口扩大选项 ——占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于TCP 首部中的窗口位数增大到(16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小。<br>\n时间戳选项——占10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）。<br>\n选择确认选项——在后面介绍。<br>\n填充字段 —— 这是为了使整个首部长度是 4 字节的整数倍。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[687,688]},&quot;v&quot;:&quot;TCP seq. numbers, ACKs序号、确认号&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[689,690]},&quot;v&quot;:&quot;序号sequence numbers：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[691,692]},&quot;v&quot;:&quot;报文段首字节的在字节流的编号&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[693,694]},&quot;v&quot;:&quot;确认号acknowledgements:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[695,696]},&quot;v&quot;:&quot;期望从另一方收到的下一个字节的序号（seq # ）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[696,697]},&quot;v&quot;:&quot;累积（cumulative）确认&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[698,699]},&quot;v&quot;:&quot;TCP不考虑接收方对乱序的报文段的排序问题&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[699,701]},&quot;v&quot;:&quot;&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[701,702]},&quot;v&quot;:&quot;TCP round trip time(往返延时, RTT), timeout(超时)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[703,704]},&quot;v&quot;:&quot;怎样设置TCP超时的值？&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[705,706]},&quot;v&quot;:&quot;比RTT要长， 但RTT是变化的&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[706,707]},&quot;v&quot;:&quot;太短：太早(premature)超时→不必要的重传&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[707,708]},&quot;v&quot;:&quot;太长：对报文段丢失反应太慢&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[709,710]},&quot;v&quot;:&quot;怎样估计(estimate)RTT？&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[711,712]},&quot;v&quot;:&quot;SampleRTT：测量从报文段发出到收到ack确认的时间（如果有重传，忽略此次测量）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[712,713]},&quot;v&quot;:&quot;SampleRTT会变化，因此估计的RTT应该比较平滑 → 对几个最近的测量值求平均，而不是仅用当前的SampleRTT&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[714,718]},&quot;v&quot;:&quot;EstimatedRTT：加权平均往返时间<br>\n指数加权(exponential weighted)移动平均<br>\n过去样本的影响呈指数衰减<br>\n推荐值：α = 0.125（0&amp;lt;α&amp;lt;1）&quot;}]}]},{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[798,814]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[798,799]},&quot;v&quot;:&quot;TCP可靠传输的实现：以字节为单位的滑动窗口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[800,806]},&quot;v&quot;:&quot;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[806,807]},&quot;v&quot;:&quot;发送缓存&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[807,808]},&quot;v&quot;:&quot;接收缓存&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[808,809]},&quot;v&quot;:&quot;注意：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[810,811]},&quot;v&quot;:&quot;A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[811,812]},&quot;v&quot;:&quot;TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[812,813]},&quot;v&quot;:&quot;TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。&quot;}]}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[814,815]},&quot;v&quot;:&quot;4.5.2 TCP：reliable data transfer可靠数据传输&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[816,817]},&quot;v&quot;:&quot;概述&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[818,819]},&quot;v&quot;:&quot;TCP在IP不可靠服务的基础上建立了rdt&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[820,821]},&quot;v&quot;:&quot;管道化的报文段(GBN or SR)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[821,822]},&quot;v&quot;:&quot;累积确认（像GBN）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[822,823]},&quot;v&quot;:&quot;单个重传定时器（像GBN）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[824,825]},&quot;v&quot;:&quot;通过以下事件触发重传&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[826,827]},&quot;v&quot;:&quot;超时（只重发那个最早的未确认段：SR）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[827,828]},&quot;v&quot;:&quot;重复的确认&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[829,830]},&quot;v&quot;:&quot;首先考虑简化的TCP发送方：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[831,832]},&quot;v&quot;:&quot;忽略重复的确认&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[832,833]},&quot;v&quot;:&quot;忽略流量控制和拥塞控制&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[834,835]},&quot;v&quot;:&quot;TCP sender events发送方事件：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[836,837]},&quot;v&quot;:&quot;从应用层接收数据：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[838,839]},&quot;v&quot;:&quot;用nextseq创建报文段&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[839,840]},&quot;v&quot;:&quot;序号nextseq为报文段首字节的字节流编号&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[840,841]},&quot;v&quot;:&quot;如果还没有运行，启动定时器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[842,843]},&quot;v&quot;:&quot;定时器与最早未确认的报文段关联&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[843,844]},&quot;v&quot;:&quot;过期间隔(expiration interval)：TimeOutInterval&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[845,846]},&quot;v&quot;:&quot;超时：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[847,848]},&quot;v&quot;:&quot;重传导致超时的报文段&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[848,849]},&quot;v&quot;:&quot;重新启动定时器&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[850,851]},&quot;v&quot;:&quot;收到确认：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[852,853]},&quot;v&quot;:&quot;如果是对尚未确认的报文段确认&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[854,855]},&quot;v&quot;:&quot;更新已被确认的报文序号&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[855,856]},&quot;v&quot;:&quot;如果当前还有未被确认的报文段，重新启动定时器&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[857,858]},&quot;v&quot;:&quot;简化的状态图&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[859,860]},&quot;v&quot;:&quot;TCP重传场景&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[861,863]},&quot;v&quot;:&quot;&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[863,864]},&quot;v&quot;:&quot;TCP fast retransmit快速重传&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[865,867]},&quot;v&quot;:&quot;超时周期往往太长：在重传丢失报文段之前的<br>\n延时太长&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[867,868]},&quot;v&quot;:&quot;通过重复的ACK来检测报文段丢失&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[869,870]},&quot;v&quot;:&quot;发送方通常连续发送大量报文段&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[870,871]},&quot;v&quot;:&quot;如果报文段丢失，通常会引起多个重复的ACK&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[871,872]},&quot;v&quot;:&quot;原因：如果发送方收到同一数据的3个冗余ACK，重传最小序号的段：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[873,878]},&quot;v&quot;:&quot;快速重传：在定时器过时之前重发报文段<br>\n它假设跟在被确认的数据后面的数据丢失了<br>\n第一个ACK是正常的；<br>\n收到第二个该段的ACK，表示接收方收到一个该段后的乱序段；<br>\n收到第3，4个该段的ack，表示接收方收到该段之后的2个，3个乱序段，可能性非常大，段丢失了，无需再等到时延后再重传&quot;}]}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[879,880]},&quot;v&quot;:&quot;4.5.3 TCP flow control流量控制&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[881,900]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[881,882]},&quot;v&quot;:&quot;接收方控制发送方，不让发送方发的太多太快以至于让接收方的缓冲区溢出&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[883,884]},&quot;v&quot;:&quot;缓冲区TCP往里面写，app从当中读取&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[885,888]},&quot;v&quot;:&quot;实现原理：接收方在其向发送方的TCP段头部的rwnd字段“通告”其空闲buffer大小<br>\n发送端将未确认的数据限制为RcvWindow<br>\nRcvr（接收端）在大于RcvWindow的段找可用空间？？？&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[889,890]},&quot;v&quot;:&quot;虽然达到流量控制，但是应用进程从缓冲区读取时可能会很慢&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[890,891]},&quot;v&quot;:&quot;速度匹配服务：将发送速率与接收应用的消耗速率相匹配&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[891,894]},&quot;v&quot;:&quot;假设TCP接收端丢弃无序报文段时<br>\n缓存中可用的空间=RcvWindow<br>\n= RcvBuffer-[LastByteRcvd - LastByteRead]&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[895,896]},&quot;v&quot;:&quot;利用滑动窗口实现流量控制&quot;}]},{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[902,918]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[902,903]},&quot;v&quot;:&quot;流量控制举例&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[904,905]},&quot;v&quot;:&quot;持续计时器(persistence timer)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[912,913]},&quot;v&quot;:&quot;必须考虑传输效率&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[921,922]},&quot;v&quot;:&quot;4.5.4 connection management连接管理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[923,924]},&quot;v&quot;:&quot;Recall：TCP发送方、接收方在交换数据段前建立“连接”&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[925,926]},&quot;v&quot;:&quot;初始化TCP变量&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[927,928]},&quot;v&quot;:&quot;序号seq.#s&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[928,929]},&quot;v&quot;:&quot;缓冲区、流量控制信息（eg.Rcvwindow）&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[930,931]},&quot;v&quot;:&quot;客户端：连接启动器（connection initiator）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[932,933]},&quot;v&quot;:&quot;Socket clientSocket = new Socket(&amp;quot;hostname&amp;quot;,&amp;quot;port number&amp;quot;);&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[934,935]},&quot;v&quot;:&quot;服务器：由客户联系&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[936,937]},&quot;v&quot;:&quot;Socket connectionSocket = welcomeSocket.accept();&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[938,939]},&quot;v&quot;:&quot;3次握手&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[940,941]},&quot;v&quot;:&quot;步骤 1：客户端主机将 TCP SYN 段发送到服务器&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[942,943]},&quot;v&quot;:&quot;指定初始序号seq#&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[943,944]},&quot;v&quot;:&quot;无数据&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[945,946]},&quot;v&quot;:&quot;步骤2：服务器主机接收SYN，使用SYNACK段回复&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[947,948]},&quot;v&quot;:&quot;服务器分配缓冲区&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[948,949]},&quot;v&quot;:&quot;指定服务器初始 seq.#&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[950,951]},&quot;v&quot;:&quot;步骤3：客户端接收SYNACK，使用ACK段回复，其中可能包含数据&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[952,953]},&quot;v&quot;:&quot;在正式交换数据之前，发送方和接收方握手建立通信关系:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[954,955]},&quot;v&quot;:&quot;同意建立连接（每一方都知道对方愿意建立连接）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[955,956]},&quot;v&quot;:&quot;同意连接参数&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[957,958]},&quot;v&quot;:&quot;Agreeing to establish a connection同意建立连接&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[959,960]},&quot;v&quot;:&quot;两次握手不总是可以确保建立连接&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[961,962]},&quot;v&quot;:&quot;变化的延迟（连接请求的段没有丢，但可能超时）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[962,963]},&quot;v&quot;:&quot;由于丢失造成的重传 (e.g.req_conn(x))&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[963,964]},&quot;v&quot;:&quot;报文乱序&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[964,965]},&quot;v&quot;:&quot;相互看不到对方&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[965,966]},&quot;v&quot;:&quot;一个栗子&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[967,968]},&quot;v&quot;:&quot;3次握手&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[969,970]},&quot;v&quot;:&quot;解决的问题：半连接和接收老数据问题&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[970,971]},&quot;v&quot;:&quot;3次握手：FSM&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[972,973]},&quot;v&quot;:&quot;TCP: 关闭连接closing a connection&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[974,975]},&quot;v&quot;:&quot;客户端，服务器分别关闭它自己这一侧的连接&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[976,977]},&quot;v&quot;:&quot;发送FIN bit = 1的TCP段&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[978,979]},&quot;v&quot;:&quot;一旦接收到FIN，用ACK回应&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[980,981]},&quot;v&quot;:&quot;接到FIN段，ACK可以和它自己发出的FIN段一起发送&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[982,983]},&quot;v&quot;:&quot;可以处理同时(simultaneous)的FIN交换&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[984,985]},&quot;v&quot;:&quot;总结：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[988,993]},&quot;v&quot;:&quot;运输连接就有三个阶段，即：连接建立、数据传送和连接释放。运输连接的管理就是使运输连接的建立和释放都能正常地进行。<br>\n连接建立过程中要解决以下三个问题：<br>\n要使每一方能够确知对方的存在。<br>\n要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）。<br>\n能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[986,987],&quot;index&quot;:1},&quot;v&quot;:&quot;1. 运输连接的三个阶段&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[994,995]},&quot;v&quot;:&quot;客户服务器方式&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1000,1001]},&quot;v&quot;:&quot;过程：握手、连接释放PPT p164-177&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1002,1003]},&quot;v&quot;:&quot;A 必须等待 2MSL 的时间&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1007,1008]},&quot;v&quot;:&quot;4.6 principles of congestion control拥塞控制原理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1009,1010]},&quot;v&quot;:&quot;拥塞:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1011,1012]},&quot;v&quot;:&quot;非正式的定义: “太多的数据需要网络传输，超过了网络的处理能力”&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1012,1013]},&quot;v&quot;:&quot;与流量控制不同&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1013,1014]},&quot;v&quot;:&quot;拥塞的表现manifestations:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1015,1016]},&quot;v&quot;:&quot;分组丢失 (路由器缓冲区溢出)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1016,1017]},&quot;v&quot;:&quot;分组经历比较长的延迟(在路由器的队列中排队)&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1018,1019]},&quot;v&quot;:&quot;拥塞的原因/代价: 场景(scenario)1&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1019,1020]},&quot;v&quot;:&quot;拥塞的原因/代价: 场景2&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1021,1025]},&quot;v&quot;:&quot;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1025,1029]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[1027,1028]},&quot;v&quot;:&quot;retrans（重传）&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1029,1030]},&quot;v&quot;:&quot;拥塞的原因/代价: 场景3&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1033,1034]},&quot;v&quot;:&quot;拥塞控制方法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1035,1036]},&quot;v&quot;:&quot;端到端拥塞控制:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1037,1038]},&quot;v&quot;:&quot;没有来自网络的显式反馈&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1038,1039]},&quot;v&quot;:&quot;端系统根据延迟和丢失事件推断是否有拥塞&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1039,1040]},&quot;v&quot;:&quot;TCP采用的方法&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1041,1042]},&quot;v&quot;:&quot;网络辅助的拥塞控制:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1043,1044]},&quot;v&quot;:&quot;路由器提供给端系统以反馈信息&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1044,1045]},&quot;v&quot;:&quot;单个bit置位，显示有拥塞 (SNA, DECbit,TCP/IP ECN, ATM)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1045,1046]},&quot;v&quot;:&quot;显式提供发送端可以采用的速率&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1047,1048]},&quot;v&quot;:&quot;4.7 TCP congestion control（TCP拥塞控制）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1049,1050]},&quot;v&quot;:&quot;TCP 拥塞控制：AIMD（additive increase multiplication decrease）加性增，乘性减&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1051,1052]},&quot;v&quot;:&quot;方法：发送方提高传输速率（窗口大小），探测可用带宽，直到发生丢失&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1058,1060]},&quot;v&quot;:&quot;加法增加：<br>\n当CongWin&amp;gt;阈值时，一个RTT如没有发生丢失事件 ,将CongWin加1MSS: 探测&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1060,1062]},&quot;v&quot;:&quot;乘法减少:<br>\n丢失事件后将CongWin降为1，将CongWin/2作为阈值，进入慢启动阶段（倍增直到CongWin/2）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1062,1063]},&quot;v&quot;:&quot;cwnd是动态的，有感知网络拥塞的功能&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1063,1065]},&quot;v&quot;:&quot;TCP发送速率：<br>\n大致就是cwnd字节，等待RTT的ACKS，然后发送更多字节&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1066,1067]},&quot;v&quot;:&quot;TCP慢启动&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1068,1069]},&quot;v&quot;:&quot;当连接开始时，指数性增加（每个RTT）发送速率直到发生丢失事件&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1070,1071]},&quot;v&quot;:&quot;连接刚建立, CongWin = 1MSS&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1071,1072]},&quot;v&quot;:&quot;每一个RTT， CongWin加倍&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1072,1073]},&quot;v&quot;:&quot;每收到一个ACK时，CongWin加1（why）&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1073,1074]},&quot;v&quot;:&quot;慢启动阶段：只要不超时或3个重复ack，一个RTT， CongWin加倍&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1075,1076]},&quot;v&quot;:&quot;总结: 初始速率很慢，但是加速却是指数性的&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1077,1078]},&quot;v&quot;:&quot;指数增加，SS时间很短，长期来看可以忽略&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1079,1080]},&quot;v&quot;:&quot;TCP：detecting, reacting to loss&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1083,1085]},&quot;v&quot;:&quot;loss indicated by timeout<br>\n超时指示的损失：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1086,1087]},&quot;v&quot;:&quot;1.cwnd 设置为 1 MSS;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1087,1088]},&quot;v&quot;:&quot;2.然后窗口呈指数级增长（exponentially）（如在慢启动时）到阈值（threshold），然后线性（linearly）增长&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1089,1090]},&quot;v&quot;:&quot;由 3 个重复的 ACK 指示的丢失：TCP RENO&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1091,1092]},&quot;v&quot;:&quot;dup ACK 表示网络能够提供某些网段&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1092,1093]},&quot;v&quot;:&quot;cwnd被切成两半的窗口，然后线性增长&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1094,1095]},&quot;v&quot;:&quot;TCP Tahoe 始终将 cwnd 设置为 1（超时timeout或 3 个重复的 ack）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1096,1097]},&quot;v&quot;:&quot;TCP：从慢启动切换到 CA（switching from slow start to CA）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1098,1100]},&quot;v&quot;:&quot;问：指数增长何时应切换到线性？<br>\n答：当cwnd在超时之前达到其值的1/2时。&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1100,1102]},&quot;v&quot;:&quot;实现：通过可变的ssthresh<br>\n在loss事件时，ssthresh 设置为亏损事件发生前 cwnd 的 1/2&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1103,1104]},&quot;v&quot;:&quot;总结：&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1105,1106]},&quot;v&quot;:&quot;TCP吞吐量throughput&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1107,1109]},&quot;v&quot;:&quot;TCP的平均吞吐量是多少，使用窗口window尺寸W和RTT来描述?<br>\n忽略慢启动阶段，假设发送端总有数据传输&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1109,1111]},&quot;v&quot;:&quot;&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1111,1112]},&quot;v&quot;:&quot;&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1113,1114]},&quot;v&quot;:&quot;TCP公平性fairness&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1115,1116]},&quot;v&quot;:&quot;公平性目标goal：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1117,1118]},&quot;v&quot;:&quot;如果 K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为 R/K&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1119,1120]},&quot;v&quot;:&quot;TCP公平的原因&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1123,1124]},&quot;v&quot;:&quot;Explicit Congestion Notification (ECN)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1125,1126]},&quot;v&quot;:&quot;网络辅助拥塞控制:&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1131,1132]},&quot;v&quot;:&quot;总结：&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1133,1134]},&quot;v&quot;:&quot;拥塞控制的一般原理&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1144,1145]},&quot;v&quot;:&quot;拥塞控制与流量控制的关系&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1152,1153]},&quot;v&quot;:&quot;开环控制和闭环控制&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1160,1161]},&quot;v&quot;:&quot;几种拥塞控制方法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1162,1166]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1164,1166]},&quot;v&quot;:&quot;发送方维持一个叫做拥塞窗口 cwnd (congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口。<br>\n发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1162,1163],&quot;index&quot;:1},&quot;v&quot;:&quot;1. 慢开始和拥塞避免&quot;}]}]},{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1168,1221]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1168,1169]},&quot;v&quot;:&quot;慢开始算法原理&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1174,1175]},&quot;v&quot;:&quot;传输轮次(transmission round)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1181,1182]},&quot;v&quot;:&quot;设置慢开始门限状态变量ssthresh&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1189,1190]},&quot;v&quot;:&quot;当网络出现拥塞时&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1195,1196]},&quot;v&quot;:&quot;慢开始和拥塞避免算法的实现举例&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1210,1211]},&quot;v&quot;:&quot;乘法减小(multiplicative decrease)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1215,1216]},&quot;v&quot;:&quot;加法增大(additive increase)&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1219,1220]},&quot;v&quot;:&quot;“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。&quot;}]},{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1223,1228]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1225,1228]},&quot;v&quot;:&quot;快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。<br>\n发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。<br>\n不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[1223,1224],&quot;index&quot;:2},&quot;v&quot;:&quot;2. 快重传和快恢复&quot;}]}]},{&quot;t&quot;:&quot;bullet_list&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[1230,1243]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1230,1231]},&quot;v&quot;:&quot;快重传举例&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1232,1233]},&quot;v&quot;:&quot;快恢复算法&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[1237,1238]},&quot;v&quot;:&quot;发送窗口的上限值&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1243,1244]},&quot;v&quot;:&quot;随机早期检测 RED (Random Early Detection)&quot;}]}]}">
</svg></div>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概论笔记</title>
    <url>/2023/01/10/shu-ju-ku-gai-lun-bi-ji/</url>
    <content><![CDATA[<h2 id="第一章introduction"><a href="#第一章introduction" class="headerlink" title="第一章introduction"></a>第一章introduction</h2><h4 id="Database-System-DBS-："><a href="#Database-System-DBS-：" class="headerlink" title="Database System (DBS)："></a>Database System (DBS)：</h4><ul>
<li><p>收集相互关联的数据</p>
<ul>
<li>Database (DB): contains information about a particular enterprise</li>
</ul>
</li>
<li><p>用于访问数据的程序集</p>
<ul>
<li>Database Management System数据库管理系统(DBMS)：提供一种既方便又高效的数据库信息存储和检索方法</li>
</ul>
</li>
</ul>
<p>分层体系结构<strong>Hierarchical Architecture</strong>：</p>
<p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110140556042.png"></p>
<h4 id="使用文件系统来存储和操作数据的缺点drawbacks"><a href="#使用文件系统来存储和操作数据的缺点drawbacks" class="headerlink" title="使用文件系统来存储和操作数据的缺点drawbacks"></a>使用文件系统来存储和操作数据的缺点<strong>drawbacks</strong></h4><ul>
<li>数据冗余redundancy和不一致inconsistency——不同文件中的信息重复</li>
<li>访问数据困难Difficulty in accessing data ——需要编写一个新程序来执行每个新任务</li>
<li>数据隔离isolation — 多种文件和格式</li>
<li>完整性问题lIntegrity problems<ul>
<li>完整性约束（例如，帐户余额&gt; 0）被“埋没”在程序代码中，而不是明确说明</li>
<li>难以添加新约束或更改现有约束</li>
</ul>
</li>
<li>更新的原子性<strong>Atomicity</strong> of updates<ul>
<li>失败可能会使数据处于不一致状态，并执行了部分更新 </li>
<li>将资金从一个账户转移到另一个账户应该完成或根本不发生</li>
</ul>
</li>
<li>多个用户的并发访问lConcurrent access by multiple users<ul>
<li>需要并发访问以提高性能</li>
<li>不受控制的并发访问可能会导致不一致</li>
<li>两个人同时阅读余额并更新</li>
</ul>
</li>
<li>安全问题 Security<ul>
<li>难以为用户提供对部分（但不是全部）数据的访问权限</li>
</ul>
</li>
</ul>
<h4 id="View-of-Data"><a href="#View-of-Data" class="headerlink" title="View of Data"></a>View of Data</h4><p>数据库系统提供数据的<strong>抽象视图<em>abstract view</em></strong> </p>
<ul>
<li><p>隐藏数据存储和维护方式的某些复杂性详细信息</p>
</li>
<li><p>通过多个抽象级别实现</p>
<ul>
<li>物理级别<strong>Physical level</strong><ul>
<li>描述记录（例如客户）的存储方式</li>
</ul>
</li>
<li>逻辑级别<strong>Logical level</strong><ul>
<li>描述数据库中存储的数据，以及数据之间的关系</li>
<li>描述整个数据库</li>
</ul>
</li>
<li>视图级别<strong>View level</strong><ul>
<li>描述数据库的一部分</li>
<li>一种隐藏方法：（a）数据类型的详细信息和（b）出于安全目的的信息（例如员工的工资）</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110140619684.png"></p>
</li>
</ul>
<h4 id="Instances-and-Schemas实例和模式"><a href="#Instances-and-Schemas实例和模式" class="headerlink" title="Instances and Schemas实例和模式"></a>Instances and Schemas实例和模式</h4><p><strong>模式Schema</strong> – 数据库的整体设计——类似于程序中变量的类型信息 </p>
<p><strong>实例Instance</strong> – 在特定时间点存储在数据库中的信息的集合——类似于变量的值</p>
<p>DBS 的几种模式：</p>
<ul>
<li>物理模式<strong>Physical schema</strong>：物理级别的数据库设计 </li>
<li>逻辑模式<strong>Logical schema</strong>：逻辑级别的数据库设计 </li>
<li>子模式<strong>Sub schemas</strong>：在视图级别描述不同的视图</li>
</ul>
<p>物理数据独立性<strong>Physical Data Independence</strong>  – 应用程序不依赖于物理架构，因此在物理架构更改时无需重写 </p>
<ul>
<li>应用程序依赖于逻辑架构</li>
<li>物理架构隐藏在逻辑架构下</li>
</ul>
<h4 id="Data-Modelss数据模型"><a href="#Data-Modelss数据模型" class="headerlink" title="Data Modelss数据模型"></a>Data Modelss数据模型</h4><p>用于描述的工具集合 </p>
<ul>
<li>数据 Data</li>
<li>数据关系 Data relationships</li>
<li>数据语义 Data semantics</li>
<li>数据约束 Data constraints</li>
</ul>
<p>提供一种在物理、逻辑和视图级别描述数据库设计的方法。</p>
<ul>
<li>Relational model关系模型——使用表的集合来表示数据以及这些数据之间的关系</li>
<li>Entity-Relationship data model实体关系数据模型<ul>
<li>主要用于数据库设计</li>
<li>实体<strong>Entity</strong>：现实世界中可与其他对象区分开来的“事物”或“对象”<ul>
<li>由一组属性<strong>attributes</strong>描述</li>
</ul>
</li>
<li>关系<strong>Relationship</strong>：多个实体之间的关联 </li>
<li>实体集<strong>Entity Set</strong>：相同类型的所有实体的集合 </li>
<li>关系集<strong>Relationship Set</strong>：同一类型的所有关系的集合</li>
</ul>
</li>
<li>Object-based data models 基于对象的数据模型<ul>
<li>Object-oriented面向对象</li>
<li>Object-relational对象关系</li>
</ul>
</li>
<li>Semistructured data model 半结构化数据模型<ul>
<li>XML</li>
</ul>
</li>
<li>Other older models:其他旧模型：<ul>
<li>Network model 网络模型</li>
<li>Hierarchical model分层模型</li>
</ul>
</li>
</ul>
<h4 id="Database-Languages"><a href="#Database-Languages" class="headerlink" title="Database Languages"></a>Database Languages</h4><p>数据库系统提供 </p>
<ul>
<li>用于指定数据库模式的数据定义语言Data Definition Language  （DDL） <ul>
<li>用于定义数据库架构的规范表示法Specification notation </li>
<li>DDL 编译器根据 DDL 语句生成表，并将这些表的架构定义存储在数据字典<strong>data dictionary</strong>中</li>
<li>数据字典包含元数据（即，描述数据的数据） <ul>
<li>数据库架构 Database schema </li>
<li>完整性约束 Integrity constraints</li>
<li>授权Authorization</li>
</ul>
</li>
</ul>
</li>
<li>用于表达数据库查询和更新的数据操作语言 Data Manipulation Language （DML） <ul>
<li>用于访问和操作由相应数据模型组织的数据的语言（DML 也称为查询语言<strong>query language</strong>）<ul>
<li>检索信息 <strong>Retrieval</strong>（查询query）</li>
<li>插入新信息 <strong>Insertion</strong></li>
<li>删除信息 <strong>Deletion</strong></li>
<li>信息修改<strong>Modification</strong></li>
</ul>
</li>
<li>两类语言<ul>
<li>过程性<strong>Procedural</strong> – 用户指定需要哪些数据以及如何获取这些数据 </li>
<li>声明性<strong>Declarative (nonprocedural非过程)</strong>  – 用户指定需要哪些数据，而不指定如何获取这些数据<ul>
<li>SQL是最广泛使用的非程序查询语言</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在实践中，DDL 和 DML 构成了单一数据库语言的一部分 ——SQL（Structured Query Language结构化查询语言）</p>
<p>应用程序通常通过以下任一方式访问access数据库： </p>
<ul>
<li>允许嵌入式embedded SQL 的语言扩展 （SQL与高级语言结合使用时，这个高级语言叫做数组语言，以特殊字符开始SQL，通过预处理器将SQL语句转成数组语言的过程调用）</li>
<li>应用程序接口（例如，ODBC(<strong>Open</strong> <strong>Database</strong> <strong>Connectivity</strong>)/JDBC(<strong>JAVA Database Connectivity</strong>)），允许将 SQL 查询发送到数据库</li>
</ul>
<h4 id="Relational-Databases"><a href="#Relational-Databases" class="headerlink" title="Relational Databases"></a>Relational Databases</h4><p>关系数据库基于关系数据模型 <em>relational data model</em></p>
<p>数据和数据之间的关系由表的集合<em>collection of tables</em> 表示 </p>
<p>包括一个 DML 和一个 DDL </p>
<h4 id="Database-Design"><a href="#Database-Design" class="headerlink" title="Database Design"></a>Database Design</h4><p>设计数据库的一般结构的过程： </p>
<ul>
<li>逻辑设计——确定数据库模式。数据库设计要求我们找到一个“好”的关系模式集合。<ul>
<li>业务决策 – 我们应该在数据库中记录哪些属性？ </li>
<li>计算机科学决策 - 我们应该拥有什么关系模式，属性应该如何在各种关系模式之间分配？</li>
</ul>
</li>
<li>物理设计—— 确定数据库的物理布局</li>
</ul>
<h4 id="Database-Users-and-Administrators"><a href="#Database-Users-and-Administrators" class="headerlink" title="Database Users and Administrators"></a>Database Users and Administrators</h4><p>数据库用户通过用户希望与系统交互的方式来区分</p>
<ul>
<li>应用程序程序员 <strong>Application programmers</strong> – 通过 DML 调用与系统交互 </li>
<li>熟练用户<strong>Sophisticated users</strong>  – 使用数据库查询语言处理表单请求</li>
<li>专门用户<strong>Specialized users</strong>  – 编写不适合传统数据处理框架的专用数据库应用程序</li>
<li>无经验用户<strong>Naive users</strong>  – 调用以前编写的永久应用程序之一，例如，通过 Web 访问数据库的人员、银行出纳员、文职人员</li>
</ul>
<h4 id="Database-Administrator数据库管理员DBA"><a href="#Database-Administrator数据库管理员DBA" class="headerlink" title="Database Administrator数据库管理员DBA"></a>Database Administrator数据库管理员DBA</h4><p>数据库管理员的职责包括：</p>
<ul>
<li>模式定义Schema definition</li>
<li>存储结构和访问方法定义 </li>
<li>授予Granting用户访问数据库的权限 </li>
<li>指定Specifying完整性约束 </li>
<li>充当与用户的联络人 liaison</li>
<li>监控性能并响应需求变化</li>
</ul>
<h4 id="Data-Storage-and-Querying"><a href="#Data-Storage-and-Querying" class="headerlink" title="Data Storage and Querying"></a>Data Storage and Querying</h4><p>DBMS的功能：</p>
<ul>
<li><p><strong>Storage Management</strong>存储管理</p>
<ul>
<li>数据库数据通常使用文件系统存储在二级内存（硬盘）上</li>
<li>存储管理器Storage Manager是一个程序模块（软件）<ul>
<li>存储管理器负责<ul>
<li>与文件系统交互</li>
<li>高效存储、检索和更新数据</li>
</ul>
</li>
<li>存储管理器包括以下组件<ul>
<li>授权和完整性管理器 Authorization and integrity manager<ul>
<li>测试完整性约束的满足情况，并检查用户访问数据的权限</li>
</ul>
</li>
<li>事务管理器 Transaction manager<ul>
<li>确保数据库在系统出现故障时仍保持一致状态</li>
<li>确保并发事务执行继续进行而不会发生冲突</li>
</ul>
</li>
<li>文件管理器 File manager<ul>
<li>在磁盘存储上分配空间</li>
<li>管理用于表示存储在磁盘上的信息的数据结构（付出一定管理代价）</li>
</ul>
</li>
<li>缓冲区管理器 Buffer manager<ul>
<li>将数据从磁盘存储提取到主存</li>
<li>决定要在主存中缓存哪些数据</li>
</ul>
</li>
</ul>
</li>
<li>存储管理器实现以下数据结构<ul>
<li><strong>Data File</strong>数据文件：存储数据库本身</li>
<li><strong>Data Dictionary</strong>数据字典：存储有关数据库结构的元数据，特别是数据库的架构</li>
<li><strong>Indices</strong>索引：提供对具有特定价值的数据项的快速访问</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Query Processing</strong>查询处理</p>
<ul>
<li><p>DBS的主要目的之一是简化和便利对数据的访问</p>
</li>
<li><p>DBS通过以下方式实现这一目标： 数据抽象 非过程语言 </p>
</li>
<li><p>查询处理器<strong>Query Processor</strong> 在逻辑级别将用非过程语言编写的更新和查询转换为物理级别的高效操作序列</p>
</li>
<li><p>查询处理器组件包括</p>
<ul>
<li>DDL Interpreter解释器 <ul>
<li>解释数据字典中的 DDL 语句和记录定义</li>
</ul>
</li>
<li>DML Compiler编译器 <ul>
<li>将 DML 语句转换为包含低级指令的评估计划</li>
</ul>
</li>
<li>Query Evaluation Engine查询评估引擎<ul>
<li>执行 DML 编译器生成的低级指令</li>
</ul>
</li>
</ul>
</li>
<li><p>查询处理步骤</p>
<ol>
<li><p>Parsing and translation.解析和翻译</p>
</li>
<li><p>Optimization优化</p>
</li>
<li><p>Evaluation评估</p>
<p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110140645404.png"></p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="Transaction-Management事务管理"><a href="#Transaction-Management事务管理" class="headerlink" title="Transaction Management事务管理"></a>Transaction Management事务管理</h4><ul>
<li>事务是在数据库应用程序中执行单个逻辑函数的操作的集合</li>
<li>事务管理组件确保数据库在发生系统故障（例如，电源故障和操作系统崩溃）和事务故障时仍保持<strong>一致consistent (correct) state</strong> 。 </li>
<li>并发控制管理器<strong>Concurrency-control manager</strong> 控制并发事务之间的交互，保证数据库的一致性</li>
</ul>
<p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110150619759.png"></p>
<h4 id="Database-Architecture"><a href="#Database-Architecture" class="headerlink" title="Database Architecture"></a>Database Architecture</h4><p>数据库系统的体系结构受运行数据库的基础计算机系统的极大影响 </p>
<ul>
<li>Centralized集中式</li>
<li>Client-server客户端-服务器 </li>
<li>Parallel (multi-processor)并行（多处理器） </li>
<li>Distributed分布式</li>
</ul>
<h2 id="第二章relational-model关系模型"><a href="#第二章relational-model关系模型" class="headerlink" title="第二章relational model关系模型"></a>第二章relational model关系模型</h2><h3 id="2-1Structure-of-Relational-Databases"><a href="#2-1Structure-of-Relational-Databases" class="headerlink" title="2.1Structure of Relational Databases"></a>2.1Structure of Relational Databases</h3><h4 id="Basic-Structure"><a href="#Basic-Structure" class="headerlink" title="Basic Structure"></a>Basic Structure</h4><p>在逻辑层面上，关系数据库是称为关系的二维表的集合</p>
<p><strong>关系</strong>表示实体集或关系集</p>
<p>关系的一行 表示实体 或关系</p>
<p>关系的每一行都可以称为<strong>元组tuple</strong></p>
<p>关系的每列都有一个名称-&gt;关系的命名列称为<strong>属性attributes</strong> 每个属性的允许值集称为属性的<strong>域domain</strong></p>
<p>属性值（通常）必须是<strong>原子的atomic</strong>,不可分割的</p>
<p>特殊值 <strong>null</strong> 是每个域的成员</p>
<p><strong>Relation</strong>：形式上，给定集合 D1， D2， ….Dn关系 r 是 D1 x D2 x …x Dn因此，关系是一组 n 元组 （a1， a2， …， an），其中每个ai∈Di</p>
<p><strong>Tuple Variable</strong>元组变量：元组变量是代表元组的变量，其域是特定关系的所有元组的集合</p>
<p><strong>Relation Schema</strong>关系架构：A1、 A2、 …、 An 是属性名称，R = （A1， A2， …， An ） 是一个关系架构，r(R)表示（denotes ）关系架构 R 上的关系，关系的当前值（关系实例）由表指定。</p>
<p>关系是无序的</p>
<p>一个数据库由多个关系组成，将所有信息存储为单个关系</p>
<p>关系对应表，元组对应行，属性对应列，关系是元组的集合，表是行的集合</p>
<h4 id="keys码-x2F-键"><a href="#keys码-x2F-键" class="headerlink" title="keys码/键"></a>keys码/键</h4><p><strong>超码 superkey</strong> ：<br>形式：一个或多个属性的集合<br>作用：在一个关系中唯一地标识一个元组。<br>特点：</p>
<ul>
<li>可能包含无关属性</li>
<li>超码的任意超集也是超码。（通俗讲，就是同一个关系r上，如果某个属性集合S包含超码K，即K是S的子集，那么S也是 r 的超码）</li>
<li>一张表（一个关系）一定有超码，因为至少所有属性的组合一定是超码，能唯一确定一个元组<br>不唯一</li>
</ul>
<p><strong>候选码candidate key</strong>:<br>形式：一个或多个属性的集合<br>作用：在一个关系中唯一地标识一个元组。<br>特点：</p>
<ul>
<li><u>是超码的一个子集</u></li>
<li>任意真子集都不可能是超码，候选码就是最小的超码</li>
<li>没有无关属性</li>
<li>不唯一</li>
</ul>
<p><strong>主码primary key</strong>：<br>形式：一个或多个属性的集合<br>作用：在一个关系中唯一地标识一个元组。<br>特点：</p>
<ul>
<li><u>是候选码之一</u></li>
<li>唯一或没有</li>
<li>由数据库设计者指定，不指定的话表就没有主码</li>
</ul>
<p><strong>外码 foreign key</strong> :</p>
<ul>
<li><p>什么时候有外码？<br>关系 r1 的属性中包含关系 r2的主码 ，设这个属性为 k</p>
</li>
<li><p>哪个是外码<br>k 就是 r1 的外码</p>
</li>
<li><p>r1 、 r2 与外码的关系？<br>r1 是 k 依赖的参照关系（referencing relation)<br>r2 是 k 的被参照关系（referenced relation)</p>
</li>
</ul>
<p><strong>参照完整性约束referential integrity constraint</strong> :在参照关系中，任意元组在特定关系上的取值必然等于被参照关系中某个元素在特性关系上的取值</p>
<p>r1 在 k 属性上的取值是r2 在 k 属性（属性名称可能不一样）上取值的子集<br>如果把 r1 中某个元组的 k 属性的取值看做一个变量x，r2中k属性的取值的集合设为s,<br>那么s 就是变量 x 的值域。</p>
<h4 id="查询语言"><a href="#查询语言" class="headerlink" title="查询语言"></a>查询语言</h4><p>用户从数据库请求信息时使用的语言。 </p>
<p>语言类别：过程性（procedural）、非程序性或声明性（Non-procedural, or declarative）</p>
<p>“Pure” languages（形成人们使用的查询语言的基础）： </p>
<ul>
<li><p>关系代数（Procedural） </p>
</li>
<li><p>元组关系演算（Nonprocedural）</p>
</li>
<li><p>域关系演算（Nonprocedural）</p>
</li>
</ul>
<h3 id="2-2Fundamental-Relational-Algebra-Operations基本关系代数运算"><a href="#2-2Fundamental-Relational-Algebra-Operations基本关系代数运算" class="headerlink" title="2.2Fundamental Relational-Algebra-Operations基本关系代数运算"></a>2.2Fundamental Relational-Algebra-Operations基本关系代数运算</h3><p>（对行的操作）基本操作</p>
<p>由一组运算符组成，将一个或两个关系作为输入，并生成一个新关系作为结果</p>
<h4 id="选择select-δ选择一行"><a href="#选择select-δ选择一行" class="headerlink" title="选择select: δ选择一行"></a>选择select: δ选择一行</h4><blockquote>
<p> δ<sub>p</sub>(<strong>r</strong>) = {<em>t</em> | <em>t</em> ∈<em>r</em> <strong>and</strong> <em>p(t)</em>}</p>
<p> δ<sub> Sage&lt; 20</sub>  (Student)  or   δ <sub>4 &lt; 20</sub> (Student)</p>
</blockquote>
<h4 id="投影project-π"><a href="#投影project-π" class="headerlink" title="投影project: π"></a>投影project: π</h4><blockquote>
<p>π<sub>Sname,Sdept</sub>(Student) or δ <sub>2,5</sub>(Student)   结果是去掉重复行的</p>
</blockquote>
<h4 id="并union-∪"><a href="#并union-∪" class="headerlink" title="并union: ∪"></a>并union: ∪</h4><blockquote>
<p>属性必须有相同的**<u>元（arity）</u>**</p>
<p>域必须是**<u>相容的(compatible)</u>**</p>
<p><em>r</em> ∪ <em>s</em> = {<em>t</em> | <em>t</em> ∈<em>r</em> or <em>t</em> 属于 <em>s</em>}  </p>
<p>∪<sub>Sname,Sdept</sub>(Student) or ∪<sub> 2,5</sub>(Student)</p>
</blockquote>
<h4 id="差set-difference-–"><a href="#差set-difference-–" class="headerlink" title="差set difference: –"></a>差set difference: <em>–</em></h4><blockquote>
<p>属性必须有相同的**<u>元（arity）</u>**</p>
<p>域必须是**<u>相容的(compatible)</u>**</p>
<p><em>r</em> <em>–</em> <em>s</em> = {<em>t</em> | <em>t</em> ∈<em>r</em> and t ∉ <em>s</em> }</p>
</blockquote>
<h4 id="笛卡尔积cartesian-product-x"><a href="#笛卡尔积cartesian-product-x" class="headerlink" title="笛卡尔积cartesian product: x"></a>笛卡尔积cartesian product: x</h4><blockquote>
<p><em>r</em> x <em>s</em> = {<em>t q</em> | <em>t</em> ∈ <em>r</em> and <em>q</em>  ∉ <em>s</em>} 当属性不相容时，必须重命名，否则为Ø</p>
</blockquote>
<h4 id="重命名rename-ρ"><a href="#重命名rename-ρ" class="headerlink" title="重命名rename: ρ"></a>重命名rename: ρ</h4><blockquote>
<p>ρ<sub>X</sub>(E) E这个关系名字重命名为X</p>
</blockquote>
<h3 id="2-3Additional-Relational-Algebra-Operations额外的"><a href="#2-3Additional-Relational-Algebra-Operations额外的" class="headerlink" title="2.3Additional Relational-Algebra-Operations额外的~"></a>2.3Additional Relational-Algebra-Operations额外的~</h3><h4 id="交Set-intersection：∩"><a href="#交Set-intersection：∩" class="headerlink" title="交Set intersection：∩"></a>交Set intersection：∩</h4><blockquote>
<p>属性必须有相同的**<u>元（arity）</u>**</p>
<p>域必须是**<u>相容的(compatible)</u>**</p>
<p>r∩s=r−(r−s)</p>
</blockquote>
<h4 id="自然连接Natural-join-：⋈"><a href="#自然连接Natural-join-：⋈" class="headerlink" title="自然连接Natural join ：⋈"></a>自然连接Natural join ：⋈</h4><blockquote>
<p>r⋈s<br>相当于在笛卡儿积运算之后去除了重复的属性值</p>
</blockquote>
<h4 id="除Division-：÷"><a href="#除Division-：÷" class="headerlink" title="除Division ：÷"></a>除Division ：÷</h4><blockquote>
<p><em>r</em> ÷<em>s</em> = { <em>t</em> | <em>t</em>∈π<sub> R-S</sub> (<em>r</em>)  Λ ∀u ∈ <em>s</em> ( <em>tu</em> ∈ <em>r</em> ) } （其中 tu 表示元组 t 和 U 的串联，以生成单个元组）</p>
<p>1.找到s的与r重合的列Y，并取出来记为s<sub>y</sub></p>
<p>2.找到r中不是Y的列X作取消重复值得到X’</p>
<p>3.求r中X’属性对应的像集Z(X‘中有几个元素就有几个表)（每一个值都拿出来列一个表）</p>
<p>4.挨个判断Z中的像集是否都包含s<sub>y</sub>，如果包含则保留，如果不包含则从X’删除，最后的X’为所求</p>
</blockquote>
<h4 id="赋值Assignment-：←"><a href="#赋值Assignment-：←" class="headerlink" title="赋值Assignment ：←"></a>赋值Assignment ：←</h4><blockquote>
<p>赋值运算符←←提供了一个用来表达复杂查询的简单方法，使用了一个临时的变量来表达</p>
<p>temp1 ← R × S  ，  temp2 ← δr.A1=s.A1 ∧ r.A2=s.A2 ∧ … ∧ r. An=s. An(temp1)</p>
</blockquote>
<h3 id="2-4Extended-Relational-Algebra-Operations扩展的"><a href="#2-4Extended-Relational-Algebra-Operations扩展的" class="headerlink" title="2.4Extended Relational-Algebra-Operations扩展的~"></a>2.4Extended Relational-Algebra-Operations扩展的~</h3><h4 id="广义投影Generalized-Projection"><a href="#广义投影Generalized-Projection" class="headerlink" title="广义投影Generalized Projection"></a>广义投影Generalized Projection</h4><blockquote>
<p>E是任意的关系代数表达式，其中F1,F2…Fn每一个都是涉及常量以及E中属性计算的算术表达式，例如：Π<sub>ID,name,deptname,salary/12</sub>(Instructor)</p>
</blockquote>
<h4 id="聚集函数Aggregate-Functions"><a href="#聚集函数Aggregate-Functions" class="headerlink" title="聚集函数Aggregate Functions"></a>聚集函数Aggregate Functions</h4><blockquote>
<p>聚集运算可以对值的集合使用<strong>聚集函数</strong>，<strong>聚集函数</strong>输入值的一个汇聚，将单一的值最为返回</p>
<h4 id="gsum-c-as-sum-balance-r-，-得到结果为一个关系，需要选择出来或者投影出来用，as后可将这一列重命名"><a href="#gsum-c-as-sum-balance-r-，-得到结果为一个关系，需要选择出来或者投影出来用，as后可将这一列重命名" class="headerlink" title="gsum(c) as sum-balance(r)， 得到结果为一个关系，需要选择出来或者投影出来用，as后可将这一列重命名"></a>g<sub>sum(c) as sum-balance</sub>(r)， 得到结果为一个关系，需要选择出来或者投影出来用，as后可将这一列重命名</h4><p><strong>avg</strong>: average value<br><strong>min</strong>: minimum value<br><strong>max</strong>: maximum value<br><strong>sum</strong>: sum of values<br><strong>count</strong>: number of values</p>
</blockquote>
<h4 id="外连接Outer-Join"><a href="#外连接Outer-Join" class="headerlink" title="外连接Outer Join"></a>外连接Outer Join</h4><blockquote>
<p>外连接为自然连接的扩展，为了<strong>避免信息的丢失avoids loss of information</strong>，会在结果中创建带空值null的元组</p>
<h4 id="右外连接-Right-outer-join-⟖"><a href="#右外连接-Right-outer-join-⟖" class="headerlink" title="右外连接 Right outer join (⟖)"></a>右外连接 Right outer join (⟖)</h4><p>R⟖S<br>右外连接结果中包含S中的所有元素，对每个元组，若R在公共属性名字上相等的元组，则正常连接，若R没有在功能属性名字上相等的元组，则保留此组，并将其他列设置为<strong>NULL</strong></p>
<h4 id="左外连接-Left-outer-join-⟕"><a href="#左外连接-Left-outer-join-⟕" class="headerlink" title="左外连接 Left outer join (⟕)"></a>左外连接 Left outer join (⟕)</h4><p>R⟕S<br>同右外连接，结果包含R中的所有元组</p>
<h4 id="全外连接-Full-outer-join-⟗"><a href="#全外连接-Full-outer-join-⟗" class="headerlink" title="全外连接 Full outer join (⟗)"></a>全外连接 Full outer join (⟗)</h4><p>R⟗S<br>同右外连接，结果包含R和S中所有的元组</p>
</blockquote>
<h3 id="2-5Null-Values空值"><a href="#2-5Null-Values空值" class="headerlink" title="2.5Null Values空值"></a>2.5Null Values空值</h3><ul>
<li><em>null</em>表示未知<em>unknown</em>的值或不存在<em>does not exist</em>的值</li>
<li>任何涉及<em>null</em>的<strong>算术表达式</strong>的结果都是<em>null</em></li>
<li>聚集函数<em>aggregate function</em>忽略null值（在SQL中）</li>
<li>对于重复删除<em>duplicate eliminate</em>和分组<em>grouping</em>，null被当作其他的任意值，两个null值被当作是一样的</li>
<li>与 <em>null</em> 值的<strong>比较</strong>返回特殊的真值：<em><strong>unknown</strong></em></li>
<li>如果选择谓词<em>select predicate</em>的结果计算结果为未知，则将其视为 <em><strong>false</strong></em></li>
<li>使用未知真值(unknown)的三值逻辑：<ul>
<li>OR: (unknown <strong>or</strong> true)     = true,<br>(unknown <strong>or</strong> false)    = unknown<br>(unknown <strong>or</strong> unknown) = unknown</li>
<li>AND:  (true <strong>and</strong> unknown)    = unknown,<br>(false <strong>and</strong> unknown)    = false,<br>  (unknown <strong>and</strong> unknown) = unknown</li>
<li>NOT: (<strong>not</strong> unknown) = unknown</li>
</ul>
</li>
<li>在 SQL 中，如果谓词 P 的计算结果为未知，则”P is unknown”的计算结果为 true</li>
</ul>
<h3 id="2-6Modification-of-the-Database修改数据库"><a href="#2-6Modification-of-the-Database修改数据库" class="headerlink" title="2.6Modification of the Database修改数据库"></a>2.6Modification of the Database修改数据库</h3><p>删除 插入 更新 所有这些操作都使用赋值运算符表示</p>
<h4 id="删除-Deletion"><a href="#删除-Deletion" class="headerlink" title="删除 Deletion"></a>删除 Deletion</h4><p>删除请求的表示方式与查询类似，只是不是向用户显示元组，而是从数据库中删除选定的元组。 只能删除整个元组;无法仅删除特定属性上的值 删除在关系代数中表示为：r ← r - E (r为关系，E为关系代数查询)</p>
<blockquote>
<p>eg. <em>account</em> ← <em>account</em> – δ<sub> <em>branch_name</em> <em>= “Perryridge”</em></sub> (<em>account</em> )</p>
</blockquote>
<h4 id="插入-Insertion"><a href="#插入-Insertion" class="headerlink" title="插入 Insertion"></a>插入 Insertion</h4><p>要将数据插入关系中，我们要么： 指定要插入的元组 编写一个查询，其结果是要插入的一组元组。在关系代数中，插入表示为：r ← r ∪ E (r为关系，E为关系代数查询)</p>
<blockquote>
<p><em>account</em> ← <em>account</em> ∪ {(“A-973”, “ Perryridge ”, 1200)}</p>
</blockquote>
<h4 id="更新-Updating"><a href="#更新-Updating" class="headerlink" title="更新 Updating"></a>更新 Updating</h4><p>一种机制，用于更改元组中的值，使用广义投影运算符执行， r ← π <sub>F<sub>1</sub>,F<sub>2</sub>,…F<sub>l</sub></sub>(r)每个 F<sub>i</sub> 要么是 r 的第i个属性（如果未更新第 i 个属性），或者， 如果要更新属性，F<sub>i</sub> 是一个表达式，仅涉及常量和 r 的属性，这为属性提供了新值。</p>
<blockquote>
<p><em>account</em> ← π <sub><em>account_number</em>, <em>branch_name</em>, <em>balance</em> * 1.05</sub> (<em>account</em>)</p>
</blockquote>
<h2 id="第三章SQL"><a href="#第三章SQL" class="headerlink" title="第三章SQL"></a>第三章SQL</h2><h3 id="3-1Data-Definition数据定义"><a href="#3-1Data-Definition数据定义" class="headerlink" title="3.1Data Definition数据定义"></a>3.1Data Definition数据定义</h3><h4 id="Data-Definition-Language（数据定义语言）"><a href="#Data-Definition-Language（数据定义语言）" class="headerlink" title="Data Definition Language（数据定义语言）"></a>Data Definition Language（数据定义语言）</h4><p>允许指定有关每个关系的信息，包括： </p>
<ul>
<li><p>每个关系的架构schema。 </p>
</li>
<li><p>与每个属性关联的值的域domain。 </p>
</li>
<li><p>完整性约束–Integrity constraints </p>
</li>
<li><p>要为每个关系维护maintained的索引集The set of indices 。 </p>
</li>
<li><p>每个关系的安全和授权信息Security and authorization information。 </p>
</li>
<li><p>磁盘disk上每个关系的物理存储结构。</p>
</li>
</ul>
<h4 id="SQL-中的域类型（基本类型定义）"><a href="#SQL-中的域类型（基本类型定义）" class="headerlink" title="SQL 中的域类型（基本类型定义）"></a>SQL 中的域类型（基本类型定义）</h4><p>**char(n).**固定长度字符串，用户指定的长度为 n</p>
<blockquote>
<p>像数组，查找方便</p>
</blockquote>
<p><strong>varchar(n).</strong> 可变长度字符串，具有用户指定的最大长度 n。</p>
<blockquote>
<p>像链表，节省空间</p>
</blockquote>
<p><strong>int.</strong> 整数（取决于机器相关的整数的有限子集）。</p>
<p><strong>smallint</strong>.小整数（整数域类型的与计算机相关的子集）。</p>
<p>**numeric(p,d).**定点数，具有用户指定的 p 位精度（总长度），小数点右侧有 d 位。</p>
<p><strong>real, double precision.</strong>  浮点和双精度浮点数，具有与机器相关的精度。</p>
<p>**float(n).**浮点数，用户指定的精度至少为 n 位。 </p>
<h4 id="Create-Table-Construct创建表构造"><a href="#Create-Table-Construct创建表构造" class="headerlink" title="Create Table Construct创建表构造"></a>Create Table Construct创建表构造</h4><p>SQL 关系是使用**<u>create table</u>**命令定义的：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> r <span class="token punctuation">(</span>A1 D1<span class="token punctuation">,</span> A2 D2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> An Dn<span class="token punctuation">,</span>
                <span class="token punctuation">(</span>integrity<span class="token operator">-</span>constraint1<span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>
                <span class="token punctuation">(</span>integrity<span class="token operator">-</span>constraintk<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">/* r 是关系的名称 
每个 Ai 都是关系 r 架构中的一个属性名称 
Di 是属性 Ai 域中值的数据类型*/</span>
<span class="token keyword">create</span> <span class="token keyword">table</span> branch <span class="token comment"># eg.</span>
	<span class="token punctuation">(</span>branch_name <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>
     branch_city <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     assets		 <span class="token keyword">integer</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Drop-Table-Constructs删除表构造"><a href="#Drop-Table-Constructs删除表构造" class="headerlink" title="Drop Table Constructs删除表构造"></a>Drop Table Constructs删除表构造</h4><p><strong>drop table</strong> r 命令从数据库中删除有关丢弃关系的所有信息。不仅删除 r 的所有元组，还删除 r 的架构</p>
<p><strong>delete table</strong> r 保留关系 r，但删除 r 中的所有元组。</p>
<h4 id="Alter-Table-Constructs加属性"><a href="#Alter-Table-Constructs加属性" class="headerlink" title="Alter Table Constructs加属性"></a>Alter Table Constructs加属性</h4><blockquote>
<p> <strong>alter table</strong> <em>r</em> <strong>add</strong> <em>A D</em>   // 加属性</p>
<p> // 其中 A 是要添加到关系 r 的属性的名称，D 是 A 的域。</p>
<p> // 关系中的所有元组都被指定为 null 作为新属性的值</p>
<p> <del><strong>alter table</strong> <em>r</em> <strong>drop</strong> <em>A</em>      //删除属性(实际为把所有的列复制到新的表中)</del></p>
<p> // 其中 A 是关系 r 的属性的名称，<strong>大多数数据库都不支持删除</strong></p>
</blockquote>
<h3 id="3-2Basic-Query-Structure基本查询结构"><a href="#3-2Basic-Query-Structure基本查询结构" class="headerlink" title="3.2Basic Query Structure基本查询结构"></a>3.2Basic Query Structure基本查询结构</h3><p>SQL基于关系代数（relational algebra ）和关系演算（relational calculus）</p>
<p>典型的 SQL 查询的格式为：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token keyword">distinct</span> A1<span class="token punctuation">,</span> A2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> An <span class="token comment"># 属性</span>
<span class="token keyword">from</span> r1<span class="token punctuation">,</span> r2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> rm <span class="token comment"># 关系</span>
<span class="token keyword">where</span> P <span class="token comment"># 谓语</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p> 等价于关系代数表达式 </p>
<p> <em><strong>π<sub>A1,A2,…An</sub>(δ<sub>P</sub>(r1×r2×…×r<sub>m</sub>))</strong></em></p>
<p> SQL 查询的<strong>结果是关系</strong></p>
</blockquote>
<h4 id="select子句（Clause）"><a href="#select子句（Clause）" class="headerlink" title="select子句（Clause）"></a>select子句（Clause）</h4><p>select子句（Clause）列出了查询结果中所需的属性，对应于关系代数的投影运算π</p>
<p>SQL <strong>名称不区分大小写</strong>， SQL 允许在关系和查询结果中使用重复项</p>
<p>要强制消除重复项，请在选择后插入<strong>distinct</strong> 关键字。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># distinct关键字-》消除重复项（去掉重复行）</span>
<span class="token keyword">select</span> <span class="token keyword">distinct</span> branch_name
<span class="token keyword">from</span> loan

<span class="token comment"># all关键字-》指定不删除重复项，默认查询结果为all</span>
<span class="token keyword">select</span> <span class="token keyword">all</span> branch_name
<span class="token keyword">from</span> loan

<span class="token comment"># *号表示“所有属性”</span>
<span class="token keyword">select</span> <span class="token operator">*</span>
<span class="token keyword">from</span> loan

<span class="token comment"># select子句可以包含设计运算: +, –, *, /,不改变原关系</span>
<span class="token keyword">select</span> loan_number<span class="token punctuation">,</span> branch_name<span class="token punctuation">,</span> amount<span class="token operator">*</span><span class="token number">100</span>
<span class="token keyword">from</span> loan
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="where子句（Clause）"><a href="#where子句（Clause）" class="headerlink" title="where子句（Clause）"></a>where子句（Clause）</h4><p>where 子句指定结果必须满足的条件，对应于关系代数的选择谓词</p>
<p>SQL 在where子句中使用逻辑连接词（logical connectives ）<strong>and, or, not</strong> </p>
<p>逻辑连接词的操作数可以是涉及比较运算&lt;、&gt;、&lt;=、&gt;=、==、&lt;&gt;(不等于)</p>
<p>比较可以应用于算术表达式（arithmetic expressions），字符串，特殊类型（如日期类型）的结果</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 基本使用</span>
<span class="token keyword">select</span> loan_number
<span class="token keyword">from</span> loan
<span class="token keyword">where</span> branch_name <span class="token operator">=</span> <span class="token string">'Perryridge'</span> <span class="token operator">and</span> amount <span class="token operator">&gt;</span> <span class="token number">1200</span>

<span class="token comment"># between and 使用</span>
<span class="token keyword">select</span> loan_number
<span class="token keyword">from</span> loan
<span class="token keyword">where</span> amount <span class="token operator">between</span> <span class="token number">90000</span> <span class="token operator">and</span> <span class="token number">100000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="from子句（Clause）"><a href="#from子句（Clause）" class="headerlink" title="from子句（Clause）"></a>from子句（Clause）</h4><p>from 子句列出了查询中涉及的关系 对应于关系代数的笛卡尔积运算“×”。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 基本使用</span>
<span class="token keyword">select</span> <span class="token operator">*</span>
<span class="token keyword">from</span> borrower<span class="token punctuation">,</span> loan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="as关键字"><a href="#as关键字" class="headerlink" title="as关键字"></a>as关键字</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># as子句-》对select子句中的属性重命名</span>
<span class="token keyword">select</span> customer_name<span class="token punctuation">,</span>borrower<span class="token punctuation">.</span>loan_number <span class="token keyword">as</span> loan_id<span class="token punctuation">,</span> amount
<span class="token keyword">from</span> borrower<span class="token punctuation">,</span> loan
<span class="token keyword">where</span> borrower<span class="token punctuation">.</span>loan_number <span class="token operator">=</span> loan<span class="token punctuation">.</span>loan_number

<span class="token comment"># Tuple Variables_元组变量通过使用 as 子句在 from 子句中定义。（给表取了一个新名字使用），此处关键字 as 可以省略</span>
<span class="token keyword">select</span> customer_name<span class="token punctuation">,</span> T<span class="token punctuation">.</span>loan_number<span class="token punctuation">,</span> S<span class="token punctuation">.</span>amount
<span class="token keyword">from</span> borrower <span class="token keyword">as</span> T<span class="token punctuation">,</span> loan <span class="token keyword">as</span> S
<span class="token keyword">where</span> T<span class="token punctuation">.</span>loan_number <span class="token operator">=</span> S<span class="token punctuation">.</span>loan_number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 运算符"like"使用使用两个特殊字符描述的模式：</span>
<span class="token comment"># % 字符匹配具有任意长度（可以是 0）的任何子字符串。</span>
<span class="token comment"># _ 字符匹配任何字符。</span>
<span class="token comment"># escape 定义转义字符，在表达式中含有%、_、[、]时使用</span>
<span class="token keyword">select</span> customer_name
<span class="token keyword">from</span> customer
<span class="token keyword">where</span> customer_street <span class="token operator">like</span> <span class="token string">'% Main%'</span><span class="token punctuation">;</span>
<span class="token comment">/*
    '张%';	# 匹配"张"姓同学
    '%平';	# 匹配以“平”结尾的同学
    '%\__' escape '\'; 	# 匹配倒数第2个字是“_”的字符串
    '%平%';	# 匹配含有"平"的字符串
*/</span>

<span class="token comment"># 模糊语句——扩展（来源网上）</span>
<span class="token keyword">SELECT</span> 字段 <span class="token keyword">FROM</span> 表 <span class="token keyword">WHERE</span> 某字段 <span class="token operator">LIKE</span> 条件<span class="token punctuation">;</span>
<span class="token comment"># []：表示括号内所列字符中的一个（类似正则表达式）</span>
<span class="token comment"># [^]：表示不在括号所列之内的单个字符。</span>
<span class="token keyword">select</span> <span class="token operator">*</span> 
<span class="token keyword">from</span> flow_user 
<span class="token keyword">where</span> username <span class="token operator">like</span> <span class="token string">'老[0-9]'</span><span class="token punctuation">;</span>

<span class="token keyword">select</span> <span class="token operator">*</span> 
<span class="token keyword">from</span> flow_user 
<span class="token keyword">where</span> regexp_like <span class="token punctuation">(</span>username<span class="token punctuation">,</span> <span class="token string">'[张王李]飞'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">#Oracle 10g以上的版本用法</span>

<span class="token keyword">select</span> <span class="token operator">*</span> 
<span class="token keyword">from</span> flow_user 
<span class="token keyword">where</span> username <span class="token operator">LIKE</span><span class="token string">'[^王李张]飞'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Order-by-对元组的显示进行排序"><a href="#Order-by-对元组的显示进行排序" class="headerlink" title="Order by 对元组的显示进行排序"></a>Order by 对元组的显示进行排序</h4><p>order by 子句会导致查询结果中的元组按排序顺序显示，默认为升序，可以对多个属性进行排序</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 普通默认升序排列或加asc</span>
<span class="token keyword">select</span> <span class="token keyword">distinct</span> customer_name
<span class="token keyword">from</span> borrower<span class="token punctuation">,</span> loan
<span class="token keyword">where</span> borrower<span class="token punctuation">.</span>loan_number <span class="token operator">=</span> loan<span class="token punctuation">.</span>loan_number <span class="token operator">and</span> 
	branch_name <span class="token operator">=</span> <span class="token string">'Perryridge'</span> 
	<span class="token keyword">order</span> <span class="token keyword">by</span> customer_name

<span class="token comment"># 降序排序 desc关键字降序 asc关键字升序</span>
<span class="token keyword">select</span> <span class="token operator">*</span>
<span class="token keyword">from</span> loan
<span class="token keyword">order</span> <span class="token keyword">by</span> amount <span class="token keyword">desc</span><span class="token punctuation">,</span> loan_number <span class="token keyword">asc</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-3Set-Operations集合操作"><a href="#3-3Set-Operations集合操作" class="headerlink" title="3.3Set Operations集合操作"></a>3.3Set Operations集合操作</h3><p>以下三个操作都会自动消除重复项，想要显示重复项就需要在后面加关键字 all</p>
<p>一般为用来对两个select语句得到的结果进行操作的</p>
<p><strong>union</strong>对应(关系代数表达式里的)∪</p>
<p><strong>intersect</strong>对应∩</p>
<p><strong>except</strong>对应-</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> dept
<span class="token keyword">UNION</span>
<span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span> dept <span class="token keyword">WHERE</span> deptno <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> dept
<span class="token keyword">INTERSECT</span>
<span class="token keyword">SELECT</span><span class="token operator">*</span> <span class="token keyword">FROM</span> dept <span class="token keyword">WHERE</span> deptno <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> dept
<span class="token keyword">UNION</span> <span class="token keyword">ALL</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> dept <span class="token keyword">WHERE</span> deptno <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4Aggregate-Functions聚合函数"><a href="#3-4Aggregate-Functions聚合函数" class="headerlink" title="3.4Aggregate Functions聚合函数"></a>3.4Aggregate Functions聚合函数</h3><h3 id="普通："><a href="#普通：" class="headerlink" title="普通："></a>普通：</h3><p>这些函数对关系的列的多集值进行操作，并返回值，<strong>要求不能为空，可以有重复值</strong></p>
<p>  <strong>avg:</strong> average value<br>  <strong>min:</strong> minimum value<br>  <strong>max:</strong> maximum value<br>  <strong>sum:</strong> sum of values<br>  <strong>count:</strong> number of values</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">avg</span> <span class="token punctuation">(</span>balance<span class="token punctuation">)</span> <span class="token comment"># 求平均值</span>
<span class="token keyword">from</span> account
<span class="token keyword">where</span> branch_name <span class="token operator">=</span> <span class="token string">'Perryridge'</span>

<span class="token keyword">select</span> <span class="token function">count</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token comment"># 计算元组的数量</span>
<span class="token keyword">from</span> customer

<span class="token keyword">select</span> <span class="token function">count</span> <span class="token punctuation">(</span><span class="token keyword">distinct</span> customer_name<span class="token punctuation">)</span> <span class="token comment"># 计算不重复的元组数量，去除重复（eliminate duplicates）</span>
<span class="token keyword">from</span> depositor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Group-By以组为单位"><a href="#Group-By以组为单位" class="headerlink" title="Group By以组为单位"></a>Group By以组为单位</h4><p>集合函数之外的选择子句中的属性必须按列表分组显示</p>
<p>GROUP BY 语句用于结合集合函数，根据一个或多个列对结果集进行分组。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">,</span> aggregate_function<span class="token punctuation">(</span>column_name<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> table_name
<span class="token keyword">WHERE</span> column_name operator <span class="token keyword">value</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> column_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Having"><a href="#Having" class="headerlink" title="Having"></a>Having</h4><p>having 子句中的谓词（predicates）<strong>在组形成之后应用</strong></p>
<p>而 where 子句中的谓词<strong>在形成组之前应用</strong></p>
<p>只有满足having条件的组才输出，只筛选group by之后的</p>
<p>select语句返回的列只有两种情况</p>
<ul>
<li>在聚集函数中的</li>
<li>group by 分过组后的</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 普通示例</span>
<span class="token keyword">SELECT</span> Websites<span class="token punctuation">.</span>name<span class="token punctuation">,</span> Websites<span class="token punctuation">.</span>url<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>access_log<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token keyword">AS</span> nums <span class="token keyword">FROM</span> <span class="token punctuation">(</span>access_log
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> Websites
<span class="token keyword">ON</span> access_log<span class="token punctuation">.</span>site_id<span class="token operator">=</span>Websites<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Websites<span class="token punctuation">.</span>name
<span class="token keyword">HAVING</span> <span class="token function">SUM</span><span class="token punctuation">(</span>access_log<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">200</span><span class="token punctuation">;</span>

<span class="token comment"># 执行顺序</span>
<span class="token keyword">SELECT</span> 		<span class="token number">5</span>
<span class="token keyword">FROM</span>		<span class="token number">1</span>
<span class="token keyword">WHERE</span>		<span class="token number">2</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span>	<span class="token number">3</span>
<span class="token keyword">HAVING</span>		<span class="token number">4</span>
<span class="token keyword">Order</span> <span class="token keyword">by</span>	<span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-5Null-Values空值"><a href="#3-5Null-Values空值" class="headerlink" title="3.5Null Values空值"></a>3.5Null Values空值</h3><p>元组的某些属性可能具有空值（用 null 表示）</p>
<p>null 表示未知值或值不存在。</p>
<p>谓词为 null 可用于检查空值</p>
<p>任何涉及null的<strong>算术表达式</strong>的结果都是<em><strong>null</strong></em></p>
<p>任何与 null 的<strong>比较</strong>都返回<em><strong>unkown</strong></em></p>
<p>使用未知真值(unknown)的三值逻辑：</p>
<ul>
<li>OR: (unknown <strong>or</strong> true)     = true,<br>(unknown <strong>or</strong> false)    = unknown<br>(unknown <strong>or</strong> unknown) = unknown</li>
<li>AND:  (true <strong>and</strong> unknown)    = unknown,<br>(false <strong>and</strong> unknown)    = false,<br>  (unknown <strong>and</strong> unknown) = unknown</li>
<li>NOT: (<strong>not</strong> unknown) = unknown</li>
</ul>
<p>如果子句谓词(clause predicate)的计算结果(evaluates评估)为未知，则将其视为 false </p>
<p>除 count（*） 之外的所有聚合操作都会忽略聚合属性上具有空值的元组</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> loan_number
<span class="token keyword">from</span> loan
<span class="token keyword">where</span> amount <span class="token operator">is</span> <span class="token boolean">null</span>

<span class="token number">5</span> <span class="token operator">+</span> <span class="token boolean">null</span> <span class="token keyword">returns</span> <span class="token boolean">null</span>
<span class="token number">5</span> <span class="token operator">&lt;</span> <span class="token boolean">null</span> <span class="token operator">or</span> <span class="token boolean">null</span> <span class="token operator">&lt;&gt;</span> <span class="token boolean">null</span> <span class="token operator">or</span> <span class="token boolean">null</span> <span class="token operator">=</span> <span class="token boolean">null</span> <span class="token keyword">return</span> <span class="token boolean">null</span>
<span class="token boolean">null</span> <span class="token operator">is</span> <span class="token boolean">null</span> <span class="token keyword">returns</span> <span class="token boolean">true</span>
<span class="token boolean">null</span><span class="token operator">=</span><span class="token boolean">null</span>	<span class="token keyword">returns</span> unknown

<span class="token keyword">select</span> <span class="token function">sum</span> <span class="token punctuation">(</span>amount<span class="token punctuation">)</span>
<span class="token keyword">from</span> loan
<span class="token comment"># 上述语句忽略null金额，如果non-null空量，则结果为null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-6Nested-Subqueries嵌套子查询"><a href="#3-6Nested-Subqueries嵌套子查询" class="headerlink" title="3.6Nested Subqueries嵌套子查询"></a>3.6Nested Subqueries嵌套子查询</h3><p>SQL 提供了一种用于嵌套子查询的机制（mechanism）。 </p>
<p>子查询（<strong>subquery</strong>）是嵌套在另一个查询中的”<strong>select-from-where</strong> “表达式。 </p>
<p>子查询的常见用途是执行集成员身份（set membership）、集比较（set comparisons）和设置基数（set cardinality）的测试</p>
<p><strong>相关子查询</strong>：子查询中包含外边的查询</p>
<h4 id="3-6-1集合成员资格（连接词in，对应not-in）：是否是集合中的成员"><a href="#3-6-1集合成员资格（连接词in，对应not-in）：是否是集合中的成员" class="headerlink" title="3.6.1集合成员资格（连接词in，对应not in）：是否是集合中的成员"></a>3.6.1集合成员资格（连接词in，对应not in）：是否是集合中的成员</h4><h4 id="3-6-2集合的比较（some-all子句）"><a href="#3-6-2集合的比较（some-all子句）" class="headerlink" title="3.6.2集合的比较（some all子句）"></a>3.6.2集合的比较（some all子句）</h4><p>some 子句 - 至少比某一个…</p>
<p>all 子句 - 比所有都…</p>
<h4 id="3-6-3空关系测试（exists结构，对应not-exists）"><a href="#3-6-3空关系测试（exists结构，对应not-exists）" class="headerlink" title="3.6.3空关系测试（exists结构，对应not exists）"></a>3.6.3空关系测试（exists结构，对应not exists）</h4><p><strong>exists r ⇔ r ≠ ∅</strong></p>
<p><strong>not exist r ⇔ r = ∅</strong></p>
<p><strong>关系代数÷</strong>可以使用两个exists（第一个为除数位置的关系）实现</p>
<h4 id="3-6-4重复元组存在性测试（unique结构-x2F-not-unique）"><a href="#3-6-4重复元组存在性测试（unique结构-x2F-not-unique）" class="headerlink" title="3.6.4重复元组存在性测试（unique结构/not unique）"></a>3.6.4重复元组存在性测试（unique结构/not unique）</h4><p>SQL提供一个布尔函数，用于测试在一个子查询的结果中是否存在重复元组。如果作为参数的子查询结果中<strong>没有重复的元组unique结构将返回true值</strong></p>
<h4 id="3-6-5（派生关系Derived-Relations）from子句中的子查询"><a href="#3-6-5（派生关系Derived-Relations）from子句中的子查询" class="headerlink" title="3.6.5（派生关系Derived Relations）from子句中的子查询"></a>3.6.5（派生关系Derived Relations）from子句中的子查询</h4><p>SQL允许在from子句中使用子查询表达式。<br>任何select-from-where表达式返回的结果都是关系，因而<strong>可以被插入到另一个select-from-where中任何关系可以出现的位置</strong></p>
<h4 id="3-6-6定义临时关系（with子句）"><a href="#3-6-6定义临时关系（with子句）" class="headerlink" title="3.6.6定义临时关系（with子句）"></a>3.6.6定义临时关系（with子句）</h4><p><code>with子句</code>提供定义临时关系的方法，<strong>这个定义只对包含with子句的查询有效</strong></p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token keyword">distinct</span> customer_name
<span class="token keyword">from</span> borrower
<span class="token keyword">where</span> customer_name <span class="token operator">in</span> 
					<span class="token punctuation">(</span><span class="token keyword">select</span> customer_name                                           <span class="token keyword">from</span> depositor<span class="token punctuation">)</span><span class="token comment"># 测试集成员资格 in</span>
					
<span class="token keyword">select</span> <span class="token keyword">distinct</span> customer_name
<span class="token keyword">from</span> borrower
<span class="token keyword">where</span> customer_name <span class="token operator">not</span> <span class="token operator">in</span> 
					<span class="token punctuation">(</span><span class="token keyword">select</span> customer_name                                                 <span class="token keyword">from</span> depositor<span class="token punctuation">)</span><span class="token comment"># 测试不具备集成员资格not in</span>
<span class="token keyword">select</span> branch_name
<span class="token keyword">from</span> branch
<span class="token keyword">where</span> assets <span class="token operator">&gt;</span> <span class="token keyword">some</span> <span class="token comment"># 设置集成员比较 &gt;</span>
			<span class="token punctuation">(</span><span class="token keyword">select</span> assets 
             <span class="token keyword">from</span> branc 
             <span class="token keyword">where</span> branch_city <span class="token operator">=</span> <span class="token string">'Brooklyn'</span><span class="token punctuation">)</span> 
             
<span class="token keyword">select</span> branch_name
<span class="token keyword">from</span> branch
<span class="token keyword">where</span> assets <span class="token operator">&gt;</span> <span class="token keyword">all</span> <span class="token comment"># all子句，这里assets要大于所有子查询的assets</span>
				<span class="token punctuation">(</span><span class="token keyword">select</span> assets
                 <span class="token keyword">from</span> branch
                 <span class="token keyword">where</span> branch_city <span class="token operator">=</span> <span class="token string">'Brooklyn'</span><span class="token punctuation">)</span> 
                 
<span class="token keyword">select</span> <span class="token keyword">distinct</span> customer_name
<span class="token keyword">from</span> borrower
<span class="token keyword">where</span> <span class="token keyword">exists</span> <span class="token comment"># exists子句，子句中存在就返回true</span>
		<span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> 
         <span class="token keyword">from</span> depositor 
         <span class="token keyword">where</span> depositor<span class="token punctuation">.</span>customer_name <span class="token operator">=</span>  borrower<span class="token punctuation">.</span>customer_name <span class="token punctuation">)</span>

<span class="token keyword">select</span> T<span class="token punctuation">.</span>customer_name
<span class="token keyword">from</span> depositor <span class="token keyword">as</span> T
<span class="token keyword">where</span> <span class="token keyword">unique</span> <span class="token punctuation">(</span> <span class="token comment"># unique子句，子句中唯一存在就返回真</span>
    	<span class="token keyword">select</span> R<span class="token punctuation">.</span>customer_name 
    	<span class="token keyword">from</span> account<span class="token punctuation">,</span> depositor <span class="token keyword">as</span> R 
    	<span class="token keyword">where</span> T<span class="token punctuation">.</span>customer_name <span class="token operator">=</span> R<span class="token punctuation">.</span>customer_name <span class="token operator">and</span> 
    	R<span class="token punctuation">.</span>account_number <span class="token operator">=</span> account<span class="token punctuation">.</span>account_number <span class="token operator">and</span> 
    	account<span class="token punctuation">.</span>branch_name <span class="token operator">=</span> <span class="token string">'Perryridge'</span><span class="token punctuation">)</span> 

<span class="token keyword">select</span> branch_name<span class="token punctuation">,</span> avg_balance 
<span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> branch_name<span class="token punctuation">,</span> <span class="token function">avg</span> <span class="token punctuation">(</span>balance<span class="token punctuation">)</span> <span class="token comment"># from子查询</span>
      <span class="token keyword">from</span> account
      <span class="token keyword">group</span> <span class="token keyword">by</span> branch_name<span class="token punctuation">)</span>
      <span class="token keyword">as</span> branch_avg<span class="token punctuation">(</span>branch_name<span class="token punctuation">,</span> avg_balance<span class="token punctuation">)</span>
<span class="token keyword">where</span> avg_balance <span class="token operator">&gt;</span> <span class="token number">1200</span>

<span class="token keyword">with</span> max_balance <span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token comment"># with子句定义临时关系</span>
	<span class="token keyword">select</span> <span class="token function">max</span> <span class="token punctuation">(</span>balance<span class="token punctuation">)</span> 
	<span class="token keyword">from</span> account 
<span class="token keyword">select</span> account_number 
<span class="token keyword">from</span> account<span class="token punctuation">,</span> max_balance 
<span class="token keyword">where</span> account<span class="token punctuation">.</span>balance <span class="token operator">=</span> max_balance<span class="token punctuation">.</span><span class="token keyword">value</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-7Complex-Queries-用with子句的复杂查询"><a href="#3-7Complex-Queries-用with子句的复杂查询" class="headerlink" title="3.7Complex Queries (用with子句的复杂查询)"></a>3.7Complex Queries (用with子句的复杂查询)</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">with</span> branch_total <span class="token punctuation">(</span>branch_name<span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token keyword">as</span>
    <span class="token keyword">select</span> branch_name<span class="token punctuation">,</span> <span class="token function">sum</span> <span class="token punctuation">(</span>balance<span class="token punctuation">)</span>
    <span class="token keyword">from</span> account
    <span class="token keyword">group</span> <span class="token keyword">by</span> branch_name
<span class="token keyword">with</span> branch_total_avg <span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token keyword">as</span>
    <span class="token keyword">select</span> <span class="token function">avg</span> <span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span>
    <span class="token keyword">from</span> branch_total
<span class="token keyword">select</span> branch_name
<span class="token keyword">from</span> branch_total<span class="token punctuation">,</span> branch_total_avg
<span class="token keyword">where</span> branch_total<span class="token punctuation">.</span><span class="token keyword">value</span> <span class="token operator">&gt;=</span> branch_total_avg<span class="token punctuation">.</span><span class="token keyword">value</span>
<span class="token comment">/*
	查找所有分行账户总存款均高于账户总存款平均值的所有分行(多用了个with)
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-8Views视图"><a href="#3-8Views视图" class="headerlink" title="3.8Views视图"></a>3.8Views视图</h3><p>视图是使用<strong>create view</strong>语句定义的，该语句具有以下格式 </p>
<blockquote>
<p> <strong>create view</strong> <em>v</em> <strong>as</strong> *&lt;* query expression &gt;</p>
</blockquote>
<p>其中<code>&lt; query expression &gt;</code>是任何合法的 SQL 表达式。 视图名称由 v 表示</p>
<p>定义视图后，视图名称可用于引用视图生成的虚拟关系。</p>
<p>创建视图时，查询表达式存储在数据库中；使用视图将表达式替换为查询。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">view</span> all_customer <span class="token keyword">as</span>
	<span class="token punctuation">(</span><span class="token keyword">select</span> branch_name<span class="token punctuation">,</span> customer_name
     <span class="token keyword">from</span> depositor<span class="token punctuation">,</span> account
     <span class="token keyword">where</span> depositor<span class="token punctuation">.</span>account_number <span class="token operator">=</span> account<span class="token punctuation">.</span>account_number<span class="token punctuation">)</span>
     <span class="token keyword">union</span>
     <span class="token punctuation">(</span><span class="token keyword">select</span> branch_name<span class="token punctuation">,</span> customer_name
      <span class="token keyword">from</span> borrower<span class="token punctuation">,</span> loan
      <span class="token keyword">where</span> borrower<span class="token punctuation">.</span>loan_number <span class="token operator">=</span> loan<span class="token punctuation">.</span>loan_number<span class="token punctuation">)</span>
<span class="token comment"># A view consisting of branches and their customers由分支机构及其客户组成的视图</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果在定义 v1 的表达式中使用 v2，则视图关系 v1 称为<em><strong>depend directly</strong></em>于视图关系 v2</p>
<p>如果 v1 直接依赖于 v2，或者存在从 v1 到 v2 的依赖关系路径，则视图关系 v1 称为<em><strong>depend on</strong></em> 视图关系 v2 如果视图关系 v 依赖于自身，则称其为<em><strong>recursive</strong></em>(递归)关系。</p>
<p><strong>视图展开View Expansion</strong></p>
<p>表达式的视图展开将重复以下替换步骤： </p>
<blockquote>
<p><strong>repeat</strong></p>
<p>Find any view relation <em>vi</em> in <em>e</em>1 </p>
<p>Replace the view relation <em>vi</em> by the expression defining <em>vi</em> </p>
<p><strong>until</strong> no more view relations are present in <em>e</em>1</p>
</blockquote>
<p>翻译：重复在 e1 中查找任何视图关系 vi，将视图关系 vi 替换为定义 vi 的表达式，直到 e1 中不再存在视图关系</p>
<p>只要视图定义不是递归的，此循环就会终止</p>
<h3 id="3-9Modification-of-the-Database数据库的修改"><a href="#3-9Modification-of-the-Database数据库的修改" class="headerlink" title="3.9Modification of the Database数据库的修改"></a>3.9Modification of the Database数据库的修改</h3><h4 id="Deletion删除某行"><a href="#Deletion删除某行" class="headerlink" title="Deletion删除某行"></a>Deletion删除某行</h4><p>删除某列使用alter语句（涉及表的结构schema为DDL语句）</p>
<p><code>注意</code>: <strong>delete 后必须为 from 而不是 table</strong></p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 删除余额低于银行平均水平的所有账户的记录。</span>
<span class="token keyword">delete</span> <span class="token keyword">from</span> account
<span class="token keyword">where</span> balance <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token function">avg</span> <span class="token punctuation">(</span>balance<span class="token punctuation">)</span>
                 <span class="token keyword">from</span> account<span class="token punctuation">)</span>
<span class="token comment">/*
	问题：当我们从存款中删除元组时，平均余额会发生变化
	SQL的解决方案（不解决平均金额不对的问题）：
		1. 首先，计算平均余额并找到所有要删除的元组
		2. 接下来，删除上面找到的所有元组（无需重新计算 avg 或重新测试元组）
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Insertion插入某行"><a href="#Insertion插入某行" class="headerlink" title="Insertion插入某行"></a>Insertion插入某行</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> account
	<span class="token keyword">select</span> loan_number<span class="token punctuation">,</span> branch_name<span class="token punctuation">,</span>  <span class="token number">200</span>
	<span class="token keyword">from</span> loan
	<span class="token keyword">where</span> branch_name <span class="token operator">=</span> <span class="token string">'Perryridge'</span> 

<span class="token keyword">insert</span> <span class="token keyword">into</span> account<span class="token punctuation">(</span>branch_name<span class="token punctuation">,</span> balance<span class="token punctuation">,</span> account_number<span class="token punctuation">)</span>
<span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">'Perryridge'</span><span class="token punctuation">,</span>  <span class="token number">1200</span><span class="token punctuation">,</span> <span class="token string">'A-9732'</span><span class="token punctuation">)</span> 

<span class="token keyword">insert</span> <span class="token keyword">into</span> account
<span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">'A-9732'</span><span class="token punctuation">,</span> <span class="token string">'Perryridge'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">)</span> <span class="token comment"># 可以置为空</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Updates更新"><a href="#Updates更新" class="headerlink" title="Updates更新"></a>Updates更新</h4><p>对普通表的更新</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 题目：将余额超过 10000 美元的所有账户增加 6%，所有其他账户增加 5%。</span>
<span class="token comment"># 第一种：顺序很重要</span>
<span class="token keyword">update</span> account
<span class="token keyword">set</span> balance <span class="token operator">=</span> balance <span class="token operator">*</span> <span class="token number">1.06</span>
<span class="token keyword">where</span> balance <span class="token operator">&gt;</span> <span class="token number">10000</span>

<span class="token keyword">update</span> account
<span class="token keyword">set</span> balance <span class="token operator">=</span> balance <span class="token operator">*</span> <span class="token number">1.05</span>
<span class="token keyword">where</span> balance <span class="token operator">*</span> <span class="token number">10000</span>

<span class="token comment"># 第二种 推荐用法Conditional Updates（条件更新）</span>
<span class="token keyword">update</span> account
	<span class="token keyword">set</span> balance <span class="token operator">=</span> <span class="token keyword">case</span>
		<span class="token keyword">when</span> balance <span class="token operator">&lt;=</span> <span class="token number">10000</span>
			<span class="token keyword">then</span> balance <span class="token operator">*</span><span class="token number">1.05</span>
		<span class="token keyword">else</span>   balance <span class="token operator">*</span> <span class="token number">1.06</span>
		<span class="token keyword">end</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过==视图==更新</p>
<p>大多数 SQL 实现仅允许在单个关系上定义的简单视图（无聚合）上进行更新</p>
<p>有些通过视图进行的更新不可能转换为数据库关系的更新，不能的情况（情况来源csdn非非官方）：</p>
<p>（1）聚合函数；<br>（2）DISTINCT关键字；<br>（3）GROUP BY子句；<br>（4）ORDER BY子句；<br>（5）HAVING子句；<br>（6）UNION运算符；<br>（7）位于选择列表中的子查询；<br>（8）FROM子句中包含多个表；<br>（9）SELECT语句中引用了不可更新视图；<br>（10）WHERE子句中的子查询，引用FROM子句中的表；<br>（11）ALGORITHM 选项指定为TEMPTABLE（使用临时表总会使视图成为不可更新的）。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">view</span> loan_branch <span class="token keyword">as</span> <span class="token comment"># 创建视图</span>
<span class="token keyword">select</span> loan_number<span class="token punctuation">,</span> branch_name
<span class="token keyword">from</span> loan

<span class="token keyword">insert</span> <span class="token keyword">into</span> v <span class="token comment"># 通过视图使用insert into，其余没有赋值的属性为null</span>
<span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">'L-99'</span><span class="token punctuation">,</span><span class="token string">'Downtown'</span><span class="token punctuation">,</span> <span class="token string">'23'</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-10Joined-Relations"><a href="#3-10Joined-Relations" class="headerlink" title="3.10Joined Relations**"></a>3.10Joined Relations**</h3><p><strong>Join operations</strong> 联接操作采用两个关系，并因此返回另一个关系。 </p>
<p>这些附加操作通常用作 from 子句中的子查询表达式</p>
<p><strong>Join condition</strong> 连接条件 – 定义两个关系中的哪些元组匹配，以及连接结果中存在哪些属性</p>
<p><strong>Join type</strong> 联接类型– 定义如何处理每个关系中与另一个关系中的任何元组不匹配的元组（基于连接条件）</p>
<p>可以使用的<strong>join type</strong>（来源菜鸟教程）：</p>
<ul>
<li><strong>INNER JOIN</strong>：如果表中有至少一个匹配，则返回行</li>
<li><strong>LEFT JOIN</strong>：即使右表中没有匹配，也从左表返回所有的行</li>
<li><strong>RIGHT JOIN</strong>：即使左表中没有匹配，也从右表返回所有的行</li>
<li><strong>FULL JOIN</strong>：只要其中一个表中存在匹配，则返回行</li>
<li><strong>cross join</strong> : 结果是笛卡尔积，就是第一个表的行数乘以第二个表的行数。</li>
</ul>
<p><strong>join conditions</strong>有：</p>
<ul>
<li>natural</li>
<li>on&lt; predicate &gt;</li>
<li>using(A<sub>1</sub>,A<sub>2</sub>,…A<sub>n</sub>)</li>
</ul>
<p>eg：P83 可参考<a href="https://www.runoob.com/w3cnote/sql-join-the-different-of-on-and-where.html">SQL JOIN 中 on 与 where的区别</a>     <a href="https://www.runoob.com/sql/sql-join.html">菜鸟教程join</a></p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">loan <span class="token keyword">inner</span> <span class="token keyword">join</span> borrower <span class="token keyword">on</span>
	loan<span class="token punctuation">.</span>loan_number <span class="token operator">=</span> borrower<span class="token punctuation">.</span>loan_number
loan <span class="token keyword">left</span> <span class="token keyword">outer</span> <span class="token keyword">join</span> borrower <span class="token keyword">on</span>
	loan<span class="token punctuation">.</span>loan_number <span class="token operator">=</span> borrower<span class="token punctuation">.</span>loan_number
loan <span class="token keyword">natural</span> <span class="token keyword">inner</span> <span class="token keyword">join</span> borrower
loan <span class="token keyword">natural</span> <span class="token keyword">right</span> <span class="token keyword">outer</span> <span class="token keyword">join</span> borrower
loan <span class="token keyword">full</span> <span class="token keyword">outer</span> <span class="token keyword">join</span> borrower <span class="token keyword">using</span> <span class="token punctuation">(</span>loan_number<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="第四章Advanced-SQL高级SQL"><a href="#第四章Advanced-SQL高级SQL" class="headerlink" title="第四章Advanced SQL高级SQL"></a>第四章Advanced SQL高级SQL</h2><h3 id="4-1SQL-Data-Types-and-Schemas"><a href="#4-1SQL-Data-Types-and-Schemas" class="headerlink" title="4.1SQL Data Types and Schemas"></a>4.1SQL Data Types and Schemas</h3><h4 id="Built-in-Data-Types-in-SQL内置数据类型"><a href="#Built-in-Data-Types-in-SQL内置数据类型" class="headerlink" title="Built-in Data Types in SQL内置数据类型"></a>Built-in Data Types in SQL内置数据类型</h4><p><strong>date</strong>：由年月日组成，格式为  yyyy -mm-dd </p>
<p><strong>time</strong>： 由 小时：分钟：秒 组成，格式为  hh:mm:ss</p>
<p><strong>time(i)</strong> ：由小时：分钟：秒加上 i （i为秒后的位数，精确到秒）个额外的数字组成，指定秒的分数，格式为 hh:mm:ss:ii…i</p>
<p><strong>Timestamp</strong>：时间戳，日期加一天中的时间</p>
<p><strong>interval</strong>：时间段，第一种用法是从另一个日期/时间/时间戳值中减去一个日期/时间/时间戳值，得到一个间隔值；第二种用法是间隔值可以添加到日期/时间/时间戳值</p>
<blockquote>
<p>可以从日期/时间/时间戳中提取单个字段的值:</p>
<p>​	<strong>extract</strong> (<strong>year from</strong> r.starttime) </p>
<p>可以将字符串类型转换为日期/时间/时间戳:</p>
<p>​	<strong>cast</strong> &lt; string-valued-expression&gt; <strong>as date</strong></p>
<p>​	<strong>cast</strong> <string-valued-expression> <strong>as time</strong></string-valued-expression></p>
</blockquote>
<h4 id="User-Defined-Types用户定义的类型"><a href="#User-Defined-Types用户定义的类型" class="headerlink" title="User-Defined Types用户定义的类型"></a>User-Defined Types用户定义的类型</h4><p><strong>create type</strong> ：SQL 中的构造创建用户定义类型</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">type</span> Dollars <span class="token keyword">as</span> <span class="token keyword">numeric</span> <span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> final <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>create domain</strong> :在 SQL-92 中构造创建用户定义的域类型</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> domain person_name <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>类型和域是相似的。 域可以具有在其上指定的约束，例如不为 null。</p>
<h4 id="Domain-Constraints域约束"><a href="#Domain-Constraints域约束" class="headerlink" title="Domain Constraints域约束"></a>Domain Constraints域约束</h4><p>域约束是最基本的完整性约束形式。它们测试插入到数据库中的值，并<strong>测试查询以确保比较有意义</strong>。</p>
<p>可以从现有数据类型创建新域</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> domain Dollars <span class="token keyword">numeric</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token keyword">create</span> domain Pounds <span class="token keyword">numeric</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>转换类型：cast关键字</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token punctuation">(</span>cast r<span class="token punctuation">.</span>A <span class="token keyword">as</span> Pounds<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="Large-Object-Types大型对象类型"><a href="#Large-Object-Types大型对象类型" class="headerlink" title="Large-Object Types大型对象类型"></a>Large-Object Types大型对象类型</h4><p>大型对象（照片、视频、CAD 文件等）存储为大型对象： </p>
<p><strong>blob</strong>：二进制大型对象 – 对象是未解释的二进制数据的大型集合（其解释留给数据库系统外部的应用程序） </p>
<p><strong>clob</strong>：字符大对象 – 对象是字符数据的大型集合</p>
<p>当查询返回大型对象时，将返回指针而不是大型对象本身</p>
<h3 id="4-2Integrity-Constraints"><a href="#4-2Integrity-Constraints" class="headerlink" title="4.2Integrity Constraints"></a>4.2Integrity Constraints</h3><p>完整性约束通过确保对数据库的授权更改不会导致数据一致性的丢失来防止对数据库的意外损坏。</p>
<p>（来源网络）数据完整性包括：实体完整性、域完整性、参照完整性、用户定义的完整性。</p>
<p>（来源网络）完整性约束的类型可分为三种类型：与表有关的约束、域(Domain)约束、断言(Assertion)<strong>本节按此分类</strong></p>
<p>（来源网络）与表有关的约束：包括列约束(表约束+NOT NULL)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。</p>
<h4 id="Constraints-on-a-Single-Relation-对单个关系的约束"><a href="#Constraints-on-a-Single-Relation-对单个关系的约束" class="headerlink" title="Constraints on a Single Relation**对单个关系的约束"></a>Constraints on a Single Relation**对单个关系的约束</h4><p><strong>not null、primary key、unique、check</strong> (P ), where <em>P</em> is a predicate</p>
<p>check子句前可选择使用constraint子句;用于指示更新违反了哪个约束。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># (1) not null（非空)约束： 只用于定义列约束。（见下一章）</span>
    <span class="token keyword">create</span> <span class="token keyword">table</span> Employee
        <span class="token punctuation">(</span>emp_id <span class="token keyword">int</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>
        emp_name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>
        address <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">create</span> domain Dollars <span class="token keyword">numeric</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token comment"># 声明域不为空</span>

<span class="token comment"># (2) primary key(主键)约束：用于定义基本表的主键，起惟一标识作用，其值不能为null,也不能重复，以此来保证实体的完整性。（见下一章）</span>
    <span class="token keyword">create</span> <span class="token keyword">table</span> branch
        <span class="token punctuation">(</span>branch_name <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
         branch_city <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
         assets	<span class="token keyword">integer</span><span class="token punctuation">,</span>
         <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>branch_name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#主键声明1</span>

    <span class="token keyword">create</span> <span class="token keyword">table</span> branch
        <span class="token punctuation">(</span>branch_name <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span><span class="token comment">#主键声明2</span>
         branch_city <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
         assets	<span class="token keyword">integer</span><span class="token punctuation">,</span><span class="token punctuation">)</span>
	<span class="token comment">/*
	1.在一个表中，只能定义一个primary key约束，但可定义多个unique约束。
	2.对于指定为primary key的一个列或多个列的组合，其中任何一个列都不能出现空值，而对于unique所约束的惟一键，则允许为null,只是null值最多有一个。
	3.候选码允许为null，但是null只能有一个。
	*/</span>
	
<span class="token comment"># (3) unique(惟一)约束：用于指明创建惟一约束的列上的取值必须惟一。（见下一章）</span>
    <span class="token keyword">create</span> <span class="token keyword">table</span> EmployeeInfo
        <span class="token punctuation">(</span>emp_id <span class="token keyword">int</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>
        emp_name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>
        phone <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">unique</span><span class="token punctuation">,</span>
        address <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># (4) check（校验）约束：用来检查字段值所允许的范围。DBMS每当执行delete,insert或update语句时，都对这个约束过滤。如果为true，则执行。否则，取消执行并提示错误。SQL-92 中的检查子句允许限制域。子句constraint是可选的;用于指示更新违反了哪个约束。</span>

    <span class="token keyword">create</span> <span class="token keyword">table</span> Emp_Sal
        <span class="token punctuation">(</span>emp_id <span class="token keyword">int</span><span class="token punctuation">,</span> 
         account <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
         salary <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
         <span class="token keyword">constraint</span> validsal 
         <span class="token keyword">check</span><span class="token punctuation">(</span>salary <span class="token operator">&gt;=</span><span class="token number">1000</span> <span class="token operator">and</span> salary<span class="token operator">&lt;=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">create</span> domain hourly_wage <span class="token keyword">numeric</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
    	<span class="token keyword">constraint</span> value_test 
    	<span class="token keyword">check</span><span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token number">4.00</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Referential-Integrity参照完整性"><a href="#Referential-Integrity参照完整性" class="headerlink" title="Referential Integrity参照完整性"></a>Referential Integrity参照完整性</h4><p><strong>primary key</strong> 子句列出组成主键的属性。 </p>
<p><strong>unique</strong>子句列出组成候选键的属性。</p>
<p><strong>foreign key</strong> 子句列出组成外键的属性和外键所引用的关系的名称。 </p>
<p>默认情况下，外键引用被引用表的主键属性。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 1、primary key</span>
<span class="token keyword">create</span> <span class="token keyword">table</span> customer
    <span class="token punctuation">(</span>customer_name	<span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    customer_street	<span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    customer_city	<span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>customer_name <span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">create</span> <span class="token keyword">table</span> branch
    <span class="token punctuation">(</span>branch_name <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     branch_city <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     assets <span class="token keyword">numeric</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>branch_name <span class="token punctuation">)</span><span class="token punctuation">)</span>
     
<span class="token comment"># 2.unique ( A1, A2, …, Am)</span>

<span class="token comment"># (3) foreign key(外键)约束（来源网络）：定义了一个表中数据与另一个表中的数据的联系。</span>
<span class="token keyword">create</span> <span class="token keyword">table</span> account
	<span class="token punctuation">(</span>account_number	<span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     branch_name	<span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     balance <span class="token keyword">integer</span><span class="token punctuation">,</span>
     <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>account_number<span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token keyword">foreign</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>branch_name<span class="token punctuation">)</span> <span class="token keyword">references</span> branch <span class="token punctuation">)</span>

<span class="token keyword">create</span> <span class="token keyword">table</span> depositor
	<span class="token punctuation">(</span>customer_name <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    account_number <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>customer_name<span class="token punctuation">,</span> account_number<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">foreign</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>account_number<span class="token punctuation">)</span> <span class="token keyword">references</span> account<span class="token punctuation">,</span>
    <span class="token keyword">foreign</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>customer_name<span class="token punctuation">)</span> <span class="token keyword">references</span> customer<span class="token punctuation">)</span>
     <span class="token comment">/*可以为表的一列或多列创建foreign key 约束，如果为多列创建 foreign key约束，将分别与主表中的相应主键相对应。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Assertions断言"><a href="#Assertions断言" class="headerlink" title="Assertions断言"></a>Assertions断言</h4><p>Assertions是一个谓词，表示我们希望数据库始终满足的条件</p>
<p>做出断言时，系统会测试其有效性，并在可能违反断言的每次更新上再次测试该断言,此测试可能会引入大量的开销。因此，应非常谨慎地使用断言。</p>
<p>SQL 中的Assertions采用以下形式:</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> assertion <span class="token operator">&lt;</span>assertion<span class="token operator">-</span>name<span class="token operator">&gt;</span> <span class="token keyword">check</span> <span class="token operator">&lt;</span>predicate<span class="token operator">&gt;</span>
<span class="token comment"># Asserting (for all X, P(X))是通过迂回方式实现：（not exists X such that not P(X)）</span>

<span class="token comment"># 每笔贷款至少有一名借款人，其账户的最低余额为1000.00美元</span>
<span class="token keyword">create</span> assertion balance_constraint <span class="token keyword">check</span>
<span class="token punctuation">(</span><span class="token operator">not</span> <span class="token keyword">exists</span> <span class="token punctuation">(</span>
	<span class="token keyword">select</span> <span class="token operator">*</span>
    <span class="token keyword">from</span> loan
    <span class="token keyword">where</span> <span class="token operator">not</span> <span class="token keyword">exists</span> <span class="token punctuation">(</span>
        <span class="token keyword">select</span> <span class="token operator">*</span>
        <span class="token keyword">from</span> borrower<span class="token punctuation">,</span> depositor<span class="token punctuation">,</span> account
        <span class="token keyword">where</span> loan<span class="token punctuation">.</span>loan_number <span class="token operator">=</span> borrower<span class="token punctuation">.</span>loan_number       
        <span class="token operator">and</span> borrower<span class="token punctuation">.</span>customer_name <span class="token operator">=</span> depositor<span class="token punctuation">.</span>customer_name
        <span class="token operator">and</span> depositor<span class="token punctuation">.</span>account_number <span class="token operator">=</span> account<span class="token punctuation">.</span>account_number
        <span class="token operator">and</span> account<span class="token punctuation">.</span>balance <span class="token operator">&gt;=</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-3Authorization"><a href="#4-3Authorization" class="headerlink" title="4.3Authorization"></a>4.3Authorization</h3><p>对数据库各部分的授权形式Forms（以下为<font color="red"><strong>自然语言</strong></font>，不是授权名）：</p>
<p>​	<strong>Read</strong>：允许读取，但不允许修改数据。</p>
<p>​	<strong>Insert</strong>：允许插入新数据，但不允许修改现有数据。</p>
<p>​	<strong>Update</strong>：允许修改，但不允许删除数据。</p>
<p>​	<strong>Delete</strong>：允许删除数据。</p>
<p>修改数据库模式schema的授权形式（在第 8 章中介绍）：</p>
<p>​	<strong>Index</strong>：允许创建和删除索引。（索引不能修改，系统自动维护）</p>
<p>​	<strong>Resources</strong>：允许创建新关系。</p>
<p>​	<strong>Alteration</strong>：允许在关系中添加或删除属性。</p>
<p>​	<strong>Drop</strong>：允许删除关系。</p>
<h4 id="Authorization-Specification-in-SQL授权规范"><a href="#Authorization-Specification-in-SQL授权规范" class="headerlink" title="Authorization Specification in SQL授权规范"></a>Authorization Specification in SQL授权规范</h4><p>​	<strong>grant</strong>语句用于授予授权</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">grant</span> <span class="token operator">&lt;</span>privilege list<span class="token punctuation">(</span>特权列表，所有的特权，所有允许的特权<span class="token punctuation">)</span><span class="token operator">&gt;</span>
<span class="token keyword">on</span> <span class="token operator">&lt;</span>relation name <span class="token operator">or</span> <span class="token keyword">view</span> name<span class="token operator">&gt;</span> <span class="token keyword">to</span> <span class="token operator">&lt;</span><span class="token keyword">user</span> list<span class="token punctuation">(</span>用户id列表 公共的，所有当前和未来的用户<span class="token punctuation">)</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>​	授予视图特权（Granting a privilege on a view）并不意味着授予对底层关系（对表的操作）的任何特权。</p>
<p>​	表和视图相互独立（有表的权限不代表又视图的权限）</p>
<p>​	特权的授予者必须已经拥有指定项的特权（或者是数据库管理员）。</p>
<h4 id="Privileges-in-SQL权限"><a href="#Privileges-in-SQL权限" class="headerlink" title="Privileges in SQL权限"></a>Privileges in SQL权限</h4><p>以下为<font color="red"><strong>特权本身的名字</strong></font>，类似关键字。</p>
<p>​	<strong>select</strong>：允许对关系进行读取访问，或使用视图进行查询的能力</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">grant</span> <span class="token keyword">select</span> <span class="token keyword">on</span> branch <span class="token keyword">to</span> U1<span class="token punctuation">,</span> U2<span class="token punctuation">,</span> U3 
<span class="token comment"># 授予用户 U1、U2 和 U3 在分支关系上select的权限</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>​	<strong>insert</strong>: 插入元组的能力</p>
<p>​	<strong>update</strong>: 使用 SQL 更新语句进行更新的功能</p>
<p>​	<strong>delete</strong>: 删除元组的能力。</p>
<p>​	<strong>all privileges</strong>: 用作所有允许权限的缩写形式</p>
<h4 id="Revoking-Authorization-in-SQL撤销授权"><a href="#Revoking-Authorization-in-SQL撤销授权" class="headerlink" title="Revoking Authorization in SQL撤销授权"></a>Revoking Authorization in SQL撤销授权</h4><p>​	<strong>revoke</strong>语句用于撤销授权</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">revoke</span> <span class="token operator">&lt;</span>privilege list<span class="token operator">&gt;</span>
<span class="token keyword">on</span> <span class="token operator">&lt;</span>relation name <span class="token operator">or</span> <span class="token keyword">view</span> name<span class="token operator">&gt;</span> 
<span class="token keyword">from</span> <span class="token operator">&lt;</span><span class="token keyword">user</span> list<span class="token operator">&gt;</span>

<span class="token keyword">revoke</span> <span class="token keyword">select</span> <span class="token keyword">on</span> branch  <span class="token keyword">from</span> U1<span class="token punctuation">,</span> U2<span class="token punctuation">,</span> U3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​	如果同一权限由不同的grantees(有权利授权的人)授予同一用户两次，则该用户可以在撤销（revocation）后保留该权限。 依赖于要撤消的权限的所有权限也将被撤消。</p>
<p>​	当A给B权限，B给C权限；当B被A撤销权限，C同时也被撤销（是符合常理、现实生活的）</p>
<h3 id="4-4Embedded-SQL嵌入式"><a href="#4-4Embedded-SQL嵌入式" class="headerlink" title="4.4Embedded SQL嵌入式"></a>4.4Embedded SQL嵌入式</h3><p>​	此部分用的较少，大多数通过封装实现操作数据库。</p>
<p>​	SQL 标准定义了 SQL 在各种编程语言（如 C、Java 和 Cobol）中的嵌入。</p>
<p>​	嵌入SQL查询的语言称为主语言（<strong>host language</strong>），并且主语言中允许的SQL结构包括嵌入式SQL。</p>
<p><strong>EXEC SQL</strong>语句用于标识对预处理器（preprocessor）的嵌入式SQL请求。</p>
<blockquote>
<p>C语言示例：</p>
<p>​	EXEC SQL</p>
<p>​	<embedded sql statement></embedded></p>
<p>​	END_EXEC</p>
<p>注：语句规范因语言而异，eg.Java：#SQL { …. }; </p>
</blockquote>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># eg 从主语言中，查找某个帐户中金额超过可变金额的客户的姓名和城市。</span>
<span class="token keyword">EXEC</span> <span class="token keyword">SQL</span>
	<span class="token keyword">declare</span> c <span class="token keyword">cursor</span> <span class="token keyword">for</span> <span class="token comment"># 声明游标（cursor游标），相当于一块缓冲区</span>
	<span class="token keyword">select</span> depositor<span class="token punctuation">.</span>customer_name<span class="token punctuation">,</span> customer_city
	<span class="token keyword">from</span> depositor<span class="token punctuation">,</span> customer<span class="token punctuation">,</span> account
	<span class="token keyword">where</span> depositor<span class="token punctuation">.</span>customer_name<span class="token operator">=</span>customer<span class="token punctuation">.</span>customer_name
		<span class="token operator">and</span> depositor account_number<span class="token operator">=</span>account<span class="token punctuation">.</span>account_number
		<span class="token operator">and</span> account<span class="token punctuation">.</span>balance <span class="token operator">&gt;</span> :amount <span class="token comment"># 加“:”的后面表示amount为诸语言中的变量；如果不加“:”则默认认为amount是SQL中的列名/表名</span>
END_EXEC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="在嵌入式中使用cursor（游标）"><a href="#在嵌入式中使用cursor（游标）" class="headerlink" title="在嵌入式中使用cursor（游标）"></a>在嵌入式中使用cursor（游标）</h4><p>注意：以下细节因语言而异。 例如，Java 嵌入定义了 Java 迭代器来单步执行结果元组。</p>
<h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><ol>
<li>使用<strong>declare</strong>声明游标（缓冲区）</li>
</ol>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXEC</span> <span class="token keyword">SQL</span>
	<span class="token keyword">declare</span> c <span class="token keyword">cursor</span> <span class="token keyword">for</span> <span class="token comment"># C为游标名称</span>
	<span class="token punctuation">(</span>一个<span class="token keyword">select</span>查询语句<span class="token punctuation">)</span>
END_EXEC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li><p>使用<strong>open</strong>语句执行查询</p>
<p>注：相当于执行一遍声明部分下面的select语句</p>
</li>
</ol>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXEC</span> <span class="token keyword">SQL</span> 
	<span class="token keyword">open</span> c 
END_EXEC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li><p>使用<strong>fetch</strong>语句取出缓冲区的数据</p>
<p>注：取缓冲区的数据是一行一行取的，执行一次相当于游标自动加一指向下一行。</p>
</li>
</ol>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXEC</span> <span class="token keyword">SQL</span> 
	<span class="token keyword">fetch</span> c <span class="token keyword">into</span> :cn<span class="token punctuation">,</span> :cc 
END_EXEC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ol start="4">
<li><p>使用<strong>close</strong> 语句释放缓冲区</p>
<p>注：关闭后数据清空，缓冲区释放。</p>
</li>
</ol>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXEC</span> <span class="token keyword">SQL</span> 
	<span class="token keyword">close</span> c 
END_EXEC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>（来源百度百科）<strong>SQLCA（SQL Communication Access</strong>,会被传递到需要与<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8">数据库服务器</a>进行通信的所有数据库<a href="https://baike.baidu.com/item/%E5%BA%93%E5%87%BD%E6%95%B0">库函数</a>中。它会在所有嵌入式 SQL 语句上被隐式传递。</p>
<p>可以将SQLCA看成一个结构体，里边有很多属性SQLSTATE是其中一个，设置为”02000”，以指示没有更多可用数据</p>
<h4 id="通过游标更改Updates-Through-Cursors："><a href="#通过游标更改Updates-Through-Cursors：" class="headerlink" title="通过游标更改Updates Through Cursors："></a>通过游标更改Updates Through Cursors：</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">declare</span> c <span class="token keyword">cursor</span> <span class="token keyword">for</span>
    <span class="token keyword">select</span> <span class="token operator">*</span>
    <span class="token keyword">from</span> account
    <span class="token keyword">where</span> branch_name <span class="token operator">=</span> ‘Perryridge’
<span class="token keyword">for</span> <span class="token keyword">update</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-5Dynamic-SQL"><a href="#4-5Dynamic-SQL" class="headerlink" title="4.5Dynamic SQL"></a>4.5Dynamic SQL</h3><p>允许程序在运行时构造和提交 SQL 查询。</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 在 C 程序中使用动态 SQL 的示例。</span>
<span class="token keyword">char</span> <span class="token operator">*</span>  sqlprog <span class="token operator">=</span> “<span class="token keyword">update</span> account
    <span class="token keyword">set</span> balance <span class="token operator">=</span> balance <span class="token operator">*</span> <span class="token number">1.05</span>
    <span class="token keyword">where</span> account_number <span class="token operator">=</span> ?” <span class="token comment"># "?"为占位符</span>
<span class="token keyword">EXEC</span> <span class="token keyword">SQL</span> <span class="token keyword">prepare</span> dynprog  <span class="token keyword">from</span> :sqlprog<span class="token punctuation">;</span>
<span class="token keyword">char</span> account <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> “A<span class="token operator">-</span><span class="token number">101</span>”<span class="token punctuation">;</span>
<span class="token keyword">EXEC</span> <span class="token keyword">SQL</span> <span class="token keyword">execute</span> dynprog <span class="token keyword">using</span> :account<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>动态 SQL 程序包含一个<strong>”?“</strong>，它是执行 SQL 程序时提供的值的占位符</p>
<h3 id="4-6ODBC-and-JDBC"><a href="#4-6ODBC-and-JDBC" class="headerlink" title="4.6ODBC and JDBC"></a>4.6ODBC and JDBC</h3><p><a href="https://www.php.cn/mysql-tutorials-414951.html">这部分PPT无，但是感觉这个很详细可参考</a></p>
<h2 id="第五章Entity-Relationship-Mode实体-联系模型"><a href="#第五章Entity-Relationship-Mode实体-联系模型" class="headerlink" title="第五章Entity-Relationship Mode实体-联系模型"></a>第五章Entity-Relationship Mode实体-联系模型</h2><h3 id="5-1Modeling"><a href="#5-1Modeling" class="headerlink" title="5.1Modeling"></a>5.1Modeling</h3><p>数据库可以建模为： 1.实体（entities）的集合，2.实体之间的关系</p>
<p>实体<strong>entity</strong>是存在且可与其他对象区分开来的对象。 </p>
<p>实体集<strong>entity set</strong> 是相同类型即具有相同性质（或属性）的一个实体集合。</p>
<p>实体由一组属性<strong>attributes</strong>表示，属性是实体集的每个成员所拥有的描述性性质。</p>
<h4 id="Relationship-Sets"><a href="#Relationship-Sets" class="headerlink" title="Relationship Sets**"></a>Relationship Sets**</h4><p>关系是多个实体之间的关联，联系集（Relationship Sets）是相同类型联系的集合，正规的说，联系集是n≥2个（可能相同的）实体集上的数学关系</p>
<p>如果E1，E2，…，En 是实体集，则关系集 R 是{(<em>e</em>1, <em>e</em>2, … <em>en</em>) | <em>e</em><sub>1</sub> ∈ <em>E</em><sub>1</sub>, <em>e</em><sub>2</sub> ∈<em>E</em><sub>2</sub>, …, <em>e<sub>n</sub></em> ∈ <em>E<sub>n</sub></em>}的一个<strong>子集</strong>，其中(<em>e</em>1, <em>e</em>2, …, <em>e**n</em>) 是一个关系</p>
<p><strong>attribute</strong>也可以是关系集的属性</p>
<h4 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h4><p>每个实体的每个属性都有一个值 </p>
<p>当实体在某个属性上没有值时使用<strong>空null</strong>值。</p>
<p>​	空值可以表示“不适用”（该实体的这个属性不存在值）/表示属性值未知（未知的值可能是缺失的或不知道的）</p>
<p>域<strong>Domain</strong>或值集<strong>value set</strong> – 每个属性都有一个可取值的集合</p>
<p>E-R模型中的属性类型： </p>
<ul>
<li><p>简单和复合属性-<strong>Simple and composite</strong> attributes。 </p>
</li>
<li><p>单值和多值属性–<strong>Single-valued and multi-valued</strong> attributes </p>
</li>
<li><p>派生属性–<strong>Derived</strong> attributes</p>
</li>
</ul>
<h5 id="Simple-and-Composite-Attributes（横向）"><a href="#Simple-and-Composite-Attributes（横向）" class="headerlink" title="Simple and Composite Attributes（横向）"></a>Simple and Composite Attributes（横向）</h5><p>​	<strong>Simple attributes</strong>简单属性：不能划分为更小的部分subparts</p>
<p>​	<strong>Composite attributes</strong>复合属性：可分为更小的部分，子部分叫Component Attributes</p>
<p>​		如果我们在某些情况下引用完整属性，而在其他情况下仅引用属性的一部分，选择复合属性是很好的选择。</p>
<p>​		复合属性可以是有层次的。	复合属性帮助将相关属性组合在一起，使建模更清晰</p>
<h5 id="Single-Valued-and-Multi-Valued-Attributes单值和多值属性（纵向）"><a href="#Single-Valued-and-Multi-Valued-Attributes单值和多值属性（纵向）" class="headerlink" title="Single-Valued and Multi-Valued Attributes单值和多值属性（纵向）"></a>Single-Valued and Multi-Valued Attributes单值和多值属性（纵向）</h5><p>​	<strong>Single-valued attributes</strong>：属性对于一个特定实体都只有单独的一个值</p>
<p>​	<strong>Multi-valued attributes</strong>：对某个特定实体而言，一个属性可能对应于一组值，用{phone-number}表示（用花括号括起来）</p>
<h4 id="Derived-Attributes派生属性"><a href="#Derived-Attributes派生属性" class="headerlink" title="Derived Attributes派生属性"></a>Derived Attributes派生属性</h4><p>​	派生属性的值可以从其他相关属性或实体派生出来。派生属性的值不存储，而是在需要的时候计算出来。</p>
<h4 id="Degree-of-a-Relationship-Set-联系集的度"><a href="#Degree-of-a-Relationship-Set-联系集的度" class="headerlink" title="Degree of a Relationship Set__联系集的度"></a>Degree of a Relationship Set__联系集的度</h4><p>联系集的度<strong>degree</strong>指参与联系集的实体集的数目。 </p>
<p>涉及两个实体集的关系集是<strong>binary</strong>（或degree two）。 （和两个实体相联系）</p>
<p>通常，数据库系统中的大多数关系集都是binary的。</p>
<p>关系集可能涉及两个以上的实体集。 两个以上的实体集之间的关系很少见。 大多数关系都是二元的。</p>
<h3 id="5-2Constraints-约束"><a href="#5-2Constraints-约束" class="headerlink" title="5.2Constraints 约束"></a>5.2Constraints 约束</h3><h4 id="Mapping-Cardinality-Constraints映射基数约束"><a href="#Mapping-Cardinality-Constraints映射基数约束" class="headerlink" title="Mapping Cardinality Constraints映射基数约束"></a>Mapping Cardinality Constraints映射基数约束</h4><p>表示一个实体通过一个联系集能关联的实体的个数</p>
<p>映射基数在描述二元关系集时最有用</p>
<p>对于二元关系集，映射基数必须是以下类型之一： </p>
<ul>
<li><p>一对一<strong>one-to-one</strong> 两个实体集的主码都可以做主码</p>
</li>
<li><p>一对多<strong>one-to-many</strong> many的主码可以做主码</p>
</li>
<li><p>多对一<strong>many-to-one</strong> many的主码可以做主码</p>
</li>
<li><p>多对多<strong>many-to-many</strong> P(A)∪P(B)</p>
</li>
</ul>
<p>注： A和B作为二元关系集中的两个关系，A 和 B 中的某些元素可能不会映射到另一个元素集中的任何元素</p>
<h4 id="Participation-Constraints参与约束"><a href="#Participation-Constraints参与约束" class="headerlink" title="Participation Constraints参与约束"></a>Participation Constraints参与约束</h4><p>实体集之间的关联称为参与。</p>
<p>E 是实体集，R 是关系集</p>
<p>如果 E 中的每个实体都参与 R 中的至少一个联系中 则 E 在 R 中的参与称为全部<strong>total</strong>的</p>
<p>如果 E 中的某些实体仅参与 R 中的关系  则 E 在 R 中的参与称为 部分<strong>partial</strong>的</p>
<h4 id="Keys-for-Relationship-Sets"><a href="#Keys-for-Relationship-Sets" class="headerlink" title="Keys for Relationship Sets"></a>Keys for Relationship Sets</h4><p>联系集的<strong>super key</strong>是一个或多个属性的集合，其值唯一地决定每个实体。 </p>
<p>联系集的<strong>candidate key</strong> 是最小超码</p>
<p>尽管可能存在多个候选码，但选择其中一个候选键作为<strong>primary key</strong>。 应选择主码，使其属性从不更改或很少更改。</p>
<p>设 R 是涉及实体集 E1,E2 ,…En的联系集，联系集 R 中的关系描述如下：</p>
<blockquote>
<p>如果联系集R没有属性与之相关联，那么属性集合</p>
<p>​            Primary-key(E1) ∪ Primary-key(E2) ∪… ∪Primary-key(En)</p>
<p>描述了集合R中的一个联系</p>
<p>如果联系集R有属性a1,a2,…,am与之相关联，那么属性集合</p>
<p>​            Primary-key(E1) ∪ Primary-key(E2) ∪… ∪Primary-key(En)∪{a1,a2,…,am}</p>
<p>​			\———————————————————————————/</p>
<p>​														超码super key（参与实体集的主键组合形成联系集的超码）</p>
<p>主键 （Ei） 表示（denote）构成实体集 E 的主键的属性集</p>
<p>{a1,a2,…an}  是联系集 R 的属性</p>
</blockquote>
<p>eg.（customer_name，account_number）是<em>depositor</em>存款联系的超码</p>
<p>联系集的主码结果依赖于联系集的映射基数。</p>
<p>注意：这意味着一对实体在特定联系集中最多可以有一个关系</p>
<h3 id="5-3E-R-Diagram"><a href="#5-3E-R-Diagram" class="headerlink" title="5.3E-R Diagram"></a>5.3E-R Diagram</h3><p>汇总：书P172 	   pptP81-82</p>
<p>矩形<strong>Rectangles</strong>表示<strong>实体集entity sets</strong>。</p>
<p>菱形<strong>Diamonds</strong>代表<strong>联系集relationship set</strong>。 </p>
<p>线段<strong>Lines</strong>将属性链接到实体集，将实体集链接到联系集。 </p>
<p>椭圆<strong>Ellipses</strong>表示属性<strong>attributes</strong> 双线椭圆<strong>Double ellipses</strong> 表示<strong>多值属性multivalued attributes</strong>。 虚线椭圆<strong>Dashed ellipses</strong> 表示<strong>派生属性derived attributes</strong>。 </p>
<p>下划线<strong>Underline</strong>表示<strong>主码属性primary key attributes</strong></p>
<p>双横线<strong>double line</strong>表示<strong>total</strong>参与</p>
<p>Cardinality Constraints基数约束，通过在关系集和实体集之间，绘制<strong>有向线 （→）</strong>，表示”<strong>一个</strong>“， 一条<strong>无向线 （—）</strong>，表示”<strong>多个</strong>“。</p>
<p>实体在联系中扮演的功能称为实体的<strong>角色（role）</strong>，关系集中涉及的实体集不必是不同的 可以使用角色指定实体如何通过关系集进行交互（同样的实体集可以以不同的角色参与一个联系集多于一次）P35</p>
<p>eg.P37-P41</p>
<p><strong>基数限制的替代表示法Alternative Notation for Cardinality Limits</strong>（常见但不常用）：基数限制也可以表示参与约束，P42（此题表示customer对loan为一对多）左边表示这个实体集于关系的参与度的下限，右边数字表示实体集与这个关系参与度的下限。表示更加精确</p>
<h4 id="E-R-Diagram-with-a-Ternary-Relationship-三元关系"><a href="#E-R-Diagram-with-a-Ternary-Relationship-三元关系" class="headerlink" title="E-R Diagram with a Ternary Relationship 三元关系"></a>E-R Diagram with a Ternary Relationship 三元关系</h4><p>我们最多允许三元ternary（或更大degree）关系中的一个箭头表示基数约束（三元联系最多只能有一个是多）</p>
<p>如果有多个箭头，则有两种方法可以定义含义：A、B 和 C 之间的三元关系 R，箭头指向 B 和 C 可能意味着1. 每个 A 实体都与 B 和 C 中的唯一实体相关联  2. 来自 （A， B） 的每对实体都与一个唯一的 C 实体相关联，并且每对 （A， C） 都与唯一的 B 相关联</p>
<p>为了避免混淆，<strong>禁止使用多个箭头</strong></p>
<h3 id="5-4Design-Issues-设计问题"><a href="#5-4Design-Issues-设计问题" class="headerlink" title="5.4Design Issues 设计问题"></a>5.4Design Issues 设计问题</h3><p>使用实体集<strong>entity sets</strong> 还是属性<strong>attributes</strong>：选择主要取决于被建模企业的结构，以及与所讨论属性相关的语义</p>
<h4 id="使用实体集or联系集"><a href="#使用实体集or联系集" class="headerlink" title="使用实体集or联系集"></a>使用实体集or联系集</h4><p>准则（guideline）：指定（designate）一个关系集来描述实体之间发生的操作（当描述发生在实体间的行为时采用联系集）</p>
<p>不要将一个实体集的主键用作另一个实体集的属性P47</p>
<p>不要将相关实体集的主键属性指定(designate)为关系集的属性（已隐式在中）P48</p>
<p>二元与 n 元关系集：</p>
<ul>
<li><p>尽管可以使用许多不同的二元关系集来替换非二元（n元，对于 n &gt; 2）关系，但 n元关系集更清楚地表明，多个实体参与单个关系。</p>
</li>
<li><p>某些看似非二元的关系可能使用二元关系更好地表示 。三元关系父母，将孩子与他/她的父亲和母亲联系起来，最好用两个二元关系，父亲和母亲代替 使用两个二元关系允许部分信息（例如，只知道母亲）P52-54</p>
</li>
</ul>
<h4 id="二元联系集or-n元联系集Converting-Non-Binary-Relationships-to-Binary-Form"><a href="#二元联系集or-n元联系集Converting-Non-Binary-Relationships-to-Binary-Form" class="headerlink" title="二元联系集or n元联系集Converting Non-Binary Relationships to Binary Form"></a>二元联系集or n元联系集Converting Non-Binary Relationships to Binary Form</h4><p>通常，任何非二元关系都可以通过创建人工实体集来使用二元关系来表示P56</p>
<p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110150800830.png"></p>
<p>转换的缺点：</p>
<ul>
<li><p>可能必须为表示联系集的实体集创建标识（identifying）属性</p>
</li>
<li><p>n元联系集可以更清楚地表示几个实体集参与单个联系集</p>
</li>
<li><p>可能无法将三元联系上的约束转换为二元联系上的约束</p>
</li>
</ul>
<h4 id="联系属性的布局Placement-of-relationship-attributes"><a href="#联系属性的布局Placement-of-relationship-attributes" class="headerlink" title="联系属性的布局Placement of relationship attributes"></a>联系属性的布局Placement of relationship attributes</h4><p>如果每个帐户只能有一个客户，则可以使访问日期成为帐户的属性，而不是关系属性</p>
<p>（也就是说，从帐户到客户的关系是多对一的，或者等效地，客户到帐户的关系是一对多</p>
<p><strong>一对多</strong>关系集的属性可以被重新定位到“多”侧的实体集。</p>
<p>对于<strong>一对一</strong>关系集，另一方面，可以放置在任意一侧。</p>
<p>对于<strong>多对多</strong>关系，关系集的属性只能放在关系集上</p>
<h3 id="5-5Weak-Entity-Sets弱实体集"><a href="#5-5Weak-Entity-Sets弱实体集" class="headerlink" title="5.5Weak Entity Sets弱实体集"></a>5.5Weak Entity Sets弱实体集</h3><p>没有足够的属性以形成主码的实体集称为弱实体集<strong>weak entity set</strong>。</p>
<p>弱实体集的存在依赖于<strong>标识实体集Identifying Entity Set</strong>或<strong>属主实体集owner entity set</strong>的存在：</p>
<ul>
<li>必须通过一个<strong>全部参与total</strong>，<strong>一对多one-to-many</strong>，的关系来与弱实体集相关联</li>
<li>这个标识关系(<strong>Identifying relationship</strong>)（关联弱实体集和标识性强实体集的联系集）使用<strong>双线菱形double diamond</strong>在ER图中表示。</li>
</ul>
<p>弱实体集的分辨符（<strong>discriminator</strong>）（或部分码<strong>partial key</strong>）是一组属性，用于区分弱实体集的所有实体，这些实体与标识实体集的同一实体相关。</p>
<p>弱实体集的主键由(弱实体集的存在所依赖的强实体集的主键)加上(弱实体集的鉴别器)构成</p>
<p>使用<strong>双矩形double rectangles</strong>来表示弱实体。 我们用<strong>虚线dashed line</strong>强调弱实体集的<strong>鉴别器discriminator</strong>。</p>
<h3 id="5-6Extended-E-R-Features扩展的E-R特性"><a href="#5-6Extended-E-R-Features扩展的E-R特性" class="headerlink" title="5.6Extended E-R Features扩展的E-R特性"></a>5.6Extended E-R Features扩展的E-R特性</h3><p><a href="https://www.cnblogs.com/RDaneelOlivaw/p/8215224.html">参考（和书上顺序差不多例子也相同，但符号不可借鉴）</a></p>
<p><strong>特化</strong>和<strong>概化</strong>定义了一个高层实体集和一个或多个低层实体集之间的包含关系。特化是取出高层实体集的一个子集来形成一个低层实体集。概化是用两个或多个不想交的（低层）实体集的并集形成一个高层实体集。高层实体集的属性被低层实体集继承。</p>
<h4 id="Specialization特化-在实体集内部进行分组的过程。"><a href="#Specialization特化-在实体集内部进行分组的过程。" class="headerlink" title="Specialization特化(在实体集内部进行分组的过程。)"></a>Specialization特化(在实体集内部进行分组的过程。)</h4><p><strong>自顶向下</strong>的设计过程<strong>Top-down design process</strong>：我们在实体集中指定与集合中其他实体不同的子分组 这些子分组将成为较低级别的实体集。这些实体集具有不适用于较高级别实体集的属性或参与的关系。</p>
<p>由标记为 <strong>ISA 的三角形组件</strong>表示（例如，客户”是”人）。P67（考试这么写）</p>
<p>高层和低层实体集按普通实体集表示。书上P167（不是用ISA表示的，考试打灭）</p>
<h4 id="Generalization概化"><a href="#Generalization概化" class="headerlink" title="Generalization概化"></a>Generalization概化</h4><p><strong>自底向上</strong>的设计过程<strong>A bottom-up design process</strong> – 将共享相同功能的多个实体集合并到更高级别的实体集中。 专业化和普遍化是彼此的简单反转;它们以相同的方式在E-R图中表示</p>
<p>术语”专业化”和”泛化”可互换(interchangeably)使用</p>
<p>可以基于不同的功能对实体集进行多个特化。</p>
<p>高层与低层实体集也分别称作<strong>超类（superclass）和子类（subclass）</strong>。</p>
<p>ISA 关系也称为超类-子类（<strong>superclass - subclass</strong>）关系</p>
<p>特化和概化的区别在于出发点和总体目标：</p>
<ul>
<li><p>特化：从单一实体集出发，通过创建不同的低层实体集来强调同一实体集中不同实体间的差异。低层实体集可以有不适用于高层实体集中所有实体的属性，也可以参与到不适用于高层实体集中所有实体集的联系中。</p>
</li>
<li><p>概化：基于“一定数量的实体集共享一些共同特征（用相同的属性描述，且参与到相同的联系集中）”。在这些实体集共性的基础上将它们总和成一个高层实体集，用于强调低层实体集间的相似性并隐藏差异。(概化使共享属性不重复出现，表达简洁。)</p>
</li>
</ul>
<h4 id="属性继承Attribute-inheritance"><a href="#属性继承Attribute-inheritance" class="headerlink" title="属性继承Attribute inheritance"></a>属性继承<strong>Attribute inheritance</strong></h4><p>较低级别的实体集继承它所链接到的较高级别实体集的所有属性和参与的。</p>
<p>在实体集的层次结构中：</p>
<p>​	如果一个实体集作为低层实体集只参与到一个ISA联系中，则称这个实体集只具有<strong>单继承（single inheritance）</strong>；</p>
<p>​	如果一个实体集作为低层实体集参与到多个ISA联系中，则称这个实体集具有<strong>多继承（multiple inheritance）</strong>，且产生的结构称为<strong>格（lattice）</strong>。</p>
<h4 id="Design-Constraints-on-a-Specialization-x2F-Generalization对特化-x2F-概化的设计约束"><a href="#Design-Constraints-on-a-Specialization-x2F-Generalization对特化-x2F-概化的设计约束" class="headerlink" title="Design Constraints on a Specialization/Generalization对特化/概化的设计约束"></a>Design Constraints on a Specialization/Generalization对特化/概化的设计约束</h4><p><font color="blue">对概化的</font>：</p>
<ol>
<li>涉及”<strong>判定哪些实体能成为给定低层实体集的成员</strong>”的约束。成员资格可以是下列其中一种：</li>
</ol>
<p>​	<strong>条件定义的（condition-defined）</strong>：在条件定义的低层实体集中，成员资格的确定基于实体是否满足一个显式的条件或谓词。</p>
<p>​				e.g.设高层实体集student具有属性student_type，所有student实体都根据student_type属性进行评估；满足条件student_type=”graduate”的实体属于graduate低层实体集；满足条件student_type=”undergraduate”的实体属于undergraduate低层实体集。</p>
<p>​	<strong>用户定义的（user-defined）</strong>：在用户定义的低层实体集中，由数据库用户将实体指派给某个实体集。（负责决策的用户根据个人观点进行分配，执行将一个实体加入某个实体集的操作。）</p>
<ol start="2">
<li>涉及”<strong>在一个<font color="red">概化</font>中一个实体是否可以属于多个实体集</strong>“的约束。低层实体集可以是下列其中一种：</li>
</ol>
<p>​	<strong>不相交（disjoint）</strong>：要求一个实体至多属于一个低层实体集。在 E-R 图中通过在 ISA 三角形旁边书写disjoint来注明</p>
<p>​	<strong>重叠（overlapping）</strong>：同一实体可以同时属于同一概化中的多个实体集。使用分开的箭头表示重叠概化，单个箭头表示不相交概化。e.g一个person可以既是employee又是student，使用分开的箭头表示重叠概化。一个箭头从employee指向person，一个箭头从student指向person；一个employee不能既是instructor</p>
<ol start="3">
<li>对概化的<strong>完全性约束（completeness constraint）</strong>。定义高层实体集中的一个实体是否必须至少属于该概化/特化的一个低层实体集。此类约束可以是下列其中之一：</li>
</ol>
<p>​	<strong>全部概化（total generalization</strong>）或特化（<strong>specialization</strong>）：每个高层实体必须属于一个低层实体集。</p>
<p>​	<strong>部分概化（partial generalization</strong>）或特化（<strong>specialization</strong>）：允许一些高层实体不属于任何低层实体集。</p>
<p>默认情况下为部分概化。如果需要表示全部概化，可在E-R图中加入关键词total，并画一条从关键词到相应空心箭头（表示不相交概化）的虚线，或画一条到空心箭头集合（表示重叠概化）的虚线。</p>
<p>完全性约束和不相交约束彼此没有依赖关系。约束模式也可以是部分-不相交或全部-重叠的。</p>
<p>对给定概化或特化使用约束带来某些插入和删除需求。又是secretary，使用单个箭头表示不相交概化，从instructor和secretary指向employee。</p>
<p><font color="blue">对特化的：</font>：</p>
<p>​	<strong>重叠特化（overlapping specialization）：</strong>一个实体集可能属于多个特化实体集。</p>
<p>​	<strong>不相交特化（disjoint specialization）：</strong>一个实体集至多属于一个特化实体集。</p>
<h4 id="Aggregation聚集"><a href="#Aggregation聚集" class="headerlink" title="Aggregation聚集"></a>Aggregation聚集</h4><p>E-R模型的一个局限性在于它不能表达联系间的联系。</p>
<p><strong>聚集（aggregation）：</strong>将联系视为高层实体的一种抽象。高层实体集可像对任何其他实体集一样处理。</p>
<p>可以通过聚合消除冗余。将关系视为抽象实体，允许关系抽象为新实体。</p>
<p>聚集的主码定义该聚集的联系集的主码，不需要单独的关系来表示聚集</p>
<h3 id="5-7Design-of-the-Bank-Database"><a href="#5-7Design-of-the-Bank-Database" class="headerlink" title="5.7Design of the Bank Database"></a>5.7Design of the Bank Database</h3><p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110150823160.png"></p>
<h4 id="E-R-Design-Decisions设计过程需要考虑的："><a href="#E-R-Design-Decisions设计过程需要考虑的：" class="headerlink" title="E-R Design Decisions设计过程需要考虑的："></a>E-R Design Decisions设计过程需要考虑的：</h4><p>使用<strong>属性or实体集</strong>来表示对象</p>
<p>现实世界的概念来讲用<strong>实体集or关系集</strong></p>
<p>使用<strong>三元关系or一对二元关系</strong></p>
<p><strong>强实体集or弱实体集</strong></p>
<p>用<strong>特化/概化</strong>（有助于设计的模块化）</p>
<p>使用<strong>聚合</strong>？（可以将聚合实体集视为单个单元，而不必担心其内部结构的细节）</p>
<h3 id="5-8Reduction-to-Relation-Schemas转换为关系模式"><a href="#5-8Reduction-to-Relation-Schemas转换为关系模式" class="headerlink" title="5.8Reduction to Relation Schemas转换为关系模式"></a>5.8Reduction to Relation Schemas转换为关系模式</h3><p><a href="https://www.cnblogs.com/yijiahao/p/11707183.html">E-R图转换为关系模型</a></p>
<p>主键允许实体集和联系集统一（uniformly）表示为表示数据库内容(content)的关系模式<strong>Relation Schemas</strong>。 </p>
<p>符合 E-R 关系图的数据库可以由模式的集合表示。</p>
<p>对于每个实体集和关系集，都有一个唯一的模式，该模式被分配了相应实体集或关系集的名称。 </p>
<p>每个模式都有许多列（通常对应于属性），这些列具有唯一的名称。</p>
<h4 id="将实体集表示为模式"><a href="#将实体集表示为模式" class="headerlink" title="将实体集表示为模式"></a>将实体集表示为模式</h4><p>强实体集将简化为具有相同属性的架构。 弱实体集将成为一个表，其中包含标识强实体集的主键列</p>
<ul>
<li>复合属性：为每个子属性创建一个单独的属性，不为复合属性自身创建创建一个单独的属性。</li>
<li>多值属性：创建新的关系模式来存储多值属性，并为这个关系构建外码约束。</li>
<li>派生属性：不在关系数据模型中显示达的表示出来。</li>
</ul>
<p>弱实体集将成为一个表，其中包含标识强实体集的主键列</p>
<h4 id="将联系集表示为模式"><a href="#将联系集表示为模式" class="headerlink" title="将联系集表示为模式"></a>将联系集表示为模式</h4><p>多对多关系集表示为一个模式，其中包含两个参与实体集的主码的属性以及关系集的所有描述性属性。</p>
<p>多对一和一对多的联系集可以通过向”多”端添加一个额外的属性来表示，其中包含”一”端的主键</p>
<p>对于一对一关系集，可以选择任何一方作为”多”方 （可以将额外的属性添加到与两个实体集对应的任意一个表中）</p>
<h4 id="模式的冗余Redundancy-of-Schemas"><a href="#模式的冗余Redundancy-of-Schemas" class="headerlink" title="模式的冗余Redundancy of Schemas"></a>模式的冗余Redundancy of Schemas</h4><p>如果<strong>participation</strong>在”<strong>many</strong>“端是<strong>partial</strong>，则将模式替换为与”许多”端对应的模式中的额外属性可能会导致空值<strong>null</strong></p>
<p>连接弱实体集与其所依赖的强实体集的联系集的模式是冗余的。</p>
<h3 id="5-9Database-Design"><a href="#5-9Database-Design" class="headerlink" title="5.9Database Design"></a>5.9Database Design</h3><h3 id="将特化表示为模式Representing-Specialization-as-Schemas"><a href="#将特化表示为模式Representing-Specialization-as-Schemas" class="headerlink" title="将特化表示为模式Representing Specialization as Schemas"></a>将特化表示为模式Representing Specialization as Schemas</h3><p>方法一：让高层实体形成一个模式。为每个低层实体集形成一个模式，包括较高级别的实体集的主键和本地属性。</p>
<p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110150840457.png"></p>
<p>缺点：想要获取低层实体信息，需要访问两个关系，一个对应于低级模式，另一个对应于高级模式。</p>
<p>方法二：为每一个实体集形成一个模式，其中包含所有的本地属性和继承属性。</p>
<p>如果特化是全部的，那么概化实体集的模式不需要存储信息，可以定义为包含特化关系并集的”视图“关系。但是外键约束可能仍然需要显示模式（explicit schema ）</p>
<p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110150853054.png"></p>
<p>缺点：street和city可能会冗余的存储给即是customer又是employee的人。</p>
<h4 id="与聚合相对应的模式Schemas-Corresponding-to-Aggregation"><a href="#与聚合相对应的模式Schemas-Corresponding-to-Aggregation" class="headerlink" title="与聚合相对应的模式Schemas Corresponding to Aggregation"></a>与聚合相对应的模式Schemas Corresponding to Aggregation</h4><p>若想要表示聚合，需要创建一个包含聚合联系的主键、联系实体集的主键和所有描述性属性的模式。</p>
<h2 id="第六章-Relational-Database-Design关系数据库设计"><a href="#第六章-Relational-Database-Design关系数据库设计" class="headerlink" title="第六章 Relational Database Design关系数据库设计"></a>第六章 Relational Database Design关系数据库设计</h2><h3 id="6-1Features-of-Good-Relational-Design好的关系设计的特点"><a href="#6-1Features-of-Good-Relational-Design好的关系设计的特点" class="headerlink" title="6.1Features of Good Relational Design好的关系设计的特点"></a>6.1Features of Good Relational Design好的关系设计的特点</h3><p>银行的模式</p>
<p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110150906107.png"></p>
<h4 id="设计选择-更小的模式smaller-schemas"><a href="#设计选择-更小的模式smaller-schemas" class="headerlink" title="设计选择-更小的模式smaller schemas"></a>设计选择-更小的模式smaller schemas</h4><p>PPT4-6  在bor_loan中，由于loan_number不是候选码，因此贷款金额可能必须重复。 这表明需要分解bor_loan。</p>
<p>并非所有的分解都是好的。</p>
<p>有损分解<strong>lossy decomposition</strong>PPT7</p>
<p>无损分解<strong>lossless decomposition</strong>：分解后的关系自然连接等于原来的关系  PPT7-9  书P183</p>
<h3 id="6-2Atomic-Domains-and-First-Normal-Form原子域和第一范式"><a href="#6-2Atomic-Domains-and-First-Normal-Form原子域和第一范式" class="headerlink" title="6.2Atomic Domains and First Normal Form原子域和第一范式"></a>6.2Atomic Domains and First Normal Form原子域和第一范式</h3><p>一个域是<strong>原子的（atomic）</strong>，如果该域的元素被认为是不可分的单元。如果关系模式R的所有属性的域都是原子的，则关系模式R属于<strong>第一范式（First Normal Form,1NF）</strong></p>
<p>非原子值使<strong>存储复杂化complicate storage</strong>，并鼓励<strong>冗余redundant</strong>（重复）存储数据</p>
<p>原子性<strong>Atomicity</strong>实际上是如何使用域元素的属性==？？？PPT P12==</p>
<p>导致在应用程序中而不是在数据库中对信息进行编码是不好的（在应用程序中拆分而不是在数据库中拆分是不好的）。</p>
<h4 id="Goal-—-Devise-a-Theory-for-the-Following目标：为以下方面制定理论"><a href="#Goal-—-Devise-a-Theory-for-the-Following目标：为以下方面制定理论" class="headerlink" title="Goal — Devise a Theory for the Following目标：为以下方面制定理论"></a>Goal — Devise a Theory for the Following目标：为以下方面制定理论</h4><p>确定特定关系R是否为”good“形式</p>
<p>如果关系R不是”good“形式，就把关系R分解为一组关系{<em>R</em>1*, R<em>2</em>, …, Rn*}且满足	1.每个关系都是good形式	2.分解是无损连接分解<strong>lossless-join decomposition</strong></p>
<p>我们的理论基于： 功能依赖关系<strong>functional dependencies</strong> 	多值依赖关系<strong>multivalued dependencies</strong></p>
<h3 id="6-3Decomposition-Using-Functional-Dependencies使用函数依赖进行分解"><a href="#6-3Decomposition-Using-Functional-Dependencies使用函数依赖进行分解" class="headerlink" title="6.3Decomposition Using Functional Dependencies使用函数依赖进行分解"></a>6.3Decomposition Using Functional Dependencies使用函数依赖进行分解</h3><h4 id="functional-dependency函数依赖"><a href="#functional-dependency函数依赖" class="headerlink" title="functional dependency函数依赖"></a>functional dependency函数依赖</h4><p>对合法关系集的约束Constraints。 </p>
<p>要求某一组属性的值唯一确定另一组属性的值。 </p>
<p>函数依赖关系是key概念（notion）的推广（generalization）。</p>
<p>（书上）令r(R)是一个关系模式。R的子集K是r(R)的超码（superkey）的条件是：在关系r(R)的任意合法实例中，对于r的实例中的所有元组对t<sub>1</sub>和t<sub>2</sub>总满足，若t<sub>1</sub>≠t<sub>2</sub>，则t<sub>1</sub>[K] ≠ t<sub>2</sub>[K]，也就是说，在关系r(R)的任意合法实例中没有两条元组在属性集K上可能具有相同的值。</p>
<p>（书上/PPT16）鉴于超码是能够唯一标识整条元组的属性集，函数依赖让我们可以表达唯一标识某些属性的值的约束。考虑一个关系模式r(R)，令a ⊆ R 且 b ⊆ R.</p>
<ul>
<li>给定r(R)的一个实例，我们说这个示例<strong>满足（satisfy）函数依赖</strong> α → β 的条件是：对实例中所有的元组对t<sub>1</sub>和t<sub>2</sub>，若t<sub>1</sub>[α] = t<sub>2</sub>[α]，则t<sub>1</sub>[β] = t<sub>2</sub>[β]</li>
<li>如果在r(R)的每个合法实例中都满足函数依赖 α → β ，则我们说该函数依赖在模式r(R)上<strong>成立（hold）</strong></li>
</ul>
<p>K是关系模式R的的超码<font color="red">⇔ </font>K→R</p>
<p>K是关系模式R的的候选码<font color="red">⇔</font> K→R 并且不存在 α ⊂K, α→ R</p>
<p>函数依赖使我们可以表示无法使用超码表达的约束。PPT19</p>
<p>以两种方式使用函数依赖： </p>
<ul>
<li>判定关系的实例是否满足给定函数依赖集F。 如果关系 r 在函数依赖关系的集合 F 下是合法的，我们说 <strong>r 满足satisfies F</strong>。 </li>
<li>说明合法关系集上的约束。因此，我们将只关心满足给定函数依赖集的那些关系实例。如果我们希望只考虑模式R上满足就桉树以来即F的关系，我们说F在r(R)上成立<strong>hold</strong>。</li>
</ul>
<p>注： 关系架构的特定实例(<strong>specific instance</strong>)可能满足函数依赖关系，即使函数依赖关系并非在所有合法实例上都成立。</p>
<p>有些函数依赖称为<strong>平凡的trivial</strong>，因为它们在所有关系中都满足。通常，如果 β ⊆ α ，那么α → β是平凡的。</p>
<h4 id="6-3-1Boyce-Codd-Normal-Form-Boyce-Codd-x2F-BCNF范式"><a href="#6-3-1Boyce-Codd-Normal-Form-Boyce-Codd-x2F-BCNF范式" class="headerlink" title="6.3.1Boyce-Codd Normal Form Boyce-Codd/BCNF范式"></a>6.3.1Boyce-Codd Normal Form Boyce-Codd/BCNF范式</h4><p>具有函数依赖集F的关系模式R属于BCNF的条件是，对F<sup>+</sup>中所有形如α → β的函数依赖（其中 β ⊆ R， α ⊆ R）,下面至少有一项成立：</p>
<ol>
<li>α → β是平凡的函数依赖（即 β ⊆ α）<del>不咋用</del></li>
<li>α 是模式R的一个超码</li>
</ol>
<p>注：按照定义来看，任何只包含两个属性的模式都属于BCNF</p>
<h5 id="Decomposing-a-Schema-into-BCNF将模式分解为BCNF"><a href="#Decomposing-a-Schema-into-BCNF将模式分解为BCNF" class="headerlink" title="Decomposing a Schema into BCNF将模式分解为BCNF"></a>Decomposing a Schema into BCNF将模式分解为BCNF</h5><p>分解的一般规则：设R为不属于BCNF的一个模式。则存在至少一个非平凡的函数依赖α → β，其中α 不是R的超码，我们在设计中将R分解为：1. （α ∪ β） 2.（R- ( β - α ) )</p>
<h5 id="BCNF和保持依赖BCNF-and-Dependency-Preservation"><a href="#BCNF和保持依赖BCNF-and-Dependency-Preservation" class="headerlink" title="BCNF和保持依赖BCNF and Dependency Preservation"></a>BCNF和保持依赖BCNF and Dependency Preservation</h5><p>约束<strong>constraints</strong>（包括函数依赖关系）在实践中检查成本高昂，除非它们<strong>仅与一个</strong>关系相关</p>
<p>有些情况下到BCNF的分解会妨碍对某些函数依赖的高效检查</p>
<p>并不能总是同时实现BCNF和保持依赖，所以考虑第三范式</p>
<h5 id="Testing-for-BCNF检验"><a href="#Testing-for-BCNF检验" class="headerlink" title="Testing for BCNF检验"></a>Testing for BCNF检验</h5><p>方法一：检查非平凡的依赖项α → β是否违反BCNF	1.计算α <sup>+</sup>（α 的属性闭包）	2.验证他是否包含R的所有属性，即它是R的超码。</p>
<p>方法二（简化的）：检查关系模式R是否属于BCNF，检查给定集合F中的函数依赖是否违反BCNF就足够了，而不是检查F<sup>+</sup>中的所有依赖项：如果F中没有一个函数依赖违反BCNF，则F<sup>+</sup>中的任何依赖项也不会违反BCNF</p>
<p>但是方法二中，在R分解中测试关系时，只是用F是不正确的，例子在PPT p67</p>
<h4 id="6-3-2Third-Normal-Form-3NF-第三范式"><a href="#6-3-2Third-Normal-Form-3NF-第三范式" class="headerlink" title="6.3.2Third Normal Form(3NF)第三范式"></a>6.3.2Third Normal Form(3NF)第三范式</h4><p>具有函数依赖集F的关系模式R属于<strong>第三范式（3NF）</strong>的条件是：对于F<sup>+</sup>中所有形如 α → β 的函数依赖（其中其中 β ⊆ R， α ⊆ R），以下至少一项成立：</p>
<ol>
<li>α → β是一个平凡的函数依赖（即 β ⊆ α）</li>
<li>α 是模式R的一个超码</li>
<li>β - α 中的每个属性A都包含于R的一个候选码中。（注：β - α中的每个属性A可能包含于<strong>不同的</strong>候选码中）</li>
</ol>
<p>任何满足BCNF 的模式都满足3NF，所以BCNF是比3NF更严格的范式。</p>
<p><strong>动机motivation</strong>：有些情况下，BCNF不是保留依赖的，在更新时有效检查函数依赖的冲突是非常重要的。</p>
<p>第三范式为一个较弱的范式，称为第三范式，允许一些冗余（也会产生一些问题），但是可以在不计算连接的情况下在单个关系上检查函数依赖关系，并且在3NF中总是<strong>无损连接lossless-join和保持依赖dependency preserving</strong>的。</p>
<h5 id="Testing-for-3NF"><a href="#Testing-for-3NF" class="headerlink" title="Testing for 3NF"></a>Testing for 3NF</h5><p>优化：只需要检查F中的函数依赖，不需要检查F<sup>+</sup>中的所有函数依赖。</p>
<ol>
<li>如果α为超码，则使用属性闭包检查每个依赖项</li>
<li>如果α不是超码，我们必须验证在β中的每个属性是否都包含在R的候选码中。（此测试很昂贵，因为涉及查找候选码）==3NF 检测已被证明是 NP-hard ppt 77==。有趣的是，分解成第三范式（稍后描述）可以在多项式时间(polynomial time)内完成。</li>
</ol>
<h3 id="6-4Functional-Dependency-Theory函数依赖理论"><a href="#6-4Functional-Dependency-Theory函数依赖理论" class="headerlink" title="6.4Functional Dependency Theory函数依赖理论"></a>6.4Functional Dependency Theory函数依赖理论</h3><p>我们现在考虑范式理论，它告诉我们一组给定的函数依赖关系在<strong>逻辑蕴涵logically imply</strong>些函数依赖关系</p>
<p>然后，我们开发<strong>算法algorithms</strong>以生成<strong>无损分解lossless decovmpositions</strong>为BCNF和3NF。</p>
<p>然后，我们开发算法来测试分解是否<strong>保留依赖dependency-preserving</strong></p>
<h4 id="6-4-1函数依赖集的闭包Closure-of-a-Set-of-Functional-Dependencies"><a href="#6-4-1函数依赖集的闭包Closure-of-a-Set-of-Functional-Dependencies" class="headerlink" title="6.4.1函数依赖集的闭包Closure of a Set of Functional Dependencies"></a>6.4.1函数依赖集的闭包Closure of a Set of Functional Dependencies</h4><p>给定关系模式r(R)，如果r(R)的每一个满足F的实例也满足f，则R上的函数依赖f被r上的函数依赖集F<strong>逻辑蕴含（logically imply）</strong>。eg.如果 <em>A</em> → <em>B</em> and <em>B</em> → <em>C</em>, 那么<em>A</em> → <em>C</em></p>
<p>F<sup>+</sup>符号来表示F集合的<strong>闭包（closure）</strong>，也就是能够从给定F集合推导出的<strong>所有</strong>函数依赖的集合。F<sup>+</sup> 是 F 的超集superset。</p>
<p>我们可以使用以下三条规则寻找逻辑蕴涵的函数依赖，通过反复应用这些规则，可以找出给定F的全部F<sup>+</sup>，这组规则称为Armstrong‘s axioms（公理）</p>
<blockquote>
<ol>
<li><p>if β ⊆ α , then α → β           **(reflevity)**自反律</p>
</li>
<li><p>if α → β, then  γ α →γ β       **(augmentation)**增广律</p>
</li>
<li><p>if α → β , and β  → γ , then  α → γ  **(transitivity)**传递律</p>
</li>
</ol>
<p>Armstrong 公理是</p>
<ul>
<li><p>sound（正确有效的），因为它们不产生任何错误的函数依赖，只产生成立的函数依赖。</p>
</li>
<li><p>complete （完备的），因为对于给定函数依赖集F，它们能产生全部F<sup>+</sup>.</p>
</li>
</ul>
<p>为进一步简化，可以使用以下附加规则：</p>
<ol>
<li><p>If  α → β holds <em>a</em>nd α → γ  holds,  then α → β γ  holds **(union)**合并律</p>
</li>
<li><p>If α → β γ holds,  then  α → β holds and α → γ  holds **(decomposition)**分解律</p>
</li>
<li><p>If α → β holds <em>a</em>nd β γ → δ holds,  then α γ → δ holds **(pseudotransitivity)**伪传递率</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>计算F<sup>+</sup>步骤：</p>
<p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110150939502.png"></p>
</blockquote>
<h4 id="6-4-2属性集的闭包Closure-of-Attribute-Sets"><a href="#6-4-2属性集的闭包Closure-of-Attribute-Sets" class="headerlink" title="6.4.2属性集的闭包Closure of Attribute Sets"></a>6.4.2属性集的闭包Closure of Attribute Sets</h4><p>如果α → B，我们称属性B被 α <strong>函数确定（functionally determine）</strong></p>
<p>我们将函数依赖集F下被 α 函数确定的所有属性的集合称为F下α 的闭包，记为 α<sup>+</sup>.</p>
<blockquote>
<p>计算α<sup>+</sup>的算法：</p>
<p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110150954292.png"></p>
<p>第一步：自反律</p>
<p>循环内：自反+传递（if后合并律）</p>
<p>有优化，以后讲</p>
</blockquote>
<p>属性闭包算法的多种用途：</p>
<ul>
<li>判断α是否是R的超码（计算α<sup>+</sup>，检查α<sup>+</sup>是否包含R中的所有属性）</li>
<li><font color="red">※有用</font>：通过检查是否β ⊆ α<sup>+</sup>，我们可以检查函数依赖 α → β是否成立（是否属于F<sup>+</sup>）。</li>
<li>计算F<sup>+</sup>的方法：对任意的 γ ⊆ R，，我们找到γ<sup>+</sup>；对任意的S ⊆ γ<sup>+</sup>，我们输出一个函数依赖 γ → S。</li>
</ul>
<h4 id="6-4-3正则覆盖Canonical-Cover"><a href="#6-4-3正则覆盖Canonical-Cover" class="headerlink" title="6.4.3正则覆盖Canonical Cover"></a>6.4.3正则覆盖Canonical Cover</h4><p>函数依赖可能有<strong>冗余依赖项 （redundant dependencies）</strong>，可以从其他依赖项推断出这些依赖项</p>
<p>直观的说，F 的正则覆盖是一组等效于 F 的“最小”函数依赖项，没有冗余依赖关系或依赖关系的冗余部分</p>
<h5 id="无关属性extraneous-attribute"><a href="#无关属性extraneous-attribute" class="headerlink" title="无关属性extraneous attribute"></a><strong>无关属性extraneous attribute</strong></h5><blockquote>
<p>如果去除函数依赖中的一个属性不改变该函数依赖集的闭包，则称该属性是无关的（extraneous）。<strong>无关属性（extraneous attribute）</strong>的形式化定义如下：考虑函数依赖集F及F中的函数依赖α → β。</p>
<ul>
<li>如果A ∈ α 并且F逻辑蕴涵（ F - { α → β } ）∪ { ( α  - A )→ β}，则属性A在 α 中是无关的。</li>
<li>如果A ∈ β并且函数依赖集（ F - { α → β } ）∪ { α  → ( β- A ) }逻辑蕴涵F，则属性A 在 β中是无关的。</li>
</ul>
</blockquote>
<blockquote>
<p>如何<strong>检验</strong>一个属性是无关属性。令R为一关系模式，且F是在R上成立的给定函数依赖集，考虑依赖 α → β 中的一个属性A</p>
<ul>
<li>如果A ∈ β ，计算F‘下的α<sup>+</sup>(α的闭包)；如果α<sup>+</sup>包含A ，则A在β中是无关的。</li>
<li>如果A ∈ α ，令 γ = α - { A }，计算F下的γ<sup>+</sup>(γ的闭包)；如果γ<sup>+</sup>包含β中的所有属性，则A在α 中是无关的。</li>
</ul>
</blockquote>
<h5 id="正则覆盖Canonical-Cover"><a href="#正则覆盖Canonical-Cover" class="headerlink" title="正则覆盖Canonical Cover"></a>正则覆盖Canonical Cover</h5><p>F 的<strong>正则覆盖canonical cover</strong>F<sub>c</sub>是一个依赖集 ，使得 F 逻辑蕴涵 F<sub>c</sub> 中的所有依赖，并且 F<sub>c</sub> 逻辑蕴涵 F 中的所有依赖，此外Fc必须具有如下性质：</p>
<ol>
<li>F<sub>c</sub>中任何函数依赖都不含无关属性</li>
<li>F<sub>c</sub> 中函数依赖的左半部都是唯一的。即，F<sub>c</sub>中不存在两个依赖 α1 → β1和 α1 → β1，满足 α1= α2。</li>
</ol>
<blockquote>
<p>正则覆盖算法：</p>
<p>F<sub>c</sub> = F(<font color="red">注意：以下的F都为F<sub>c</sub></font>)</p>
<p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110151013372.png"></p>
<p>注意：删除某些无关属性后，合并律可能会又变得适用，因此必须重新应用</p>
<p>网上解释：<a href="https://my.oschina.net/u/4411837/blog/4322411#:~:text=3NF%E5%88%86%E8%A7%A3%E4%B8%80%E8%88%AC%E5%88%86%E4%B8%BA%E4%B8%A4%E7%A7%8D%EF%BC%9A%20%E4%BF%9D%E6%8C%81%E4%BE%9D%E8%B5%96,%E5%92%8C%20%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%20%E3%80%82">3NF分解</a></p>
<p>​	右侧先拆单，依赖依次删，再拆左非单</p>
</blockquote>
<h4 id="6-4-4无损分解Lossless-join-Decomposition"><a href="#6-4-4无损分解Lossless-join-Decomposition" class="headerlink" title="6.4.4无损分解Lossless-join Decomposition"></a>6.4.4无损分解Lossless-join Decomposition</h4><p>无损分解和无损连接分解是相同的（有损分解和有损连接分解同理）</p>
<blockquote>
<p>无损分解指的是对关系模式分解时，原关系模型下任一合法的关系值在分解之后应能通过自然联接运算恢复起来(分解后替代没有信息损失)。反之，则称为有损分解。</p>
</blockquote>
<p>对于 R = （R1， R2） 的情况，我们要求对于架构 R 上的所有可能关系 R满足：r = Π <sub>R<sub>1</sub></sub>(r ) ⋈ Π<sub>R<sub>2</sub></sub>(r) ，则将 R 分解为 R1 和 R2 是无损分解</p>
<p><strong>检验无损分解</strong>：如果以下两个函数依赖（<strong>R1∩R2→R1 	R1∩R2→R2</strong>）中至少有一个属于 F<sup>+</sup> 中时，则为无损分解，换句话说，如果<strong>R1∩R2是R1或R2的超码</strong>，R上的分解就是无损分解</p>
<h4 id="6-4-5保持依赖Dependency-Preservation"><a href="#6-4-5保持依赖Dependency-Preservation" class="headerlink" title="6.4.5保持依赖Dependency Preservation"></a>6.4.5保持依赖Dependency Preservation</h4><p>令F为模式R上的一个函数依赖集，R1,R2,…,Rn为R的一个分解。F在R<sub>i</sub>的**限定(restriction)<strong>是</strong>F<sup>+</sup>**中所有只包含Ri中属性的函数依赖的集合F<sub>i</sub>。由于一个限定中的所有函数依赖只涉及一个关系模式的属性，因此判断这种依赖是否满足可以只检查一个关系。</p>
<p><strong>保持依赖Dependency Preservation</strong>：</p>
<ul>
<li><p>如果F上的每一个函数依赖都在其分解后的某一个关系上成立 ⇒ 分解是函数依赖的</p>
</li>
<li><p>对F上的<strong>每一个</strong>α→β使用下面的过程：</p>
<p>result := α ;（赋值语句）</p>
<p>while(result发生变化)do</p>
<p>​	for each 分解后的R</p>
<p>​		t=(result∩Ri)+ ∩Ri  </p>
<p>​		result=result∪t</p>
<p>这里的属性闭包是在函数依赖集F下计算出来的。如果result中包含了β的所有属性，则函数依赖α→β。<strong>分解是保持依赖的当且仅当上述过程中F的所有依赖都被保持。</strong></p>
</li>
</ul>
<p>是无损分解不一定保持函数依赖（PPT p31）</p>
<p>如果 (<em>F</em><sub>1</sub> ∪ <em>F</em><sub>2</sub> ∪ <em>…</em> ∪ <em>F</em><sub>n</sub> )<sup>+</sup> = <em>F</em> <sup><em>+</em></sup>，则分解为保持依赖的</p>
<p>为了检查在将 R 分解为 R1、R2、…， Rn 时是否保留了依赖项α → β，我们应用以下测试（对 F 执行属性闭包）算法和上面相同</p>
<p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110151047658.png"></p>
<p>我们将测试应用于 F 中的所有依赖项，以检查分解是否保持依赖</p>
<p>此判定方法的代价是多项式时间（polynomial time），而不是计算 F<sup>+ </sup>和（F<sub>1</sub> ∪ F<sub>2</sub> ∪ …∪ F<sub>n</sub>）<sup>+</sup>所需的指数时间的代价</p>
<h3 id="6-5Algorithms-for-Functional-Dependencies分解算法B站"><a href="#6-5Algorithms-for-Functional-Dependencies分解算法B站" class="headerlink" title="6.5Algorithms for Functional Dependencies分解算法B站"></a>6.5Algorithms for Functional Dependencies分解算法<a href="https://www.bilibili.com/video/BV1CD4y1974g?from=search&amp;seid=11954966729834900882&amp;spm_id_from=333.337.0.0">B站</a></h3><h4 id="6-5-1-BCNF-Decomposition-Algorithm分解算法"><a href="#6-5-1-BCNF-Decomposition-Algorithm分解算法" class="headerlink" title="6.5.1 BCNF Decomposition Algorithm分解算法"></a>6.5.1 BCNF Decomposition Algorithm分解算法</h4><p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110151106877.png"></p>
<h4 id="6-5-2-3NF-Decomposition-Algorithm分解算法"><a href="#6-5-2-3NF-Decomposition-Algorithm分解算法" class="headerlink" title="6.5.2 3NF Decomposition Algorithm分解算法"></a>6.5.2 3NF Decomposition Algorithm分解算法</h4><p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110151115315.png"></p>
<blockquote>
<p> 书中有可选的移除冗余关系的办法</p>
<p> 上述算法确保：每个关系模式Ri都符合3NF	分解保留依赖和无损连接。</p>
<p> 网上口诀：保函依赖分解题，先求最小依赖集（正则）。</p>
<p> ​		依赖两侧未出现，分成子集放一边，剩余依赖变子集。</p>
<p> ​		若要连接成无损，再添候选做子集。</p>
</blockquote>
<h4 id="6-5-3-BCNF和3NF的比较"><a href="#6-5-3-BCNF和3NF的比较" class="headerlink" title="6.5.3 BCNF和3NF的比较"></a>6.5.3 BCNF和3NF的比较</h4><p>3NF的一个优点是，我们总是可以在满足无损分解和保持依赖的前提下得到3NF设计</p>
<p>3NF的一个缺点是，我们可能不得不用空值表示数据项间的某些可能有意义的联系，并且存在信息重复的问题。</p>
<p>对应用函数依赖进行数据库设计的目标是：1.BCNF	2.无损	3.保持依赖</p>
<p>如果不能全部做到，可以接受 1.缺少保持依赖	2. 3NF导致的冗余</p>
<h3 id="6-6Decomposition-Using-Multivalued-Dependencies-使用多值依赖的分解（第四范式的范围）"><a href="#6-6Decomposition-Using-Multivalued-Dependencies-使用多值依赖的分解（第四范式的范围）" class="headerlink" title="6.6Decomposition Using Multivalued Dependencies 使用多值依赖的分解（第四范式的范围）"></a>6.6Decomposition Using Multivalued Dependencies 使用多值依赖的分解（第四范式的范围）</h3><h4 id="Multivalued-Dependencies-MVDs-多值依赖"><a href="#Multivalued-Dependencies-MVDs-多值依赖" class="headerlink" title="Multivalued Dependencies (MVDs)多值依赖"></a>Multivalued Dependencies (MVDs)多值依赖</h4><p>多值依赖并不排除某些元组的存在，而是要求某种形式的其他元组存在于关系中，由于这个原因，函数依赖有时称为相等产生依赖（equality-generating dependency），而多值依赖称为元组产生依赖（tuple-generating dependency）</p>
<blockquote>
<p>令R为关系模式并且令α ⊆ <em>R</em> 且 β ⊆ <em>R.</em>  <strong>多值依赖</strong> α →→ β在R上成立的条件是：</p>
<p>在R的任意合法实例中，对于r中任意一对满足<em>t</em><sub>1</sub>[α] = t<sub>2</sub> <em>[α]的元组对</em>t<sub>1</sub>和 <em>t<sub>2</sub><em>，r中都存在元组</em>t</em><sub>3</sub>和*t<sub>4</sub>*，使得</p>
<p><em>t</em><sub>1</sub>[α] = <em>t<sub>2</sub></em> [α] = <em>t</em><sub>3</sub> [α] = <em>t</em><sub>4</sub> [α]</p>
<p><em>t</em><sub>3</sub>[β] = <em>t</em><sub>1</sub> [β]</p>
<p><em>t</em><sub>3</sub>[<em>R</em> <em>–</em> β] = <em>t</em><sub>2</sub>[<em>R</em> <em>–</em> β]</p>
<p><em>t</em><sub>4</sub> [β] = <em>t</em><sub>2</sub>[β]</p>
<p><em>t</em><sub>4</sub>[<em>R</em> <em>–</em> β] = <em>t</em><sub>1</sub>[<em>R</em> <em>–</em> β] </p>
</blockquote>
<h4 id="Use-of-Multivalued-Dependencies多值依赖关系的使用"><a href="#Use-of-Multivalued-Dependencies多值依赖关系的使用" class="headerlink" title="Use of Multivalued Dependencies多值依赖关系的使用"></a>Use of Multivalued Dependencies多值依赖关系的使用</h4><p>我们以两种方式使用多值依赖：</p>
<ol>
<li>检验关系以<font color="red">确定determine</font>它们在一组给定的功能和多值依赖关系下是否合法</li>
<li>在合法关系集上指定约束； 因此，我们将只考虑满足给定的函数依赖集和多值依赖集的关系。</li>
</ol>
<p>如果关系 r 无法满足给定的多值依赖关系，可以通过向 r 中增加元组构造一个确实满足多值依赖关系的关系r ‘。</p>
<p>从多值依赖的定义中可以推导出：α →→ β ⇒ α →→ β，也就是说每一个函数依赖也是一个多值依赖</p>
<p>D 的<strong>闭包 D<sup>+</sup></strong> 是由D 逻辑蕴涵的所有函数和多值依赖关系的集合。 我们可以从D计算D<sup>+</sup>，使用函数依赖关系和多值依赖关系的形式定义。 我们可以用这样的推理来管理非常简单的多值依赖关系，这在实践中似乎是最常见的。 对于复杂的依赖关系，最好使用推理规则系统来推理依赖关系集。</p>
<h4 id="Fourth-Normal-Form第四范式"><a href="#Fourth-Normal-Form第四范式" class="headerlink" title="Fourth Normal Form第四范式"></a>Fourth Normal Form第四范式</h4><p>关系模式 R 相对于函数和多值依赖关系的集合 D 在 4NF 中，如果对于 D+ 中形式的α →→ β的所有多值依赖项，其中α ⊆ R 和 β ⊆ R 至少有以下一项成立：</p>
<ul>
<li><p>α →→ β  是平凡的（即β ⊆ α 或 β ∪ α = R）</p>
</li>
<li><p>α 是 R 超码</p>
</li>
</ul>
<p>如果关系在 4NF 中，则在 BCNF 中</p>
<h4 id="多值依赖关系的限制"><a href="#多值依赖关系的限制" class="headerlink" title="多值依赖关系的限制"></a>多值依赖关系的限制</h4><p>==D 对 Ri 的限制是集合 Di 由 D+ 中仅包含 Ri 属性的所有功能依赖项 表单的所有多值依赖项   （  Ri） 其中   Ri 和    位于 D+ 中==</p>
<p>第四范式分解算法</p>
<p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110151321527.png"></p>
<h3 id="6-7More-Normal-Form更多的范式"><a href="#6-7More-Normal-Form更多的范式" class="headerlink" title="6.7More Normal Form更多的范式"></a>6.7More Normal Form更多的范式</h3><h4 id="6-8Database-Design-Process数据库设计过程"><a href="#6-8Database-Design-Process数据库设计过程" class="headerlink" title="6.8Database-Design Process数据库设计过程"></a>6.8Database-Design Process数据库设计过程</h4><h4 id="规范化的目标Goals-of-Normalization"><a href="#规范化的目标Goals-of-Normalization" class="headerlink" title="规范化的目标Goals of Normalization"></a>规范化的目标Goals of Normalization</h4><blockquote>
<ol>
<li>设R是具有一组函数依赖项的关系模式</li>
<li>确定关系R是否处于“良好”形式。</li>
<li>如果关系模式R不是“good”形式，就把R分解为一组关系方案 { R <sub>1</sub>, R <sub>2</sub>, …, R <sub>n</sub> }使得<ol>
<li>每个关系模式都处于good形式</li>
<li>分解时<strong>无损连接分解（lossless-join decomposition）</strong></li>
<li>分解最好（preferably）<strong>保留依赖（dependency preserving）</strong></li>
</ol>
</li>
</ol>
<p>BCNF有多好？PPT p37==？==</p>
<p>​	BCNF中似乎存在未充分规范化的数据库模式。</p>
</blockquote>
<h3 id="6-9Modeling-Temporal-Data时态数据建模"><a href="#6-9Modeling-Temporal-Data时态数据建模" class="headerlink" title="6.9Modeling Temporal Data时态数据建模"></a>6.9Modeling Temporal Data时态数据建模</h3><h2 id="第七章-Transactions事务"><a href="#第七章-Transactions事务" class="headerlink" title="第七章 Transactions事务"></a>第七章 Transactions事务</h2><h3 id="Transaction-Concept事务概念"><a href="#Transaction-Concept事务概念" class="headerlink" title="Transaction Concept事务概念"></a>Transaction Concept事务概念</h3><p><strong>ACID特性（Properties）：</strong></p>
<p>​	<strong>事务</strong>是访问并可能更新各种数据项的程序执行<strong>单元unit</strong>。为了保持数据的完整性，数据库系统必须确保：</p>
<ol>
<li><p><strong>原子性Atomicity</strong>:事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映。</p>
</li>
<li><p><strong>一致性Consistency</strong>:隔离执行事务时(换言之                                                                                                                                 ，在没有其他事务并发执行的情况下)保持数据库的一致性。</p>
</li>
<li><p><strong>隔离性Isolation</strong>:尽管多个事务可能并发执行，但系统保证，对于任何一对事务Ti和Tj)，在Ti看来,Tj或者在Ti开始之前已经完成执行，或者在Ti完成之后开始执行。因此，每个事务都感觉不到系统中有其他事务在并发地执行。</p>
</li>
<li><p><strong>持久性Durability</strong>:一个事务成功完成后，它对数据库的改变必须是永久的，即使出现系统故障。</p>
</li>
</ol>
<h3 id="Transaction-State事务状态"><a href="#Transaction-State事务状态" class="headerlink" title="Transaction State事务状态"></a>Transaction State事务状态</h3><p>我们需要更准确地定义一个事务成功完成的含义。为此我们建立了一个简单的抽象事务模型。事务必须处于以下状态之一。</p>
<ul>
<li>**活动的( active)**：初始状态,事务执行时处于这个状态。</li>
<li>**部分提交的( partially committed)**：最后一条语句执行后。</li>
<li><strong>失败的( failed)</strong>:发现正常的执行不能继续后。</li>
<li><strong>中止的(aborted)</strong>:事务回滚并且数据库已恢复到事务开始执行前的状态后。</li>
<li><strong>提交的(committed)</strong>:成功完成后。</li>
</ul>
<p>在不出现故障的情况下，所有的事务都能成功完成。但是，事务并非总能顺利执行完成，这种事务称为中止事务。如果要保持事务的原子性，中止事务必须对数据库的状态不造成影响。这样中止事务对数据库所做过的任何改变都必须撤销。一旦中止事务造成的变更撤销，我们就说事务<strong>已回滚rolled back</strong>。</p>
<p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110151355860.png"></p>
<h4 id="Implementation-of-Atomicity-and-Durability原子性和持久性的实现"><a href="#Implementation-of-Atomicity-and-Durability原子性和持久性的实现" class="headerlink" title="Implementation of Atomicity and Durability原子性和持久性的实现"></a><strong>Implementation of Atomicity and Durability原子性和持久性的实现</strong></h4><p>数据库系统的恢复管理组件实现了对原子性和持久性的支持。（eg. shadow-database影子数据库，维持指针dp-pointer，指向数据库的当前副本，以下两种情况需要更新数据库新副本 1.事务达到部分提交  2.所有更新的页面都已刷新到磁盘。）</p>
<p><img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110151419071.png"></p>
<p>db_pointer始终指向数据库的当前一致副本。 如果事务失败，可以使用db_pointer指向的旧一致副本，并且可以删除卷影副本。 </p>
<p>影子数据库方案： </p>
<blockquote>
<p>假定一次只有一个事务处于活动状态。</p>
<p>假定磁盘不会出现故障</p>
<p>对文本编辑器很有用，但是 对于大型数据库来说效率极低（为什么？ 称为卷影分页的变体可减少数据复制，但对于大型数据库仍然不切实际 </p>
<p>不处理并发事务</p>
</blockquote>
<h3 id="Concurrent-Executions并发执行"><a href="#Concurrent-Executions并发执行" class="headerlink" title="Concurrent Executions并发执行"></a>Concurrent Executions并发执行</h3><p>允许多个事务在系统中同时运行。 优点是： </p>
<ul>
<li>提高了处理器和磁盘利用率<strong>increased processor and disk utilization</strong>，从而提高了事务吞吐量 <ul>
<li>例如，一个事务可以使用 CPU，而另一个事务正在读取或写入磁盘</li>
</ul>
</li>
<li>减少事务的平均响应时间<strong>reduced average response time</strong> ：短事务不需要等待长事务。</li>
</ul>
<p>并发控制方案<strong>Concurrency control schemes</strong> – 实现隔离的机制 </p>
<ul>
<li>也就是说，控制并发事务之间的交互，以防止它们破坏数据库的一致性</li>
</ul>
<h4 id="Schedule机制"><a href="#Schedule机制" class="headerlink" title="Schedule机制"></a>Schedule机制</h4><p>机制是一系列指令，用于指定执行并发事务指令的时间顺序 </p>
<ul>
<li><p>一组交易的时间表必须由这些交易的所有指令组成</p>
</li>
<li><p>必须保留指令在每个单独交易中出现的顺序。</p>
</li>
</ul>
<p>成功完成其执行的事务将具有提交<strong>commit</strong>指令作为最后一个语句</p>
<p>未能成功完成其执行的事务将具有中止<strong>abort</strong>指令作为最后一个语句</p>
<h3 id="Serializability可串行化"><a href="#Serializability可串行化" class="headerlink" title="Serializability可串行化"></a>Serializability可串行化</h3><p><strong>基本假设</strong> – 每个事务都保持数据库的一致性。 因此，一组事务的串行执行可保持数据库的一致性。</p>
<p>如果某个（可能是并发的）计划等效于串行计划，则该计划是可序列化的。 不同形式的附表等同产生了以下概念： 1. 冲突可序列化<strong>conflict serializability</strong>           2. 视图可序列化性<strong>view serializability</strong></p>
<p>简化的交易视图 我们忽略读取和写入指令以外的操作 我们假设事务可以在读取和写入之间对本地缓冲区中的数据执行任意计算。 我们简化的时间表仅包括读取和写入指令。</p>
<h4 id="Conflicting-Instructions-冲突的说明"><a href="#Conflicting-Instructions-冲突的说明" class="headerlink" title="Conflicting Instructions 冲突的说明"></a>Conflicting Instructions 冲突的说明</h4><p>交易的指令 li 和 lj 分别为 Ti 和 Tj，当且仅当存在一些由 li 和 lj 访问的项目 Q 时发生冲突，并且这些指令中至少有一个写了 Q。    </p>
<ol>
<li>li = read（Q）， lj = read（Q）。  li 和 lj 不冲突。</li>
<li>li = read（Q）， lj = write（Q）。 它们相互冲突。</li>
<li>li = write（Q）， lj = read（Q）。  它们相互冲突</li>
<li>li = write（Q）， lj = write（Q）。</li>
</ol>
<p>它们相互冲突 直观地说，li和lj之间的冲突迫使它们之间有一个（逻辑的）时间顺序。 如果 li 和 lj 在一个时间表中是连续的，并且它们不冲突，那么即使它们在时间表中互换(<strong>interchanged</strong>)，它们的结果也将保持不变。</p>
<h4 id="Conflict-Serializability冲突可串行化"><a href="#Conflict-Serializability冲突可串行化" class="headerlink" title="Conflict Serializability冲突可串行化"></a>Conflict Serializability冲突可串行化</h4><p>如果一个调度S可以通过一系列不冲突指令的交换来转换为调度S’，我们说S和S’是冲突等价<strong>conflict equivalent</strong>的。 </p>
<p>我们称一个调度 S 是冲突可串行化<strong>conflict serializable</strong>的，如果它与一个串行调是冲突等价<strong>conflict equivalent</strong>的、</p>
<h4 id="Other-Notions-of-Serializability可串行化性的其他概念"><a href="#Other-Notions-of-Serializability可串行化性的其他概念" class="headerlink" title="Other Notions of Serializability可串行化性的其他概念"></a>Other Notions of Serializability可串行化性的其他概念</h4><blockquote>
<p> 下面的计划生成与串行计划相同的结果，&lt; T1、T5 &gt;，但不是冲突等效或视图等效。</p>
<p> <img src="/2023/01/10/shu-ju-ku-gai-lun-bi-ji/image-20230110151442056.png"></p>
<p> 确定这种等效性需要分析读取和写入以外的操作。</p>
</blockquote>
<h3 id="Testing-for-Serializability测试可串行化"><a href="#Testing-for-Serializability测试可串行化" class="headerlink" title="Testing for Serializability测试可串行化"></a>Testing for Serializability测试可串行化</h3><p>考虑一组事务 T1、T2、…、Tn 的某个时间表 </p>
<p>优先级图<strong>Precedence graph</strong> — 一个直接图，其中顶点是事务（名称）。</p>
<p>如果两个事务发生冲突，我们绘制一个从 Ti 到 Tj 的弧线，Ti 访问了之前发生冲突的数据项。 在Tj执行read(Q)之前，Ti执行write(Q) 在Tj执行之前write(Q)，Ti执行 read(Q) 在Tj执行write(Q)之前，Ti执行write(Q) 我们可以按访问的项目标记弧线。</p>
<p>当且仅当明细表的优先级图是非循环的acyclic时，调度才可冲突序列化conflict serializable 。 </p>
<p>存在周期检测算法，需要 n<sup>2</sup> 数量级的运算，其中 n 是图中的顶点数。 （更好的算法采用 n + e 阶，其中 e 是边数。)</p>
<p>如果优先图是非循环的，则可以通过图的拓扑排序<em>topological sorting</em> 来获得可序列化顺序。</p>
<h3 id="Recoverability"><a href="#Recoverability" class="headerlink" title="Recoverability"></a>Recoverability</h3><h4 id="Recoverable-Schedules可恢复调度"><a href="#Recoverable-Schedules可恢复调度" class="headerlink" title="Recoverable Schedules可恢复调度"></a>Recoverable Schedules可恢复调度</h4><p>可恢复调度( recoverable schedule):对于每对事务Ti和Tj，如果Tj读取了之前由Ti所写的数据项，则Ti先于Tj提交。例如，如果要使调度9是可恢复的，则T,应该推迟到T提交后再提交。</p>
<h4 id="Cascading-Rollbacks级联回滚"><a href="#Cascading-Rollbacks级联回滚" class="headerlink" title="Cascading Rollbacks级联回滚"></a>Cascading Rollbacks级联回滚</h4><p>因单个事务故障导致一系列事务回滚的现象称为<strong>级联回滚</strong>( cascading rollback)。</p>
<h4 id="Cascadeless-Schedule无级联调度"><a href="#Cascadeless-Schedule无级联调度" class="headerlink" title="Cascadeless Schedule无级联调度"></a>Cascadeless Schedule无级联调度</h4><p>级联回滚导致撤销大量工作，是我们不希望发生的。我们希望对调度加以限制，避免级联回滚发生。这样的调度称为无级联调度。规范地说，**无级联调度(cascadeless schedule)**应满足:对于每对事务Ti和Tj，如果Tj读取了先前由Ti所写的数据项，则Ti必须在Tj这一读操作前提交。容易验证每一个无级联调度也都是可恢复的调度。</p>
<h4 id="Concurrency-Control并发控制"><a href="#Concurrency-Control并发控制" class="headerlink" title="Concurrency Control并发控制"></a>Concurrency Control并发控制</h4><p>数据库必须提供一种机制，以确保所有可能的调度都是 1.冲突或视图可序列化。 2.是可恢复的，最好是无级联cascadeless的</p>
<p>一次只能执行一个事务的策略会生成串行计划，但并发程度较差 </p>
<p>在执行调度后测试其可串行化有点为时已晚！ </p>
<p>目标 – 开发可序列化的并发控制协议。</p>
<h4 id="Concurrency-Control-vs-Serializability-Tests并发控制与可序列化性测试"><a href="#Concurrency-Control-vs-Serializability-Tests并发控制与可序列化性测试" class="headerlink" title="Concurrency Control vs. Serializability Tests并发控制与可序列化性测试"></a>Concurrency Control vs. Serializability Tests并发控制与可序列化性测试</h4><p>并发控制协议允许并发调度，但要确保调度是可冲突/视图序列化的，并且是可恢复和无级联的。</p>
<p>并发控制协议在创建优先级图时通常不会检查优先级图</p>
<p>​	相反，协议强加了一个避免不可序列化的时间表的纪律。 </p>
<p>不同的并发控制协议在它们允许的并发量和它们产生的开销量之间提供了不同的权衡。 </p>
<p>可串行化测试有助于我们理解并发控制协议为何正确。</p>
<h4 id="Weak-Levels-of-Consistency一致性水平低"><a href="#Weak-Levels-of-Consistency一致性水平低" class="headerlink" title="Weak Levels of Consistency一致性水平低"></a>Weak Levels of Consistency一致性水平低</h4><p>某些应用程序更愿意处于较低的一致性水平下，允许不可序列化的计划</p>
<p>​	例如，想要获得所有帐户的近似总余额的只读事务 </p>
<p>​	例如，为查询优化计算的数据库统计信息可以是近似值</p>
<p>​	此类事务不必相对于其他事务进行序列化</p>
<p>性能的精度权衡Tradeoff accuracy for performance</p>
<h4 id="Levels-of-Consistency-in-SQL-92一致性级别"><a href="#Levels-of-Consistency-in-SQL-92一致性级别" class="headerlink" title="Levels of Consistency in SQL-92一致性级别"></a>Levels of Consistency in SQL-92一致性级别</h4><p>•<strong>Serializable</strong> — default默认</p>
<p>•<strong>Repeatable read可重复读取</strong> — only committed records to be read, repeated reads of same record must return same value. However, a transaction may not be serializable – it may find some records inserted by a transaction but not find others.仅要读取的已提交记录，重复读取同一记录必须返回相同的值。 但是，事务可能不可序列化 – 它可能会找到事务插入的某些记录，但找不到其他记录。</p>
<p>•<strong>Read committed读取已提交</strong> — only committed records can be read, but successive reads of record may return different (but committed) values.只能读取已提交的记录，但连续读取的记录可能会返回不同（但已提交）的值。</p>
<p>•<strong>Read uncommitted读取未提交</strong> — even uncommitted records may be read.  甚至可能读取未提交的记录。</p>
<p>警告：默认情况下，某些数据库系统不确保可序列化调度为默认 例如，Oracle和PostgreSQL默认支持称为快照隔离的一致性级别（不是SQL标准的一部分）</p>
<h3 id="Implementation-of-Isolation"><a href="#Implementation-of-Isolation" class="headerlink" title="Implementation of Isolation"></a>Implementation of Isolation</h3><h4 id="Transaction-Definition-in-SQLSQL-中的事务定义"><a href="#Transaction-Definition-in-SQLSQL-中的事务定义" class="headerlink" title="Transaction Definition in SQLSQL 中的事务定义"></a>Transaction Definition in SQLSQL 中的事务定义</h4><p>数据操作语言必须包含用于指定组成事务的操作集的构造。 </p>
<p>在 SQL 中，事务以隐式方式开始。 </p>
<p>SQL 中的事务的结束方式为： </p>
<p>​	提交工作<strong>Commit work</strong> 提交当前事务并开始一个新事务。 </p>
<p>​	回滚工作<strong>Rollback work</strong> 会导致当前事务中止。 </p>
<p>在几乎所有数据库系统中，默认情况下，如果每个 SQL 语句成功执行，也会隐式提交 </p>
<p>​	隐式提交可以通过数据库指令关闭，例如，在JDBC中，connection. setAutoCommit（false）;</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
